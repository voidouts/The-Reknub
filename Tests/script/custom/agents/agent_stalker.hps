//----------------------------------------------------------------------
//----------------------------------------------------------------------

////////////////////////////////
// STALKER                    //
////////////////////////////////

//----------------------------------------------------------------------

#include "agents/Agent_Humanoid.hps"
#include "helpers/helper_player.hps"
#include "helpers/helper_game.hps"
#include "custom/helpers/helper_player_custom.hps"
#include "helpers/helper_effects.hps"
#include "custom/player/PlayerTypes_Custom.hps"
#include "base/Base_Types.hps"
#include "custom/agents/agent_types_custom.hps"
#include "custom/components/ComponentInterfaces_Custom.hps"
#include "custom/helpers/helper_areas_custom.hps"
#include "helpers/helper_props.hps"
#include "helpers/helper_areas.hps"
#include "helpers/helper_items.hps"
#include "helpers/helper_effects_custom.hps"
#include "custom/helpers/helper_modules_custom.hps"
#include "custom/helpers/helper_props_custom.hps"

//----------------------------------------------------------------------

/////////////////////////////////////////
// SOUND
//{//////////////////////////////////////

//----------------------------------------------------------------------

const tString gsStalkerSound_PlayerDetected = "creatures/stalker/smell_end";
const tString gsStalkerSound_PlayerSpotted = "creatures/stalker/spot";
const tString gsStalkerSound_Attack = "creatures/stalker/attack";
const tString gsStalkerSound_Idle = "creatures/stalker/idle";
const tString gsStalkerSound_LookAround = "creatures/stalker/smell";
const tString gsStalkerSound_SoundHeard = "creatures/stalker/smell_end";
const tString gsStalkerSound_Search = "creatures/stalker/search";
const tString gsStalkerSound_Frustration = "creatures/stalker/fire_react";
const tString gsStalkerSound_Whine = "creatures/stalker/whine";
const tString gsStalkerSound_GasChoke = "creatures/stalker/gas_choke";
const tString gsStalkerSound_AngryShout = "creatures/stalker/attack";
const tString gsStalkerSound_BeHit = "creatures/stalker/pain_shot";
const tString gsStalkerSound_LostTrackSmall = "creatures/stalker/search_end";
const tString gsStalkerSound_ShotByGun = "creatures/stalker/pain_shot";
const tString gsStalkerSound_GeneratorOff = "creatures/stalker/power_down";
const tString gsStalkerSound_HitMetalDoor = "level_entity_shared/item_break/metal_door/impact";
const tString gsStalkerSound_CrawlOut = "creatures/stalker/exit";
const tString gsStalkerSound_CrawlIn = "creatures/stalker/retreat";
const tString gsStalkerSound_CrawlOutFoley = "creatures/stalker/tunnel_exit";
const tString gsStalkerSound_CrawlInFoley = "creatures/stalker/tunnel_enter";
const tString gsStalkerSound_HoleBreatheLoop = "creatures/stalker/tunnel_breathe_loop";
const tString gsStalkerSound_EmergeAlert = "creatures/stalker/tunnel_warning";
const tString gsStalkerSound_WallMoveLoop = "creatures/stalker/tunnel";
const tString gsStalkerSound_EmergeWarning = "creatures/stalker/tunnel_bark";
const tString gsStalkerSound_Talk = "creatures/stalker/talk";

//----------------------------------------------------------------------

//} END SOUND

//----------------------------------------------------------------------

/////////////////////////////////////////
// ANIMATION
//{//////////////////////////////////////

//----------------------------------------------------------------------

const tString gsStalkerAnim_Glimpse = "glimpse_ahead_loop";
const tString gsStalkerAnim_Glimpse_45_Left = "glimpse_left_45_loop";
const tString gsStalkerAnim_Glimpse_45_Right = "glimpse_right_45_loop";
const tString gsStalkerAnim_Glimpse_90_Left = "glimpse_left_90_loop";
const tString gsStalkerAnim_Glimpse_90_Right = "glimpse_right_90_loop";

const tString gsStalkerAnim_Alert = "alert";
const tString gsStalkerAnim_AlertCrampedArms = "alert_cramped";
const tString gsStalkerAnim_AlertCrampedFull = "alert_cramped_hunched";
const tString gsStalkerAnim_AlertCrampedStepBack = "alert_cramped_hunched_step_back";

const tString gsStalkerAnim_EnterHole = "crawl_into_hole";
const tString gsStalkerAnim_ExitHole = "crawl_out_of_hole";
const tString gsStalkerAnim_ExitHoleTurnLeft = "exit_hole_turn_left";
const tString gsStalkerAnim_ExitHoleTurnRight = "exit_hole_turn_right";
const tString[] gsStalkerAnim_HoleReachOut = { "hole_reach_out_1", "hole_reach_out_2", "hole_reach_out_3" };
const tString gsStalkerAnim_HoleReachOutEndL = "hole_reach_out_end_l";
const tString gsStalkerAnim_HoleReachOutEndR = "hole_reach_out_end_r";

const tString gsStalkerAnim_BeHit = "alert";

const tString gsStalkerAnim_LookAroundLong = "look_around";
const tString gsStalkerAnim_LookAroundLeft = "look_around_left";
const tString gsStalkerAnim_LookAroundRight = "look_around_right";
const tString gsStalkerAnim_ShrugOff = "shrug_off";
									
const tString gsStalkerAnim_HitObstacle_Sweep = "hit_obstacle_sweep";
const tString gsStalkerAnim_HitObstacle_Smash = "hit_obstacle_smash";
const tString gsStalkerAnim_HitObstacle_Shove = "hit_obstacle_shove";
const tString gsStalkerAnim_HitObstacle_Tackle = "hit_obstacle_shoulder";
													  
const tString gsStalkerAnim_KillPlayerFront = "death_front";
const tString gsStalkerAnim_KillPlayerFrontPlayerAnim = "player_death_front";
const tString gsStalkerAnim_KillPlayerBack = "death_back";
const tString gsStalkerAnim_KillPlayerBackPlayerAnim = "player_death_back";
const tString gsStalkerAnim_KillPlayerHoleLeft = "death_hole_left";
const tString gsStalkerAnim_KillPlayerHoleRight = "death_hole_right";
const tString gsStalkerAnim_KillPlayerHoleFront = "death_hole_front";
const tString gsStalkerAnim_KillPlayerHoleBack = "death_hole_back";
const tString gsStalkerAnim_KillPlayerHolePlayerAnimLeft = "player_death_hole_left";
const tString gsStalkerAnim_KillPlayerHolePlayerAnimRight = "player_death_hole_right";
const tString gsStalkerAnim_KillPlayerHolePlayerAnimFront = "player_death_hole_front";
const tString gsStalkerAnim_KillPlayerHolePlayerAnimBack = "player_death_hole_back";
const tString gsStalkerAnim_KillPlayerUnder = "death_under";
const tString gsStalkerAnim_KillPlayerUnderPlayerAnim = "player_death_under";
const tString gsStalkerAnim_KillPlayerLadder = "death_ladder";
const tString gsStalkerAnim_KillPlayerLadderPlayerAnim = "player_death_ladder";

const tString gsStalkerAnim_ThrowPlayer_Forward = "throw_forward_stand";
const tString gsStalkerAnim_ThrowPlayer_Back = "throw_backward_stand";
const tString gsStalkerAnim_ThrowPlayer_Left = "throw_left_stand";
const tString gsStalkerAnim_ThrowPlayer_Right = "throw_right_stand";
const tString gsStalkerAnim_ThrowPlayer_BehindPlayer = "throw_behind_player_stand";

const tString gsStalkerAnim_ThrowPlayer_Forward_Crouch = "throw_forward_crouch";
const tString gsStalkerAnim_ThrowPlayer_Back_Crouch = "throw_backward_crouch";
const tString gsStalkerAnim_ThrowPlayer_Left_Crouch = "throw_left_crouch";
const tString gsStalkerAnim_ThrowPlayer_Right_Crouch = "throw_right_crouch";
const tString gsStalkerAnim_ThrowPlayer_BehindPlayer_Crouch = "throw_behind_player_crouch";

const tString gsStalkerAnim_Idle = "idle_patrol";
const tString gsStalkerAnim_Walk = "walk_patrol";
const tString gsStalkerAnim_Run = "run_patrol";

const tString gsStalkerAnim_IdleStalk = "idle_stalk";
const tString gsStalkerAnim_WalkStalk = "walk_stalk";
const tString gsStalkerAnim_RunStalk = "run_stalk";

const tString gsStalkerAnim_IdleRage = "idle_rage";
const tString gsStalkerAnim_WalkRage = "walk_rage";
const tString gsStalkerAnim_RunRage = "run_rage";

const tString gsStalkerAnim_WalkCramped = "walk_cramped_patrol";
const tString gsStalkerAnim_WalkCrampedStalk = "walk_cramped_stalk";
const tString gsStalkerAnim_WalkCrampedRage = "walk_cramped_rage";

const tString gsStalkerAnim_WalkBackward = "walk_backward";
const tString gsStalkerAnim_WalkUprightA = "walk_upright_1";
const tString gsStalkerAnim_WalkUprightB = "walk_upright_2";
const tString gsStalkerAnim_WalkUprightBCramped = "walk_upright_2_cramped";

const tString gsStalkerAnim_TurnAround = "turn_180_slow";
const tString gsStalkerAnim_TurnAroundFast = "turn_180_fast";
const tString gsStalkerAnim_Turn_90_Left = "turn_90_left";
const tString gsStalkerAnim_Turn_90_Right = "turn_90_right";
const tString gsStalkerAnim_Turn_90_Fast_Left = "turn_90_fast_left";
const tString gsStalkerAnim_Turn_90_Fast_Right = "turn_90_fast_right";
const tString gsStalkerAnim_TurnLeftStopped = "stopped_turn_left";
const tString gsStalkerAnim_TurnRightStopped = "stopped_turn_right";
const tString gsStalkerAnim_TurnLeftWalk = "walk_turn_left";
const tString gsStalkerAnim_TurnRightWalk = "walk_turn_right";
const tString gsStalkerAnim_TurnLeftRun = "run_turn_left";
const tString gsStalkerAnim_TurnRightRun = "run_turn_right"; 

const tString gsStalkerAnim_Shot = "shot_start";
const tString gsStalkerAnim_ShotRun = "shot_run_start";
const tString gsStalkerAnim_ShotAlert = "shot_alert_start";
const tString gsStalkerAnim_ShotAttack = "shot_get_up_attack";
const tString gsStalkerAnim_ShotRetreat = "shot_get_up_retreat";
const tString gsStalkerAnim_ShotRecently = "shot_short_idle";
const tString gsStalkerAnim_ShotRecentlyAlert = "shot_short_alert";
const tString gsStalkerAnim_ShotRecentlyRun = "shot_short_run";
const tString gsStalkerAnim_HurtAdditive = "shot_additive";

const tString gsStalkerAnim_GoThroughVent = "go_through_vent";

const tString gsStalkerAnim_Hurt = "flinch";
const tString gsStalkerAnim_BreakDoorAlign = "walk_backward";

const tString gsStalkerAnim_SitStart = "sit_start";
const tString gsStalkerAnim_SitLoop = "sit_loop";
const tString gsStalkerAnim_SitEnd = "sit_end";

const tString gsStalkerAnim_ExamineRabbit = "examine_rabbit_doll";
const tString gsStalkerAnim_ExamineRabbitEnd = "examine_rabbit_doll_end";

const tString gsStalkerAnim_OpenDoorInLeft = "open_door_inward_left";
const tString gsStalkerAnim_OpenDoorInRight = "open_door_inward_right";
const tString gsStalkerAnim_OpenDoorOutLeft = "open_door_outward_left";
const tString gsStalkerAnim_OpenDoorOutRight = "open_door_outward_right";

const tString gsStalkerAnim_JumpLong = "jump_long";
const tString gsStalkerAnim_JumpShort = "jump_short";
const tString gsStalkerAnim_JumpShortTurnAround = "jump_short_180";
const tString gsStalkerAnim_JumpHangOnLedge = "jump_long_hang";
const tString gsStalkerAnim_JumpExtraLongHangOnLedge = "jump_extra_long_hang";
const tString gsStalkerAnim_JumpFail = "jump_fail";
const tString gsStalkerAnim_ClimbUpLedge = "climb_up_ledge";
const tString gsStalkerAnim_ClimbUpLedgeExtraLong = "climb_up_ledge_extra_long";
const tString gsStalkerAnim_ClimbUpLedgeTackle = "climb_up_ledge_tackle";
const tString gsStalkerAnim_ClimbUpLedgeTackleExtraLong = "climb_up_ledge_tackle_extra_long";
const tString gsStalkerAnim_FallStart = "fall_start";
const tString gsStalkerAnim_FallStartExtraLong = "fall_start_extra_long";
const tString gsStalkerAnim_Fall = "fall_loop";
const tString gsStalkerAnim_IdleToFall = "idle_to_fall";
const tString gsStalkerAnim_IdleToFallJumpLand = "idle_to_fall_jump_land";

const tString gsStalkerAnim_RunMapTransfer = "run_map_transfer";

const tString[] gsStalkerAnim_Head_Mouth = { "head_mouth_1", "head_mouth_2", "head_mouth_3" };
const tString[] gsStalkerAnim_Head_Twist = { "head_twist_1", "head_twist_2", "head_twist_3", "head_twist_4", "head_twist_5" };
const tString[] gsStalkerAnim_Head_Twitch = { "head_twitch_1", "head_twitch_2", "head_twitch_3", "head_twitch_4", "head_twitch_5" };

//----------------------------------------------------------------------

//} END ANIMATION

//----------------------------------------------------------------------

/////////////////////////////////////////
// SETTINGS
//{//////////////////////////////////////

//----------------------------------------------------------------------

const int[] glStalker_ShotCountToRetreat = { 1, 2 };

const int glStalker_IgnoreOccludedSoundMaxPrio = 3;
const int glStalker_GeneratorOnMinEmergeSoundPrio = 5;

const float gfStalker_AlertTime = 8.0f;

const float gfStalker_SightRange = 25.f;
const float gfStalker_SightRange_Easy = 20.f;
const float gfStalker_SightRange_Hard = 30.f;

const float gfStalker_RunSpeed = 6.2f;
const float gfStalker_AttackForce = 50.f;

const float gfStalker_PresenceProximityMaxDist = 30.f;
const float gfStalker_PresenceProximityRate = 1.f / 210.f;
const float gfStalker_PresenceOnScreenRate = 1.f / 60.f;
const float gfStalker_PresenceAggressiveRate = 1.f / 30.f;
const float gfStalker_PresenceDecreaseRate = 1.f / 240.f;

const float gfStalker_TenacityMin = 0.f;
const float gfStalker_TenacityMax = 2.f;

const float gfStalker_InHoleHearRadius = 8.f;
const float gfStalker_InHoleAlwaysHearRadius = 4.f;
const float gfStalker_CollidePropTrackTime = 4.f;
const float gfStalker_PreHuntMinDist = 4.f;
const float gfStalker_AutoRemovePathBlockerTime = 60.f * 5.f;
const float gfStalker_SwingDoorObstacleOpenAmount = 0.7f;
const float gfStalker_MaxAttackPlayerDistHole = 2.25f;

const float gfStalker_CheckHoleShortcutTime = 0.3f;
const float gfStalker_CheckHoleShortcutMinPathDistToTarget = 30.f;
const float gfStalker_CheckHoleShortcutMinTimeSinceEmerge = 10.f;

const float gfStalker_PlayTurnSideAnimMinAngle = cMath_ToRad(60.f);
const float gfStalker_PlayTurnSideAnimMaxAngle = cMath_ToRad(115.f);
const float gfStalker_PlayTurnAroundAnimMinAngle = cMath_ToRad(115.f);
const float gfStalker_PlayTurnSideAnimWalkMinAngle = cMath_ToRad(70.f);
const float gfStalker_MinTimeBetweenQuickTurns = 1.f;
const float gfStalker_QuickTurnMaxFwdSpeed = 1.f;

const float gfStalker_MinHeadAnimationDelay = 0.f;
const float gfStalker_MaxHeadAnimationDelay = 6.f;

const float gfStalker_ThrowForwardAngle = 60.f;
const float gfStalker_ThrowBackwardAngle = 140.f;
const float gfStalker_ThrowDamage = 0.34f;

const float gfStalker_ReactToGrenadeDist = 6.f;

const int glStalker_IgnoreSoundMaxPrioWhenHurt = 6;

const float gfStalker_JumpLongAnimDistOffset = 6.987f;
const float gfStalker_JumpFailAnimDistOffset = 8.500f;
const float gfStalker_JumpHangOnLedgeAnimDistOffset = 8.650f;
const float gfStalker_JumpExtraLongHangOnLedgeAnimDistOffset = 13.206f;
const float gfStalker_JumpShortAnimDistOffset = 4.331f;
const float gfStalker_SecondJumpMaxRelT = 0.9f;
const float gfStalker_HangOnLedgeAnimMinAllowFallRelTimePos = 0.18f;
const float gfStalker_HangOnLedgeLongAnimMinAllowFallRelTimePos = 0.231f;
const float gfStalker_BossFightMaxHurtByGunDistance = 35.f;
const float gfStalker_BossFightRunBeforeJumpMinDist = 6.f;
const float gfStalker_IgnoreRabbitPlayerDistance = 7.f;
const float gfStalker_SitAndWaitMinTime = 20.f;
const float gfStalker_SitAndWaitMaxTime = 45.f;
const float gfStalker_ReachOutHoleCooldownMin = 60.f * 30.f;
const float gfStalker_ReachOutHoleCooldownMax = 60.f * 40.f;
const float gfStalker_SitAndWaitCooldownMin = 60.f * 15.f;
const float gfStalker_SitAndWaitCooldownMax = 60.f * 30.f;
const float gfStalker_MinInterestAreaRadius = 8.f;
const float gfStalker_AlertInterestAreaRadiusMax = 15.f;
const float gfStalker_AlertInterestAreaRadiusMin = 9.f;
const float gfStalker_AlertInterestMaxDistBetweenSounds = 20.f;
const float gfStalker_SlowInterestAreaRadiusIncreaseTime = 30.f;
const float gfStalker_StopInterestAreaRadiusIncreaseTime = 5.f;
const float gfStalker_InterestAreaRadiusSpeedSlow = 1.f / 5.f;
const float gfStalker_InterestAreaRadiusSpeedFast = 1.f / 0.1f;
const float gfStalker_MinTimeBetweenInterestIncrease = 1.f;
const float gfStalker_MinInterestEmergeTime = 9.f;
const float gfStalker_MaxInterestEmergeTime = 15.f;
const int glStalker_InterestDecreaseNumToAlert = 10;

const float gfStalker_PlayerPredictionIntervalTime = 0.2f;
const int glStalker_PlayerPredictionVelocityBufferSize = 5;

const cVector3f gvStalker_HeadAdjustmentRotAdd(0.f, 0.f, cMath_ToRad(12.5f));
const cVector3f gvStalker_HeadAdjustmentPosAdd(-1.f, 0.f, 0.f);

const tString gsStalker_PlayerHasBeenAttackedOnEmergeVar = "PlayerHasBeenAttackedOnEmerge";
const tString gsStalker_GeneratorTurnedOffTimer = "Timer_GeneratorTurnedOff";
const tString gsStalker_BossFightIgnoreEnvironmentalDamageTimer = "Timer_BossFightIgnoreEnvironmentalDamage";

const tString gsStalker_HeadSocket = "Socket_Head";
const tString gsStalker_RabbitCutsceneEnt = "doll_rabbit_cutscene.ent";

const tString[] gsStalker_NoHeadAdjustmentAnims = { gsStalkerAnim_Alert, gsStalkerAnim_AlertCrampedFull, gsStalkerAnim_AlertCrampedStepBack, gsStalkerAnim_AlertCrampedArms };

const float gfStalker_FirstEncounterMaxDist = 20;

//----------------------------------------------------------------------

//} END SETTINGS

//----------------------------------------------------------------------

/////////////////////////////////////////
// TYPES
//{//////////////////////////////////////

//----------------------------------------------------------------------

enum eStalkerState
{
	eStalkerState_Idle,
	eStalkerState_Emerge,
	eStalkerState_InvestigateSound,
	eStalkerState_ReturnToHole,
	eStalkerState_PreHunt,
	eStalkerState_Hunt,
	eStalkerState_PostHunt,
	eStalkerState_SearchArea,
	eStalkerState_CheckLastKnownPosition,
	eStalkerState_PlayerLightDetected,
	eStalkerState_CheckGobo,
	eStalkerState_CheckFlashlightHit,
	eStalkerState_PlayerDetected,
	eStalkerState_Alert,
	eStalkerState_AttackClose,
	eStalkerState_Stunned,
	eStalkerState_Blocked,
	eStalkerState_BlockedByProp,
	eStalkerState_Retreat,
	eStalkerState_BreakDoor,
	eStalkerState_Stalk,
	eStalkerState_WaitInHole,
	eStalkerState_MoveBetweenHoles,
	eStalkerState_Hurt,
	eStalkerState_Rage,
	eStalkerState_KillPlayer,
	eStalkerState_EvaluateObstacle,
	eStalkerState_Roar,
	eStalkerState_ThrowPlayer,
	eStalkerState_CrawlThroughVent,
	eStalkerState_SitAndWait,
	eStalkerState_ExamineRabbit,
	eStalkerState_BossFight_Default,
	eStalkerState_BossFight_Pace,
	eStalkerState_BossFight_Retreat,
	eStalkerState_BossFight_Jump,
	eStalkerState_MapTransfer,
	eStalkerState_Null,
	eStalkerState_Debug
}

//----------------------------------------------------------------------

enum eStalkerProximity
{
	eStalkerProximity_Touching,
    eStalkerProximity_VeryClose,
	eStalkerProximity_Close,
    eStalkerProximity_SemiClose,
	eStalkerProximity_Near,
	eStalkerProximity_Midrange,
	eStalkerProximity_Far
}

//----------------------------------------------------------------------

enum eStalkerAlertState
{
	eStalkerAlertState_None = 0,
	eStalkerAlertState_Investigating = 1,
	eStalkerAlertState_Detected = 2,
}

//----------------------------------------------------------------------

enum eStalkerLocomotionAnimType
{
	eStalkerLocomotionAnimType_Idle,
	eStalkerLocomotionAnimType_Walk,
	eStalkerLocomotionAnimType_Run
}

//----------------------------------------------------------------------

enum eStalkerQuickTurnType
{
	eStalkerQuickTurnType_TurnAround = 0,
	eStalkerQuickTurnType_Left = 1,
	eStalkerQuickTurnType_Right = 2,
}

//----------------------------------------------------------------------

enum eStalkerHeadAnimationType
{
	eStalkerHeadAnimationType_Mouth = 1 << 0,
	eStalkerHeadAnimationType_Twist = 1 << 1,
	eStalkerHeadAnimationType_Twitch = 1 << 2,
}

//----------------------------------------------------------------------

enum eStalkerBossFightBehaviour
{
	eStalkerBossFightBehaviour_Default = 0,
	eStalkerBossFightBehaviour_Pace = 1,
	eStalkerBossFightBehaviour_Retreat = 2
}

//----------------------------------------------------------------------

//} END TYPES

//----------------------------------------------------------------------

/////////////////////////////////////////
// CLASSES
//{//////////////////////////////////////

//----------------------------------------------------------------------

class cStalker_CollidePropData
{
	float mfTimeSinceCollision = 0.f;
	tString msPropName = "";
	cVector3f mvLastPropPos = cVector3f(0.f);
	tID m_idProp = tID_Invalid;
}

//----------------------------------------------------------------------

class cStalker_PathBlockerBodyData
{
	float mfTimeUntilRemoval = gfStalker_AutoRemovePathBlockerTime;
	bool mbIsOpenDoor = false;
	bool mbManualRemovalOnly = false;
	tID m_idBody = tID_Invalid;
}

//----------------------------------------------------------------------

class cStalker_DoorAABB
{
	cVector3f mvMin(0.f);
	cVector3f mvMax(0.f);
	tID m_idBodyId = tID_Invalid;
}

//----------------------------------------------------------------------

class cStalker_InterestPosition
{
	cVector3f mvPos(0.f);
	tID m_idBreakProp = tID_Invalid;
}

//----------------------------------------------------------------------

//} END CLASSES

//----------------------------------------------------------------------

class cScrAgentStalker : cScrAgentHumanoid
{
	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// MAIN FUNCTIONS
	//=======================================
	//{//////////////////////////////////////
	
	//===========================================================

	//------------------------------------------------------------

	/////////////////////////////////////////
	// INIT
	//{//////////////////////////////////////

	//------------------------------------------------------------

	void Init()
	{
		mBaseObj.SetUpdatePlayerDetection(true);
		mBaseObj.SetCheckForDoors(true);
		mBaseObj.SetMaxCheckDoorDistance(1.7f);
		mBaseObj.SetAnimationCallbackActive(true);
	}
	
	//------------------------------------------------------------

	//} END INIT

	//------------------------------------------------------------

	/////////////////////////////////////////
	// LOADING
	//{//////////////////////////////////////

	//------------------------------------------------------------

	void SetupCharBody()
	{
		cScrAgentHumanoid::SetupCharBody();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();

		pCharBody.SetMass(80.f);
		pCharBody.SetMaxPositiveMoveSpeed(eCharDir_Forward, 1.f);
		pCharBody.SetMoveSpeedMul(eCharDir_Forward,1.f);
		pCharBody.SetMoveAcc(eCharDir_Forward, 4.f);
		pCharBody.SetMoveDeacc(eCharDir_Forward, 8.f);
		pCharBody.SetMaxPushMass(20.f);
		pCharBody.SetMaxPushForce(300.f);
		pCharBody.SetAccurateClimbing(true);
		pCharBody.SetCollideCharacter(false);		
		pCharBody.SetupSafePositions(0.25f, 5.f);
	}

	//------------------------------------------------------------

	void SetupAfterLoad(cWorld@ apWorld, cResourceVarsObject@ apVars, cResourceVarsObject@ apInstanceVars)
	{
		cScrAgentHumanoid::SetupAfterLoad(apWorld, apVars, apInstanceVars);

		//////////////////////
		// General Setup
		float fSightRange;
		switch (Game_GetDifficultyMode())
		{
			case eGameMode_Easy: 	fSightRange = gfStalker_SightRange_Easy; 	break;
			case eGameMode_Hard: 	fSightRange = gfStalker_SightRange_Hard; 	break;
			default: 				fSightRange = gfStalker_SightRange; 		break;
		}
		
		mBaseObj.SetAlignEntityWithGroundRay(true);
		mBaseObj.SetFOV(cMath_ToRad(130.f));
		mBaseObj.SetSightRange(fSightRange);
		mBaseObj.SetSightRangeMul(mfSightMul);
		mBaseObj.SetRelativeEyeHeight(0.8f);
		
		//////////////////////
		// Pathfinder Setup
		mpPathfinder.SetNodeContainerName("Stalker");
		mpPathfinder.SetMaxHeight(0.8f);
		mpPathfinder.SetDirectPathMaxDistanceMul(mfDirectPathMaxDistanceMul);
		mpPathfinder.SetMaxEdgeDistance(3.f);
		mpPathfinder.Debug_SetRenderPathBlockerBodies(true);
		mpPathfinder.SetMaxGoalsPerIsland(4);
		
		//////////////////////
		// Hole network
		msHoleNetwork = "GhoulHole_*";
		
		//////////////////////
		// Animation		
		SetUpdateBonesWhenCulled(true);
		mBaseObj.GetMeshEntity().SetNormalizeAnimationWeights(false);	
		
		//////////////////////
		// Components
		SetupComponents(apWorld, apVars, apInstanceVars);
		
		////////////
		// Preload
		ParticleSystem_Preload("ghoul_hole_dust_pre_emerge.ps");
		ParticleSystem_Preload("dust_impact_door_hit.ps");
		ParticleSystem_Preload("ghoul_ceiling_dust.ps");
		ParticleSystem_Preload("ghoul_hole_dust_trap.ps");
		Entity_Preload(gsStalker_RabbitCutsceneEnt);
	}

	//------------------------------------------------------------

	void SetupComponents(cWorld@ apWorld, cResourceVarsObject@ apVars, cResourceVarsObject@ apInstanceVars)
	{
		//////////////////////
		// State Machine
		@mpStateMachine = cLux_CreateEntityComponent_StateMachine(mBaseObj);
		
		mpStateMachine.AddState("Idle", eStalkerState_Idle);
		mpStateMachine.AddState("Emerge", eStalkerState_Emerge);
		mpStateMachine.AddState("ReturnToHole", eStalkerState_ReturnToHole);
		mpStateMachine.AddState("InvestigateSound", eStalkerState_InvestigateSound);
		mpStateMachine.AddState("PreHunt", eStalkerState_PreHunt);
		mpStateMachine.AddState("Hunt", eStalkerState_Hunt);
		mpStateMachine.AddState("PostHunt", eStalkerState_PostHunt);
		mpStateMachine.AddState("SearchArea", eStalkerState_SearchArea);
		mpStateMachine.AddState("CheckLastKnownPosition", eStalkerState_CheckLastKnownPosition);
		mpStateMachine.AddState("PlayerLightDetected", eStalkerState_PlayerLightDetected);
		mpStateMachine.AddState("CheckGobo", eStalkerState_CheckGobo);
		mpStateMachine.AddState("CheckFlashlightHit", eStalkerState_CheckFlashlightHit);
		mpStateMachine.AddState("PlayerDetected", eStalkerState_PlayerDetected);
		mpStateMachine.AddState("Alert", eStalkerState_Alert);
		mpStateMachine.AddState("AttackClose", eStalkerState_AttackClose);
		mpStateMachine.AddState("Stunned", eStalkerState_Stunned);
		mpStateMachine.AddState("BlockedByProp", eStalkerState_BlockedByProp);
		mpStateMachine.AddState("Retreat", eStalkerState_Retreat);
		mpStateMachine.AddState("Blocked", eStalkerState_Blocked);
		mpStateMachine.AddState("BreakDoor", eStalkerState_BreakDoor);	
		mpStateMachine.AddState("Stalk", eStalkerState_Stalk);
		mpStateMachine.AddState("WaitInHole", eStalkerState_WaitInHole);
		mpStateMachine.AddState("MoveBetweenHoles", eStalkerState_MoveBetweenHoles);
		mpStateMachine.AddState("Hurt", eStalkerState_Hurt);
		mpStateMachine.AddState("Rage", eStalkerState_Rage);
		mpStateMachine.AddState("KillPlayer", eStalkerState_KillPlayer);
		mpStateMachine.AddState("ThrowPlayer", eStalkerState_ThrowPlayer);
		mpStateMachine.AddState("CrawlThroughVent", eStalkerState_CrawlThroughVent);
		mpStateMachine.AddState("SitAndWait", eStalkerState_SitAndWait);
		mpStateMachine.AddState("ExamineRabbit", eStalkerState_ExamineRabbit);
		mpStateMachine.AddState("Null", eStalkerState_Null);
		mpStateMachine.AddState("MapTransfer", eStalkerState_MapTransfer);
		mpStateMachine.AddState("Debug", eStalkerState_Debug);
		mpStateMachine.AddState("EvaluateObstacle", eStalkerState_EvaluateObstacle);
		mpStateMachine.AddState("Roar", eStalkerState_Roar);
		mpStateMachine.AddState("BossFightDefault", eStalkerState_BossFight_Default);
		mpStateMachine.AddState("BossFightRetreat", eStalkerState_BossFight_Retreat);
		mpStateMachine.AddState("BossFightPace", eStalkerState_BossFight_Pace);
		mpStateMachine.AddState("BossFightJump", eStalkerState_BossFight_Jump);
		
		//////////////////////
		// Listener
		@mpSoundListener = cLux_CreateEntityComponent_SoundListener(mBaseObj);
		mpSoundListener.LoadFromInstanceVariables(apInstanceVars);
		mpSoundListener.SetHearRadius(mfHearRadius);
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);

		//////////////////////
		// Light Sensor
		@mpLightSensor = cLux_CreateEntityComponent_LightSensor(mBaseObj);
		
		//////////////////////
		// Foot placement
		@mpFootPlacement = cLux_CreateEntityComponent_FootPlacement(mBaseObj);
		mpFootPlacement.LoadFromVariables(apVars);
		
		//////////////////////
		// Head Tracker
		@mpHeadTracker = cLux_CreateEntityComponent_HeadTracker(mBaseObj);
		mpHeadTracker.LoadFromVariables(apVars);
		
		msHeadTracker_TargetEntity = apInstanceVars.GetVarString("HeadTracker_TargetEntity", "");
		if (msHeadTracker_TargetEntity == "")
			msHeadTracker_TargetEntity = "Player";
		
		mpHeadTracker.SetActive(apInstanceVars.GetVarBool("HeadTracker_Active", true));
		
		//////////////////////
		// Proximity Sensor
		@mpProximitySensor = cLux_CreateEntityComponent_ProximitySensor(mBaseObj);

		mpProximitySensor.AddState(eStalkerProximity_Touching, 1.2, 1.3, true, false);
        mpProximitySensor.AddState(eStalkerProximity_VeryClose, 2.0, 2.2, true, false);
		mpProximitySensor.AddState(eStalkerProximity_Close, 3.0, 3.2, true, false);
        mpProximitySensor.AddState(eStalkerProximity_SemiClose, 3.6, 3.7, true, false);
		mpProximitySensor.AddState(eStalkerProximity_Near, 4.5, 4.7, true, false);
		mpProximitySensor.AddState(eStalkerProximity_Midrange, 12.4, 12.6, true, false);
		mpProximitySensor.AddState(eStalkerProximity_Far, 16.4, 16.6, true, false);
		
		//////////////////////
		// Mover Setup
		mpMover.SetupWallAvoidance(0.9f, 5.f, 4);
		mpMover.SetWallAvoidanceActive(true);
		mpMover.SetupDynamicObjectAvoidance(2.5f, 20.f, 5);
		mpMover.SetDynamicObjectAvoidanceActive(false);		
		mpMover.SetDynamicObjectPlayerAvoidanceActive(false);
		mpMover.SetupDynamicObjectPlayerAvoidance(4.f, 3);
		mpMover.SetRunToWalkSpeed(1.9f);
		mpMover.SetWalkToRunSpeed(2.f);
		mpMover.SetStoppedToWalkSpeed(0.025f);
		mpMover.SetWalkToStoppedSpeed(0.05f);
		mpMover.SetStoppedToWalkTurnAnimSpeed(1.f);
		mpMover.SetTurnMinBreakAngle(cMath_ToRad(25.f));
		mpMover.SetTurnMinPlayAnimAngle(cMath_ToRad(25.f));
		mpMover.SetStoppedTurnAnimNames(gsStalkerAnim_TurnLeftStopped, gsStalkerAnim_TurnRightStopped);
		mpMover.SetWalkTurnAnimNames(gsStalkerAnim_TurnLeftWalk, gsStalkerAnim_TurnRightWalk);
		mpMover.SetRunTurnAnimNames(gsStalkerAnim_TurnLeftRun, gsStalkerAnim_TurnRightRun);
				
		mpMover.AddSpeedState(eStalkerSpeed_Walk);
			mpMover.SetSpeedState_Forward(1.6f);
			mpMover.SetSpeedState_Backward(1.f);
			mpMover.SetSpeedState_ForwardAcc(20.f);
			mpMover.SetSpeedState_ForwardDeacc(20.f);
			mpMover.SetSpeedState_TurnBreakMul(0.4f);
		
		mpMover.AddSpeedState(eStalkerSpeed_Run);
			mpMover.SetSpeedState_Forward(gfStalker_RunSpeed);
			mpMover.SetSpeedState_ForwardAcc(20.f);
			mpMover.SetSpeedState_ForwardDeacc(20.f);
			mpMover.SetSpeedState_TurnMaxSpeed(20.f);
			mpMover.SetSpeedState_TurnSpeedMul(4.f);
			mpMover.SetSpeedState_TurnBreakMul(0.75f);

		mpMover.AddSpeedState(eStalkerSpeed_Stopped);
			mpMover.SetSpeedState_Forward(0.f);
			mpMover.SetSpeedState_Backward(0.f);
		
		mpMover.SetStopMovementDuringNonLocomotionAnim(true);
		
		mpMover.AddLocomotionAnim("glimpse_ahead_end");
		mpMover.AddLocomotionAnim("glimpse_left_45_end");
		mpMover.AddLocomotionAnim("glimpse_right_45_end");
		mpMover.AddLocomotionAnim("glimpse_left_90_end");
		mpMover.AddLocomotionAnim("glimpse_right_90_end");
		mpMover.AddLocomotionAnim(gsStalkerAnim_HurtAdditive);
		
		for (int i = 0; i < gsStalkerAnim_Head_Mouth.size(); ++i)
			mpMover.AddLocomotionAnim(gsStalkerAnim_Head_Mouth[i]);
		for (int i = 0; i < gsStalkerAnim_Head_Twist.size(); ++i)
			mpMover.AddLocomotionAnim(gsStalkerAnim_Head_Twist[i]);
		for (int i = 0; i < gsStalkerAnim_Head_Twitch.size(); ++i)
			mpMover.AddLocomotionAnim(gsStalkerAnim_Head_Twitch[i]);
		
		//////////////////////
		// Attack Damage
		@mpAttackDamage = cLux_CreateEntityComponent_AttackDamage(mBaseObj);

		mpAttackDamage.AddType(0, "Attack");
			mpAttackDamage.SetType_Damage(1.f, 1.f);
			mpAttackDamage.SetType_DamageType(eDamageType_Silent);
			mpAttackDamage.SetType_Affects(true, false, false);
			mpAttackDamage.SetType_Force(gfStalker_AttackForce, 1.f);
			mpAttackDamage.SetType_AddShapeAtSocket("hand_right", cVector3f(0.f, -0.5f, 0.f), 1.f);
			mpAttackDamage.SetType_MaxAffectedBodies(6);

		//////////////////////
		// Verlet
		@mpVerletAnimation = cLux_CreateEntityComponent_VerletAnimation(mBaseObj);
	}

	//------------------------------------------------------------

	void OnAfterWorldLoad()
	{
		cScrAgentHumanoid::OnAfterWorldLoad();
		
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap is null) return;
		
		/////////////////////
		// Add to blackboard
		if (mBaseObj.IsActive())
		{
			Blackboard_AddEnemy(mBaseObj.GetID());			
		}
		
		/////////////////////
		// Head tracker
		if (msHeadTracker_TargetEntity != "")
		{
			iLuxEntity@ pEnt = pMap.GetEntityByName(msHeadTracker_TargetEntity);
			if (pEnt !is null)
			{
				m_idHeadTracker_TargetEntity = pEnt.GetID();
				mpHeadTracker.SetTrackEntity(pEnt);
			}
		}
		
		/////////////////////
		// Setup default interest area pos
		iPhysicsWorld@ pPhysicsWorld = pMap.GetPhysicsWorld();
		if (pPhysicsWorld !is null &&
			mvInterest_AreaPos.SqrLength() <= 0.f)
		{			
			cVector3f vSize = (pPhysicsWorld.GetWorldSizeMin() + pPhysicsWorld.GetWorldSizeMax()) / 2.f;
			mfInterest_MapRadius = vSize.Length();			
			mvInterest_AreaPos = vSize;
			mfInterest_AreaRadius = mfInterest_MapRadius;
		}
		
		/////////////////////
		// Doors
		mvDoorAABBs.resize(0);
		
		array<iLuxEntity@> vSwingDoors;
		array<iLuxEntity@> vSlideDoors;
		pMap.GetEntityArray("*", eLuxEntityType_Prop, "cScrPropSwingDoor", vSwingDoors);
		pMap.GetEntityArray("*", eLuxEntityType_Prop, "cScrPropSlideDoor", vSlideDoors);
		
		for (int i = 0; i < vSwingDoors.size(); ++i)
		{
			iPhysicsBody@ pBody = cLux_ID_Body(SwingDoor_GetDoorBodyID(vSwingDoors[i].GetName()));
			cBoundingVolume@ pBV = pBody !is null ? pBody.GetBoundingVolume() : null;
			
			if (pBody is null) continue;
			if (pBV is null) continue;
			
			cStalker_DoorAABB aabb;
			aabb.mvMin = pBV.GetMin();
			aabb.mvMax = pBV.GetMax();
			aabb.m_idBodyId = pBody.GetID();
			mvDoorAABBs.push_back(aabb);
		}
		
		for (int i = 0; i < vSlideDoors.size(); ++i)
		{
			iPhysicsBody@ pBody = vSlideDoors[i].GetMainBody();
			cBoundingVolume@ pBV = pBody !is null ? pBody.GetBoundingVolume() : null;
			
			if (pBody is null) continue;
			if (pBV is null) continue;
			
			cStalker_DoorAABB aabb;
			aabb.mvMin = pBV.GetMin();
			aabb.mvMax = pBV.GetMax();
			aabb.m_idBodyId = pBody.GetID();
			mvDoorAABBs.push_back(aabb);
		}
		
		/////////////////////
		// Hide areas
		mvHideAreaIds.resize(0);
		pMap.GetEntityArrayID("*", eLuxEntityType_Area, "cScrAreaHide", mvHideAreaIds);
		
		///////////////////
		// Transfer areas
		mvMapTransferData_TransferAreaIds.resize(0);
		pMap.GetEntityArrayID("*", eLuxEntityType_Area, "cScrAreaMapTransfer", mvMapTransferData_TransferAreaIds);
	}

	//------------------------------------------------------------

	void OnMapEnter()
	{
		EnvironmentalDamage_AddEntityToCheck(mBaseObj.GetID());
		Blackboard_AddEnemy(mBaseObj.GetID());
	}

	void OnMapLeave()
	{
		EnvironmentalDamage_RemoveEntityToCheck(mBaseObj.GetID());
		Blackboard_RemoveEnemy(mBaseObj.GetID());
		
		mlGhoulHoleNetworkId = -1;
		
		cParticleSystem@ pPSA = cLux_ID_ParticleSystem(m_idWaitInHole_ParticlesId);
		cParticleSystem@ pPSB = cLux_ID_ParticleSystem(m_idMoveBetweenHoles_Particles);		 
		
		if (pPSA !is null) pPSA.Kill(); 
		if (pPSB !is null) pPSB.Kill();
			
		m_idMoveBetweenHoles_Particles = tID_Invalid;
		m_idWaitInHole_ParticlesId = tID_Invalid;
	}
	
	//------------------------------------------------------------
	
	void BeforeEntityDestruction()
	{
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
					
		if (mpCrampedAnimShape !is null)
		{
			pPhysicsWorld.DestroyShape(mpCrampedAnimShape);
			@mpCrampedAnimShape = null;
		}
		
		if (mpHeadAdjustment_Shape !is null)
		{
			pPhysicsWorld.DestroyShape(mpHeadAdjustment_Shape);
			@mpHeadAdjustment_Shape = null;
		}
			
		StopLampFlickerInCurrLevel();
		
		EnvironmentalDamage_RemoveEntityToCheck(mBaseObj.GetID());
		Blackboard_RemoveEnemy(mBaseObj.GetID());
	}
	
	//------------------------------------------------------------
	
	void OnStart()
	{		
		mbStarted = true;
		
		/////////////////////
		// Setup lamps
		OnStartGetLampsInCurrLevel();
		
		/////////////////////
		// Disable if no nodes!
		if (mpPathfinder.GetNodeContainer() is null)
		{
			mBaseObj.SetActive(false);
			Error("No path nodes found for " + mBaseObj.GetName() + "!");
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void SetupAfterMapTransfer()
	{		
		///////////////
		// Stage 1 (enter null so we know the following state changes will happen)
		if (mlMapTransferData_SetupStage == 0)
		{
			mlMapTransferData_SetupStage = 1;
			
			ResetProperties();
			
			mpPathfinder.Stop();
			mpMover.StopTurning();
			mBaseObj.ResetPlayerDetectionState();
			mpProximitySensor.ResetAllStates();
			
			mpStateMachine.ChangeState(eStalkerState_Null);
		}
		
		///////////////
		// Stage 2
		else if (mlMapTransferData_SetupStage == 1)
		{
			mlMapTransferData_SetupStage = -1;
			
			///////////////
			// Apply transfered vars			
			mMode = mMapTransferData_Mode;
			mAlertState = mMapTransferData_AlertState;
			mfPresence = mfMapTransferData_Presence;
			mfTenacity = mfMapTransferData_Tenacity;
			mbEmergeAllowed = mbMapTransferData_EmergeAllowed;
			mbHurt_RecentlyHurt = mbMapTransferData_RecentlyHurt;
			mbInterest_Alert = mbMapTransferData_InterestAlert;
			mfInterest_AreaRadius = mfMapTransferData_InterestAreaRadius;
			mfInterest_IncreaseCount = mfMapTransferData_InterestIncreaseCount;
			mfInterest_PauseEmergeCount = mfMapTransferData_InterestPauseEmergeCount;
			mfInterest_EmergeCount = mfMapTransferData_InterestEmergeCount;
			mfInterest_EmergeTime = mfMapTransferData_InterestEmergeTime;
			mvInterest_AreaPos = mvMapTransferData_InterestAreaPos;
			
			///////////////
			// Setup vars
			float fDistToPlayer = mBaseObj.GetDistanceToPlayer();
			
			float fPathDistToPlayer = -1.f;
			if (mpPathfinder.BuildPathNodeArrayToPos(mBaseObj.GetPlayerFeetPos()))
				fPathDistToPlayer = mpPathfinder.GetPathNodeArrayFullLength();
							
			bool bInsideWalls = mlMapTransferData_State == eStalkerState_Null ||
								mlMapTransferData_State == eStalkerState_WaitInHole ||
								mlMapTransferData_State == eStalkerState_MoveBetweenHoles;
			
			bool bEnterHole = bInsideWalls || 
							  fDistToPlayer >= 35.f ||
							  fPathDistToPlayer >= 50.f ||
							  (mbMapTransferData_RetreatActive || mbMapTransferData_RecentlyHurt) && (fDistToPlayer >= 15.f || fPathDistToPlayer >= 25.f);
			
			///////////////
			// Enter hole?
			if (bEnterHole)
			{
				SetHidden(true);
				mpStateMachine.ChangeState(eStalkerState_Null);		
				
				///////////////
				// Decide behaviour
				tID idHole = tID_Invalid;
				float fBehaviourDelay = 0.f;
				{
					/////////////////
					// Active?
					if (mMapTransferData_Mode == eStalkerMode_Active)
					{				
						///////////////
						// Go near player if was in interest alert
						if (mbMapTransferData_InterestAlert)
						{
							idHole = GetHoleWithShortestPathToPos(mBaseObj.GetPlayerPos());
							if (idHole == tID_Invalid)
								idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition());
						
							fBehaviourDelay = 1.f;
						}
						
						///////////////
						// Go to random hole
						else
						{
							idHole = Blackboard_GetRandomGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition());			
							fBehaviourDelay = 1.f;
						}
						
						m_idMoveBetweenHoles_GoalHole = idHole;
						
						///////////////
						// Emerge?
						bool bEmerge = mbMapTransferData_Emerging ||
									   (mbMapTransferData_InterestAlert && bInsideWalls == false);
						if (bEmerge)
						{
							m_idMoveBetweenHoles_EmergeHole = m_idMoveBetweenHoles_GoalHole;							
							mbEmerge_SearchArea = true;
						}
					}	

					/////////////////
					// Passive?
					else if (mMapTransferData_Mode == eStalkerMode_Passive)
					{			
						///////////////
						// Go far away from player!
						m_idMoveBetweenHoles_GoalHole = Blackboard_GetFarthestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos());
						fBehaviourDelay = 5.f;
					}
				}
				
				///////////////
				// Sound
				if (bInsideWalls == false)
				{
					mBaseObj.Timer_Add("Timer_PlayMapTransferEnterHoleSound", 0.5f, "OnTimer_PlayMapTransferEnterHoleSound");
				}
				
				///////////////
				// Delay behaviour!				
				if (mlMapTransferData_State == eStalkerState_MoveBetweenHoles || 
					mbMapTransferData_Emerging)
				{
					fBehaviourDelay = 0.f;
				}
				
				mBaseObj.Timer_Add("Timer_SetupAfterMapTransfer", fBehaviourDelay, "OnTimer_SetupAfterMapTransfer", false, false);
			}
			
			///////////////
			// Go to map transfer area!
			else
			{
				SetHidden(false);
				
				///////////////
				// Determine next state
				int lNextState;
				
				if (mbMapTransferData_RecentlyHurt)
				{
					lNextState = eStalkerState_Retreat;
				}
				else if (mbMapTransferData_RetreatActive)
				{
					lNextState = eStalkerState_Retreat;
				}
				else if (mMapTransferData_AlertState == eStalkerAlertState_Investigating)
				{
					mlInvestigateSound_Prio = 5;
					mvInvestigateSound_Goal = mBaseObj.GetPlayerPos();
					mfInvestigateSound_Distance = (mBaseObj.GetPlayerPos() - mBaseObj.GetPosition()).SqrLength();
					msInvestigateSound_SoundName = "MapTransferInvestigateSound";
					m_idInvestigateSound_SoundSourceBodyId = tID_Invalid;
					
					lNextState = eStalkerState_InvestigateSound;
				}
				else if (mMapTransferData_AlertState == eStalkerAlertState_Detected)
				{
					mAlertState = eStalkerAlertState_None; // Setting this to none so the player pos will be revealed when entering hunt
					lNextState = eStalkerState_Hunt;
				}
				else
				{
					lNextState = eStalkerState_Idle;
				}
				
				///////////////
				// Place at closest node if already in map transfer state
				if (mlMapTransferData_State == eStalkerState_MapTransfer)
				{
					iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
					cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition(), 0.f, 30.f, true, false, false, null);
					
					if (pNode !is null)
					{ 						
						if (GetCharacterFitsAtPos(pNode.GetPosition(), true) == false)
						{
							@pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + mBaseObj.GetPlayerDir() * 5.f, 0.f, 30.f, true, false, false, pNode);
						}
						
						if (pNode !is null && 
							GetCharacterFitsAtPos(pNode.GetPosition(), true))
						{
							pCharBody.SetFeetPosition(pNode.GetPosition(), false);
						
							mpMover.PlayAnimation(msIdleAnim, 0.f);
							mpMover.SetUseMoveStateAnimations(true);
							
							if (lNextState == eStalkerState_InvestigateSound)
								mAlertState = eStalkerAlertState_None; // Setting this to none so it won't play the reaction anim when entering InvestigateSound
							
							mpStateMachine.ChangeState(lNextState);
							return;
						}
					}
				}
				
				///////////////
				// Change state immediately if inside transfer area
				if (mbMapTransferData_InsideTransferArea)
				{			
					mpMover.PlayAnimation(msIdleAnim, 0.f);
					mpMover.SetUseMoveStateAnimations(true);
					
					mpStateMachine.ChangeState(lNextState);
				}
				
				///////////////
				// Move to transfer area!
				else
				{
					mBaseObj.SetSensesActive(false);
					
					mlMapTransfer_NextState = lNextState;
					mpStateMachine.ChangeState(eStalkerState_MapTransfer);
				}
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_PlayMapTransferEnterHoleSound(uint64 alId)
	{
		mBaseObj.PlaySound("Sound_EnterHole", "creatures/stalker/tunnel_enter", true, false);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_SetupAfterMapTransfer(uint64 alId)
	{
		if (mpStateMachine.GetCurrentState() == eStalkerState_Null)
		{
			mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
		}
	}
	
	//------------------------------------------------------------

	//} END LOADING

	//------------------------------------------------------------

	/////////////////////////////////////////
	// GENERAL
	//{///////////////////////////////////////

	//------------------------------------------------------------
	
	void OnUpdate(float afTimeStep)
	{				
		cScrAgentHumanoid::OnUpdate(afTimeStep);
		if (mBaseObj.IsActive() == false) return;

		/////////////////////
		// On start
		if (mbStarted == false)
		{
			OnStart();
		}	
		
		/////////////////////
		// Register network
		if (mlGhoulHoleNetworkId == -1)
		{
			mlGhoulHoleNetworkId = Blackboard_RegisterGhoulHoleNetwork(mBaseObj.GetMap(), msHoleNetwork);
		}

		/////////////////////
		// Setup after map change
		if (mlMapTransferData_SetupStage != -1)
		{
			SetupAfterMapTransfer();
		}
		
		/////////////////////
		// Update
		UpdatePlayerPrediction(afTimeStep);
		UpdateCheckLos(afTimeStep);
		UpdateProximityDetection(afTimeStep);
		UpdateWalkAnims(afTimeStep);
		UpdateHitByProp(afTimeStep);
		UpdateNoCollisionBodies(afTimeStep);
		UpdateObstacles(afTimeStep);
		UpdateQuickTurn(afTimeStep);
		UpdateFirstEncounterAchievement(afTimeStep);
	}
	
	//------------------------------------------------------------
	
	void OnVariableUpdate(float afDeltaTime)
	{
		if (mbVerletModuleInitialized == false)
		{
			InitVerletModule();
		}
		
		UpdateMusic(afDeltaTime);
		UpdateFallingFailSafe(afDeltaTime);
		UpdateEyePosition(afDeltaTime);
		UpdateIsOnScreen(afDeltaTime);
		UpdateMode(afDeltaTime);
		UpdateInterest(afDeltaTime);
		UpdatePlayerHiding(afDeltaTime);
		UpdatePlayerLeftSaveRoom(afDeltaTime);
		UpdateSoundCounter(afDeltaTime);
		UpdateFlashlightDetection(afDeltaTime);
		UpdateCheckHoleShortcut(afDeltaTime);
		UpdateLampFlickerProximity(afDeltaTime);
		UpdateInPlayerProximity(afDeltaTime);
		UpdateHeadTracker(afDeltaTime);
		UpdateCrawlThroughVent(afDeltaTime);
		UpdateHeadAnimation(afDeltaTime);
		UpdateAdditiveHurtAnimation(afDeltaTime);
		UpdateGrenadeTracking(afDeltaTime);
		UpdateMeshMovement(afDeltaTime);
	}
	
	//------------------------------------------------------------
	
	void OnAfterAnimationUpdate(cMeshEntity@ apFunctions, float afTimeStep)
	{
		UpdateHeadAdjustment(afTimeStep);
	}	
	
	//------------------------------------------------------------

	void ResetProperties()
	{
		cScrAgentHumanoid::ResetProperties();
		
		///////////////////////
		// Reset timers
		mBaseObj.Timer_ClearAll();
		
		///////////////////////
		// Reset general vars
		mAlertState = eStalkerAlertState_None;
		msAnimState = "";
		mbIsInLiquid = false;
		mbHidden = false;
		mbPlayerIsInSaveRoom = false;
		mbWasInActiveModeWhenPlayerEnteredSaveRoom = false;
		mbIsOnScreen = false;
		mfPlayerLeftSaveRoomCount = 0.f;
		mlPathfindingFailCount = 0;
		
		mbPlayerIsHiding = false;
		mbPlayerHidWhileSpotted = false;
		
		mMode = eStalkerMode_Active;
		mfPresence = 0.f;
		mfPresenceIncreaseMul = 1.f;
		mfPresenceDecreaseMul = 1.f;
		mfRandPresenceDecreaseMul = 1.f;
		mfTenacity = 1.f;
		mbPresencePaused = false;
				
		mfSightMul = 1.0f;
		mfHearingMul = 1.0f;
		mfHearRadius = 1.0f;
		mfIsInPlayerProximityTimer = 0.f;
		
		mbPlayerIsInLos = false;
		mfPlayerLosCounter = 0.0f;
		mfTimeSincePlayerInLoS = 100.0f;
		
		mfProximityDetectionTimer = 0.0f;
		mbProximityDetectionActive = true;
		
		mbDetectFlashlight = true;
		mfGoboCount = 0.0f;
		mfHitByFlashlightCount = 0.0f;
		mvGoboPos = cVector3f(0.f);
			
		mfDirectPathMaxDistanceMul = 0.25f;
		mbFootstepSoundsActive = true;
		
		mbCheckHoleShortcut_ForceCheck = false;
		mlCheckHoleShortcut_Stage = 0;
		mfCheckHoleShortcut_UpdateCount = 0.f;
		mfCheckHoleShortcut_PathDistToTarget = -1.f;
		mfCheckHoleShortcut_PathDistToClosestHole = -1.f;
		mfCheckHoleShortcut_PathDistToTargetHole = -1.f;
		m_idCheckHoleShortcut_ClosestHole = tID_Invalid;
		
		mbLastHitByPropThrownByPlayer = false;
		mbLastHitByPropWasMolotov = false;
		m_idLastHitByPropThrownByPlayerId = tID_Invalid;
		
		mfNoCollisionBodiesUpdateCount = 0.2f;
		
		mfSoundCounter = 0.f;
		
		mbUseCrampedAnims = false;
		mfUpdateWalkAnimCount = 0.f;
		
		mbPlayQuickTurnAnim = false;
		mfQuickTurnStartYaw = 0.f;
		mfQuickTurnGoalYaw = 0.f;
		mfQuickTurnCount = 0.f;
		mlQuickTurnTimeStamp = 0;
		msQuickTurnAnim = "";
		mlQuickTurnDoneState = -1;
		mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
				
		msIdleAnim = gsStalkerAnim_Idle;
		msWalkAnim = gsStalkerAnim_Walk;
		msWalkCrampedAnim = gsStalkerAnim_WalkCramped;
		msRunAnim = gsStalkerAnim_Run;
		
		mfHeadAnimation_PlayCount = 0.f;
		mlHeadAnimation_CurrentId = -1;
		mHeadAnimation_CurrentType = eStalkerHeadAnimationType_Mouth;
	
		mvHeadAnimation_MouthAnimIndices.resize(0);
		mvHeadAnimation_TwistAnimIndices.resize(0);
		mvHeadAnimation_TwitchAnimIndices.resize(0);
		
		mbHeadAdjustment_HeadColliding = false;
		mtxHeadAdjustment_Offset = cMatrixf_Identity;
		@mpHeadAdjustment_Shape = null;
		
		mvInterest_AreaPos = cVector3f(0.f);
		mfInterest_AreaRadius = -1.f;
		mbInterest_Alert = false; 
		mfInterest_IncreaseCount = 0.f;
		mfInterest_PauseEmergeCount = 0.f;
		mfInterest_EmergeCount = 0.f;
		mfInterest_EmergeTime = 1.f;
		
		mfPlayerPrediction_UpdateCount = gfStalker_PlayerPredictionIntervalTime;
		mvPlayerPrediction_VelocityBuffer.resize(0);
		
		mvTrackedGrenades.resize(0);
			
		///////////////////////
		// Reset state vars
		mvMapTransfer_GoalPos = cVector3f(0.f);
		mlMapTransfer_NextState = eStalkerState_Idle;
		
		mbEmerge_Hurt = false;
		mbEmerge_InvestigateSound = false;
		mbEmerge_EmergeAttack = false;
		mbEmerge_SearchArea = false;
		mbEmerge_SitAndWait = false;
		mlEmerge_HitTimesToBreakBlockage = -1;
		mlEmerge_LastTimeStamp = -1;
		mlEmerge_KnockDownPlayerDir = 0;
		mfEmerge_KnockDownPlayerAnimAngle = 0.f;
		mvEmerge_KnockDownPlayerAnimPos = cVector3f(0.f);
		mEmerge_KnockDownPlayerType = eStalkerThrowPlayerType_Forward;
		m_idEmerge_Hole = tID_Invalid;
		m_idEmerge_BlockedHoleBody = tID_Invalid;
		m_idEmerge_LastEmergeHole = tID_Invalid;
		
		mbReturnToHole_EnteringHole = false;
		m_idReturnToHole_Hole = tID_Invalid;
		mReturnToHole_Speed = eStalkerSpeed_Walk;
		
		mvInvestigateSound_Goal = 0.f;
		mlInvestigateSound_Prio = -1;
		mfInvestigateSound_Distance = 0.f;
		mbInvestigateSound_QueueSound = false;
		mlInvestigateSound_PlayerSoundCount = 0;
		mlInvestigateSound_EnterFromHighPrioPlayerSoundCount = 0;
		mfInvestigateSound_PlayerSoundDecreaseCount = 0.f;
		msInvestigateSound_SoundName = "";
		m_idInvestigateSound_SoundSourceBodyId = tID_Invalid;
		mInvestigateSound_PrevSpeedState = eStalkerSpeed_Stopped;
		msInvestigateSound_AnimReaction = "";
	
		msPlayerDetected_GlimpseAnim = "";
		mbPlayerDetected_TurnFollow = false;
		mbPlayerDetected_TimerActive = true;
		mbPlayerDetected_StopTurn = true;
		mbPlayerDetected_Moved = false;
		mfPlayerDetected_Timer = 0.0f;
		mlPlayerDetected_Count = 0;
		
		mvPreHunt_GoalPos = cVector3f(0.f);
		
		msAlert_Anim = "";
		mlAlert_LastAlertTimeStamp = -1;
		mbAlert_TurnToPlayer = false;
		mfAlert_DistanceToPlayerWhenUndetected = 0.f;
		mvAlert_PlayerDir = cVector3f(0.f);
	
		mbHunt_PredictedPos = false;
		mlHunt_AttackCount = 0;
		mfHunt_PlayerStartHealth = 0;
		mbHunt_Unreachable = false;
		mvHunt_LastPlayerDir = cVector3f(0.f);
		mvHunt_PlayerHideKillAnimPos = cVector3f(0.f);
		mvHunt_GoalPos = cVector3f(0.f);
		
		mvPostHunt_SoundPos = cVector3f(0.f);
		mlPostHunt_SoundPrio = -1;
		mbPostHunt_SensesEnabled = true;
		mbPostHunt_SoundIsCausedByPlayer = false;
		mbPostHunt_SoundIsPhysicsSound = false;
		msPostHunt_SoundName = "";
		m_idPostHunt_SoundSourceBodyId = tID_Invalid;
			
		mvSearchArea_SearchPos = 0.f;
		mlSearchArea_CurrentInterestPosId = -1;
		mlSearchArea_SearchCount = 0;
		mlSearchArea_MaxSearchCount = 6;
		mvSearchArea_InterestPositions.resize(0);
		mvSearchArea_BreakPropIds.resize(0);
	
		mvCheckLastKnownPosition_Goal = 0.f;
	
		mbPlayerLightDetected_DetectedGobo = false;
		mbPlayerLightDetected_DetectedFlash = false;
		mvPlayerLightDetected_LastPlayerPos = cVector3f(0.f);
		mvPlayerLightDetected_InterestPos = cVector3f(0.f);
				
		mlAttackClose_AnimEventId = 0;
		msAttackClose_Animation = "";
		m_idAttackClose_PropToAttack = tID_Invalid;
	
		mbStunned_Stunned = false;
		mbStunned_Detected = false;
		
		mlCrawlThroughVent_NextState = eStalkerState_Idle;
		mbCrawlThroughVent_Hurt = false;
		m_idCrawlThroughVent_GratingWallId = tID_Invalid;
		
		mlBlocked_PrevState = eStalkerState_Idle;
	
		mvBlockedByProp_DoorDir = 0.f;
		m_idBlockedByProp_Entity = tID_Invalid;
		mvBlockedByProp_PathGoalPos = cVector3f(0.f);
		mBlockedByProp_PrevSpeedState = eStalkerSpeed_Walk;
	
		mbBreakDoor_DoorIsOpen = false;
		mbBreakDoor_DoorCanBeBroken = true;
		mbBreakDoor_InvestigateSound = false;
		mbBreakDoor_MoveToBreakPos = false;
		mlBreakDoor_BlockedByLockedDoorCount = 0;
		mlBreakDoor_Hits = 0;
		mvBreakDoor_GoalPos = 0.f;
		msBreakDoor_DoorName = "";
		m_idBreakDoor_Door = tID_Invalid;
	
		mlStalk_LocalAreaCheckCount = 0;
		mlStalk_TotalCheckCount = 0;
		mlStalk_TotalCheckCountMax = -1;
		mlStalk_LookCount = 0;
		mbStalk_WasInInterestAlert = false;
		mbStalk_ResetAfterQuickTurn = false;
		mvStalk_BasePos = cVector3f(0.f);
		mvStalk_StalkPos = cVector3f(0.f);
		mvStalk_PrevStalkPos = cVector3f(0.f);
	
		mfWaitInHole_Count = 0.f;
		mfWaitInHole_SkipEmergeCount = 0.f;
		mfWaitInHole_PlayerAtHoleCount = 0.f;
		mfWaitInHole_PlayTalkSoundCount = 0.f;
		mbWaitInHole_ImmediateEmerge = false;
		mbWaitInHole_HoleEffectsActive = false;
		mbWaitInHole_PlayerSeenHole = false;
		m_idWaitInHole_Hole = tID_Invalid;
		m_idWaitInHole_ParticlesId = tID_Invalid;
	
		mfMoveBetweenHoles_Speed = 4.f;
		mbMoveBetweenHoles_KilledParticles = false;
		mlMoveBetweenHoles_MoveCount = 0;
		mlMoveBetweenHoles_MoveCountMax = cMath_RandRectl(1, 2);
		mlMoveBetweenHoles_PointIndex = 0;
		m_idMoveBetweenHoles_GoalHole = tID_Invalid;
		m_idMoveBetweenHoles_EmergeHole = tID_Invalid;
		m_idMoveBetweenHoles_Particles = tID_Invalid;
		mvMoveBetweenHoles_Points.resize(0);
			
		mbHurt_RecentlyHurt = false;
		mbHurt_HurtByPlayer = false;
		mbHurt_ShouldRetreat = false;
		mbHurt_PlayedSound = false;
		mbHurt_ShotRun = false;
		mbHurt_ShotRecentlyAnimPlaying = false;
		mlHurt_RecentlyShotCount = 0;
		mfHurt_ShotRunCount = 0.f;
		mvHurt_StartPos = cVector3f(0.f);
		mHurt_DamageType = eDamageType_Gun;
		msHurt_HurtAnim = "";
	
		mbRetreat_Active = false;
		mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
		mvRetreat_GoalPos = cVector3f(0.f);
		mvRetreat_ShortcutTarget = cVector3f(0.f);
		mbRetreat_TakingShortcut = false;
		mlRetreat_ShortcutState = eStalkerState_Stalk;
		m_idRetreat_GoalHoleId = tID_Invalid;
	
		m_idRage_PropToBreak = tID_Invalid;
	
		mbKillPlayer_PlayHoleAnimation = false;
		mbKillPlayer_PlayUnderAnimation = false;
		mfKillPlayer_CameraNearClipPlane = 0.f;
		m_idKillPlayer_HoleId = tID_Invalid;
		
		mbThrowPlayer_PlayAnim = true;
		msThrowPlayer_ThrowAnim = "";
		mThrowPlayer_ThrowType = eStalkerThrowPlayerType_Forward;
	
		mbEvaluateObstacle_ObstacleIsTrap = false;
		mbEvaluateObstacle_AttackObstacle = false;
		mfEvaulateObstacle_AttackObstacleTimeOutCount = 7.f;
		mvEvaulateObstacle_PathGoal;
		m_idEvaluateObstacle_BlockerBodyCandidate = tID_Invalid;
		
		mvSitAndWait_Pos = cVector3f(0.f);
		mvSitAndWait_Dir = cVector3f(0.f);
		mbSitAndWait_Turning = false;
		mbSitAndWait_Sitting = false;
		mbSitAndWait_SeenByPlayer = false;
		
		mbExamineRabbit_Turning = false;
		mbExamineRabbit_Examining = false;
		mbExamineRabbit_FadePropPos = false;
		mfExamineRabbit_FadePropCount = 0.f;
		m_idExamineRabbit_RabbitId = tID_Invalid;
		m_idExamineRabbit_CutsceneRabbitId = tID_Invalid;
		
		mbRoar_PlayerDetectedOnEnter = false;
	}

	//------------------------------------------------------------

	void OnSetActive(bool abX)
	{
		cScrAgentHumanoid::OnSetActive(abX);
		
		if (abX)
		{
			Blackboard_AddEnemy(mBaseObj.GetID());
			
			if (mbHidden)
			{
				SetHidden(true);
			}
			
			mBaseObj.Timer_Add("Timer_EnableFootstepSounds", 0.75, "OnTimer_EnableFootstepSounds");
		}
		else
		{
			mbFootstepSoundsActive = false;
			
			tID id = mBaseObj.GetID();
			Blackboard_RemoveGhoulHolesUsedBy(id);
			Blackboard_SetEnemyHunt(id, false);
			Terror_RemoveHuntingEnemy(id);
			Terror_RemoveEnemy(id);
			Terror_SetEnemyMusicStage(eTerrorMusicAgentType_Stalker, eTerrorMusicStage_None);
			Player_AddScaredSource(0.f, false);
			Blackboard_RemoveEnemy(id);
						
			if (Sound_Exists("Sound_WallMoveLoop")) 
				Sound_Stop("Sound_WallMoveLoop", 0.f);
			
			StopLampFlickerInCurrLevel();
		}
		//Entity_CreateAtEntityExt("gen_1", "generator.ent", "Stalker_1", true, cVector3f(0.45, 0.45, 0.45), cVector3f(0, 0, 0), cVector3f(0, 0, 0), true);
		//Entity_SetCollideCharacter("gen_1", false);
		//Entity_AttachToSocket("gen_1", "Stalker_1", "Socket_Head", true, true);
				
	}
	
	//------------------------------------------------------------
	
	void OnTimer_EnableFootstepSounds(uint64 alID)
	{
		mbFootstepSoundsActive = true;
	}
	
	//------------------------------------------------------------

	//} END GENERAL

	//------------------------------------------------------------

	//} END MAIN FUNCTIONS

	//===========================================================

	//------------------------------------------------------------

	/////////////////////////////////////////
	// HELPERS
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	tString SpeedStateToString(int alState)
	{
		switch (alState)
		{
			case eStalkerSpeed_Walk: return "Walk";
			case eStalkerSpeed_Run: return "Run";
			case eStalkerSpeed_Stopped: return "Stopped";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	tString StateToString(int alState)
	{
		switch (alState)
		{
			case eStalkerState_Idle: return "Idle";
			case eStalkerState_Emerge: return "Emerge";
			case eStalkerState_InvestigateSound: return "InvestigateSound";
			case eStalkerState_ReturnToHole: return "ReturnToHole";
			case eStalkerState_PreHunt: return "PreHunt";
			case eStalkerState_Hunt: return "Hunt";
			case eStalkerState_PostHunt: return "PostHunt";
			case eStalkerState_SearchArea: return "SearchArea";
			case eStalkerState_CheckLastKnownPosition: return "CheckLastKnownPosition";
			case eStalkerState_PlayerLightDetected: return "PlayerLightDetected";
			case eStalkerState_CheckGobo: return "CheckGobo";
			case eStalkerState_CheckFlashlightHit: return "CheckFlashlightHit";
			case eStalkerState_PlayerDetected: return "PlayerDetected";
			case eStalkerState_Alert: return "Alert";
			case eStalkerState_AttackClose: return "AttackClose";
			case eStalkerState_Stunned: return "Stunned";
			case eStalkerState_Blocked: return "Blocked";
			case eStalkerState_BlockedByProp: return "BlockedByProp";
			case eStalkerState_Retreat: return "Retreat";
			case eStalkerState_BreakDoor: return "BreakDoor";
			case eStalkerState_Stalk: return "Stalk";
			case eStalkerState_WaitInHole: return "WaitInHole";
			case eStalkerState_MoveBetweenHoles: return "MoveBetweenHoles";
			case eStalkerState_Hurt: return "Hurt";
			case eStalkerState_Rage: return "Rage";
			case eStalkerState_KillPlayer: return "KillPlayer";
			case eStalkerState_ThrowPlayer: return "ThrowPlayer";
			case eStalkerState_CrawlThroughVent: return "CrawlThroughVent";
			case eStalkerState_SitAndWait: return "SitAndWait";
			case eStalkerState_ExamineRabbit: return "ExamineRabbit";
			case eStalkerState_EvaluateObstacle: return "EvaluateObstacle";
			case eStalkerState_Roar: return "Roar";
			case eStalkerState_BossFight_Default: return "BossFightDefault";
			case eStalkerState_BossFight_Pace: return "BossFightPace";
			case eStalkerState_BossFight_Retreat: return "BossFightRetreat";
			case eStalkerState_BossFight_Jump: return "BossFightJump";
			case eStalkerState_MapTransfer: return "MapTransfer";
			case eStalkerState_Null: return "Null";
			case eStalkerState_Debug: return "Debug";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	tString AlertStateToString(int alState)
	{
		switch (alState)
		{
			case eStalkerAlertState_None: return "None";
			case eStalkerAlertState_Investigating: return "Investigating";
			case eStalkerAlertState_Detected: return "Detected";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	tString ModeToString(int alMode)
	{
		switch (alMode)
		{
			case eStalkerMode_Active: return "Active";
			case eStalkerMode_Passive: return "Passive";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	tString EscalationStageToString(eStalkerEscalation aEscalation)
	{
		switch (aEscalation)
		{
			case eStalkerEscalation_None: return "None";
			case eStalkerEscalation_Stage1: return "Stage 1";
			case eStalkerEscalation_Stage2: return "Stage 2";
			case eStalkerEscalation_Stage3: return "Stage 3";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	tString GetIdleAnimName() override
	{
		return msIdleAnim;
	}

	//------------------------------------------------------------
	
	void StalkerRumbleEffect(float afMaxDistance=6.f, float afAmount=0.25f, float afDuration=0.25f)
	{
		float fDist = mBaseObj.GetDistanceToPlayer2D();
		if (fDist < afMaxDistance)
		{
			float fRumble = afAmount / cMath_Clamp(fDist, 1, afMaxDistance);
			Effect_Rumble_Start(fRumble, afDuration, 0.0, 0.25);
		}
	}
	
	//------------------------------------------------------------

	//} END HELPERS

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// MESH MOVEMENT
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfMeshTime = 0;
	float fMax = 0;
	float mfMeshMovementAmount = 0;
	float mfMeshMovementAmountGoal = 0;
	
	//------------------------------------------------------------
	
	void UpdateMeshMovement(float afTimeStep)
	{
		if (mbVerletEnabled == false) return;
		if (mbVerletModuleInitialized == false) return;
		
		bool bUpdate = mfMeshMovementAmount > 0;
		mfMeshMovementAmount = cMath_IncreaseTo(mfMeshMovementAmount, 1.0f * afTimeStep, mfMeshMovementAmountGoal);
		mpVerletAnimation.SetMovementOffsetMul(mfMeshMovementAmount, mfMeshMovementAmount);
	}
	
	//------------------------------------------------------------
	
	void InitVerletModule()
	{
		if (mbVerletEnabled == false) return;
		if (mbVerletModuleInitialized) return;
		
		SetupVerletTree("j_R_shirt_cloth_5_1");
		SetupVerletTree("j_R_shirt_cloth_4_1");
		SetupVerletTree("j_R_shirt_cloth_3_1");
		SetupVerletTree("j_R_shirt_cloth_2_1");
		SetupVerletTree("j_R_shirt_cloth_1_1");
		
		SetupVerletTree("j_L_shirt_cloth_1_1");
		SetupVerletTree("j_L_shirt_cloth_2_1");
		SetupVerletTree("j_L_shirt_cloth_3_1");

		SetupVerletTree("j_shirt_cloth_1_1");
		SetupVerletTree("j_shirt_cloth_2_1");
		SetupVerletTree("j_shirt_cloth_3_1");
		
		SetupVerletTree("j_B_shirt_cloth_1_1");
		
		SetupVerletTree("j_leg_cloth_6_1");
		
		SetupVerletTree("j_R_leg_cloth_1_1");
		SetupVerletTree("j_R_leg_cloth_2_1");
		SetupVerletTree("j_R_leg_cloth_3_1");
		SetupVerletTree("j_R_leg_cloth_4_1");
		
		SetupVerletTree("j_L_leg_cloth_1_1");
		SetupVerletTree("j_L_leg_cloth_2_1");
		SetupVerletTree("j_L_leg_cloth_3_1");
		
		mpVerletAnimation.SetGravityMul(1.0f);
		mbVerletModuleInitialized = true;
	}

	//------------------------------------------------------------
	
	void SetupVerletTree(const tString&in asRoot, const tString&in asFinal="",
						float afBaseDampingMul=0.9f, float afBaseMoveToPositionMul=0.5f,
						float afNodeStartMoveToPosMul=1.0f, float afNodeEndMoveToPosMul=1.0f,
						eEasing aNodeMoveToPosMulEasing = eEasing_Linear)
	{
		cNode3D@ pRootNode = mBaseObj.GetMeshEntity().GetBoneStateFromName(asRoot);
		cNode3D@ pFinalNode = asFinal== "" ? null : mBaseObj.GetMeshEntity().GetBoneStateFromName(asFinal);
		
		mpVerletAnimation.SetupVerletTree(pRootNode, pFinalNode, mBaseObj.GetMeshEntity().GetBoneStateRoot(), 
										afBaseDampingMul, afBaseMoveToPositionMul, 
										afNodeStartMoveToPosMul, afNodeEndMoveToPosMul,
										aNodeMoveToPosMulEasing);
	}
	
	//------------------------------------------------------------
	
	//} END MESH MOVEMENT

	/////////////////////////////////////////
	// GLOBAL FUNCS
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	void _Global_GoToHole()
	{
		/////////////////
		// Setup vars
		tString sHole = cScript_GetGlobalArgString(0);
		bool bForce = cScript_GetGlobalArgBool(1);
		bool bInstant = cScript_GetGlobalArgBool(2);
		int lSpeed = cScript_GetGlobalArgInt(3);
		
		iLuxEntity@ pEnt = mBaseObj.GetMap().GetEntityByName(sHole, eLuxEntityType_Area);
		if (pEnt is null) return;
		
		tID idHole = pEnt.GetID();
		int lState = mpStateMachine.GetCurrentState();
		
		/////////////////
		// Do it instantly?
		if (bInstant)
		{
			m_idWaitInHole_Hole = idHole;
			
			SetHidden(true);
			PositionAtGhoulHole(m_idWaitInHole_Hole);
			
			mpStateMachine.ChangeState(eStalkerState_WaitInHole);
			return;
		}	
		
		/////////////////
		// Already in hole network? Move to hole!
		if (mbHidden)
		{
			if (lState == eStalkerState_WaitInHole && m_idWaitInHole_Hole != idHole)
			{
				m_idMoveBetweenHoles_GoalHole = idHole;
				mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
			}
			else if (lState == eStalkerState_MoveBetweenHoles && m_idMoveBetweenHoles_GoalHole != idHole)
			{				
				m_idMoveBetweenHoles_GoalHole = idHole;
				MoveBetweenHoles_StartMove();
			}
			else if (lState != eStalkerState_MoveBetweenHoles && lState != eStalkerState_WaitInHole)
			{
				m_idMoveBetweenHoles_GoalHole = idHole;
				mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
			}
			
			return;
		}
		
		/////////////////
		// Move to hole!
		m_idReturnToHole_Hole = idHole;
		mReturnToHole_Speed = eStalkerSpeed(lSpeed);
		
		if (bForce || lState == eStalkerState_Retreat)
		{
			mpStateMachine.ChangeState(eStalkerState_ReturnToHole);
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_EmergeFromHole()
	{
		/////////////////
		// Setup vars
		tString sHole = cScript_GetGlobalArgString(0);
		bool bInstant = cScript_GetGlobalArgBool(1);
		
		iLuxEntity@ pEnt = mBaseObj.GetMap().GetEntityByName(sHole, eLuxEntityType_Area);
		if (pEnt is null) return;
		
		tID idHole = pEnt.GetID();
		int lState = mpStateMachine.GetCurrentState();
		
		/////////////////
		// Inside hole network?
		if (mbHidden)
		{
			/////////////////
			// Do it instantly?
			if (bInstant)
			{
				SetHidden(true);
				PositionAtGhoulHole(idHole);
			}
			
			/////////////////
			// Emerge!
			m_idMoveBetweenHoles_EmergeHole = idHole;
			
			if (lState == eStalkerState_WaitInHole)
				mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
			else if (lState == eStalkerState_MoveBetweenHoles)
				MoveBetweenHoles_StartMove();
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_ApplyMapTransferData()
	{
		mlMapTransferData_SetupStage = 0;
		mbMapTransferData_InsideTransferArea = cScript_GetGlobalArgBool(0);
		mlMapTransferData_State = eStalkerState(cScript_GetGlobalArgInt(1));
		mMapTransferData_Mode = eStalkerMode(cScript_GetGlobalArgInt(2));
		mfMapTransferData_Presence = cMath_Clamp(cScript_GetGlobalArgFloat(3), 0.f, 1.f);
		mfMapTransferData_Tenacity = cMath_Clamp(cScript_GetGlobalArgFloat(4), gfStalker_TenacityMin, gfStalker_TenacityMax);
		mbMapTransferData_EmergeAllowed = cScript_GetGlobalArgBool(5);
		mbMapTransferData_RecentlyHurt = cScript_GetGlobalArgBool(6);
		mbMapTransferData_RetreatActive = cScript_GetGlobalArgBool(7);
		mMapTransferData_AlertState = eStalkerAlertState(cScript_GetGlobalArgInt(8));
		mbMapTransferData_InterestAlert = cScript_GetGlobalArgBool(9);
		mfMapTransferData_InterestAreaRadius = cScript_GetGlobalArgFloat(10);
		mfMapTransferData_InterestIncreaseCount = cScript_GetGlobalArgFloat(11);
		mfMapTransferData_InterestPauseEmergeCount = cScript_GetGlobalArgFloat(12);
		mfMapTransferData_InterestEmergeCount = cScript_GetGlobalArgFloat(13);
		mfMapTransferData_InterestEmergeTime = cScript_GetGlobalArgFloat(14);
		mvMapTransferData_InterestAreaPos = cScript_GetGlobalArgVector3f(15);
		mbMapTransferData_Emerging = cScript_GetGlobalArgBool(16);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetMode()
	{
		cScript_SetGlobalReturnInt(int(mMode));
	}
	
	//------------------------------------------------------------
	
	void _Global_GetPresence()
	{
		cScript_SetGlobalReturnFloat(mfPresence);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetGhoulHoleNetworkId()
	{
		cScript_SetGlobalReturnInt(mlGhoulHoleNetworkId);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetEmergeAllowed()
	{
		mbEmergeAllowed = cScript_GetGlobalArgBool(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetEmergeAllowed()
	{
		cScript_SetGlobalReturnBool(mbEmergeAllowed);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetRecentlyHurt()
	{
		cScript_SetGlobalReturnBool(mbHurt_RecentlyHurt);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetMode()
	{
		eStalkerMode mode = eStalkerMode(cScript_GetGlobalArgInt(0));
		bool bResetPresence = cScript_GetGlobalArgBool(1);
		
		ChangeMode(mode, bResetPresence);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetTenacity()
	{
		mfTenacity = cMath_Clamp(cScript_GetGlobalArgFloat(0), gfStalker_TenacityMin, gfStalker_TenacityMax);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetTenacity()
	{
		cScript_SetGlobalReturnFloat(mfTenacity);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetLampsFlicker()
	{
		SetLampsFlicker(cScript_GetGlobalArgBool(0));
	}
	
	//------------------------------------------------------------
	
	void _Global_GetSaveRoomBehaviorActive()
	{
		cScript_SetGlobalReturnBool(mfPlayerLeftSaveRoomCount > 0.f && mbWasInActiveModeWhenPlayerEnteredSaveRoom);
	}
	
	//------------------------------------------------------------
	
	void _Global_Jump()
	{
		bool bJumping = mpStateMachine.GetCurrentState() == eStalkerState_BossFight_Jump;
		if (bJumping)
		{
			cAnimationState@ pState = mBaseObj.GetMeshEntity().GetAnimationStateFromName(msBossFightJump_JumpAnim);
			if (pState !is null && pState.GetRelativeTimePosition() < gfStalker_SecondJumpMaxRelT)
				return;
		}
				
		mvBossFightJump_GoalPos = cScript_GetGlobalArgVector3f(0);
		mbBossFightJump_JumpingToPlatform = cScript_GetGlobalArgBool(1);
		mbBossFightJump_TurnAround = cScript_GetGlobalArgBool(2);
		mbBossFightJump_PlayerBrokeBridge = cScript_GetGlobalArgBool(3);
		
		if (bJumping)
		{
			BossFightJump_Setup(true);
		}
		else
		{
			mpStateMachine.ChangeState(eStalkerState_BossFight_Jump);
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_SetClosestJumpPos()
	{
		mvBossFight_ClosestJumpPos = cScript_GetGlobalArgVector3f(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_AddPathBlockerBody()
	{
		tID idBlocker = cScript_GetGlobalArgID(0);
		bool bManualRemovalOnly = cScript_GetGlobalArgBool(1);
		
		EvaluateObstacle_AddPathBlocker(idBlocker, GetPathBlockerIsOpenDoor(idBlocker), bManualRemovalOnly);
	}
	
	//------------------------------------------------------------
	
	void _Global_RemovePathBlockerBody()
	{
		tID idBlocker = cScript_GetGlobalArgID(0);
		EvaluateObstacle_RemovePathBlocker(idBlocker, true);
	}
	
	//------------------------------------------------------------
	
	void _Global_AddIgnoredPathBlockerBody()
	{
		tID idBlocker = cScript_GetGlobalArgID(0);
		
		if (mvEvaluateObstacle_IgnoredBlockers.find(idBlocker) == -1)
			mvEvaluateObstacle_IgnoredBlockers.push_back(idBlocker);
	}
	
	//------------------------------------------------------------
	
	void _Global_RemoveIgnoredPathBlockerBody()
	{
		tID idBlocker = cScript_GetGlobalArgID(0);
		
		int lId = mvEvaluateObstacle_IgnoredBlockers.find(idBlocker);
		if (lId != -1)
			mvEvaluateObstacle_IgnoredBlockers.removeAt(lId);
	}
	
	//------------------------------------------------------------
	
	void _Global_RemoveIgnoredSoundSourceBody()
	{
		InvestigateSound_RemoveIgnoredSoundSourceBody(cScript_GetGlobalArgID(0));
	}
	
	//------------------------------------------------------------
	
	void _Global_GetIsInsideWalls()
	{
		cScript_SetGlobalReturnBool(mbHidden);
	}
	
	//------------------------------------------------------------
	
	void _Global_Retreat()
	{
		if (mbHidden == false)
		{
			if (mbCutsceneAnimation_Active == false)
			{
				mpStateMachine.ChangeState(eStalkerState_Retreat);
			}
			else
			{
				if (mBaseObj.Timer_Exists("Timer_RetreatWhenAnimationDone") == false)
					mBaseObj.Timer_Add("Timer_RetreatWhenAnimationDone", 0.1f, "OnTimer_RetreatWhenAnimationDone", false, false);
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_RetreatWhenAnimationDone(uint64 alId)
	{
		if (mbCutsceneAnimation_Active)
		{
			mBaseObj.Timer_Add("Timer_RetreatWhenAnimationDone", 0.1f, "OnTimer_RetreatWhenAnimationDone", true, false);
			return;
		}
		
		mpStateMachine.ChangeState(eStalkerState_Retreat);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetMapTransferData()
	{
		cScript_SetGlobalVarInt("Stalker_State", mpStateMachine.GetCurrentState());
		cScript_SetGlobalVarInt("Stalker_Mode", int(mMode));
		cScript_SetGlobalVarFloat("Stalker_Presence", mfPresence);
		cScript_SetGlobalVarFloat("Stalker_Tenacity", mfTenacity);
		cScript_SetGlobalVarBool("Stalker_EmergeAllowed", mbEmergeAllowed);
		cScript_SetGlobalVarBool("Stalker_RecentlyHurt", mbHurt_RecentlyHurt);		
		cScript_SetGlobalVarBool("Stalker_RetreatActive", mbRetreat_Active);		
		cScript_SetGlobalVarInt("Stalker_AlertState", int(mAlertState));		
		cScript_SetGlobalVarBool("Stalker_InterestAlert", mbInterest_Alert);
		cScript_SetGlobalVarFloat("Stalker_InterestAreaRadius", mfInterest_AreaRadius);
		cScript_SetGlobalVarFloat("Stalker_InterestIncreaseCount", mfInterest_IncreaseCount);
		cScript_SetGlobalVarFloat("Stalker_InterestPauseEmergeCount", mfInterest_PauseEmergeCount);
		cScript_SetGlobalVarFloat("Stalker_InterestEmergeCount", mfInterest_EmergeCount);
		cScript_SetGlobalVarFloat("Stalker_InterestEmergeTime", mfInterest_EmergeTime);
		cScript_SetGlobalVarVector3f("Stalker_InterestAreaPos", mvInterest_AreaPos);
		cScript_SetGlobalVarBool("Stalker_Emerging", mbHidden && 
													 (m_idMoveBetweenHoles_EmergeHole != tID_Invalid ||
													  m_idEmerge_Hole != tID_Invalid));
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_Enter()
	{
		mpStateMachine.ChangeState(eStalkerState_BossFight_Default);
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_AddBridgeEntityIds()
	{
		mvBossFight_BridgeEntityIds.resize(0);
		
		int lNum = cScript_GetGlobalArgInt(0);
		for (int i = 0; i < lNum; ++i)
			mvBossFight_BridgeEntityIds.push_back(cScript_GetGlobalArgID(i + 1));
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_AddRetreatPosition()
	{
		mvBossFightRetreat_Positions.push_back(cScript_GetGlobalArgVector3f(0));
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_UpdateBehaviour()
	{
		BossFight_UpdateBehaviour(eStalkerBossFightBehaviour(cScript_GetGlobalArgInt(0)));
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_SetPacePosition()
	{
		mvBossFightPace_PacePosition = cScript_GetGlobalArgVector3f(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_SetIsDesperate()
	{
		BossFight_SetIsDesperate(cScript_GetGlobalArgBool(0));
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_SetEndArea()
	{
		m_idBossFight_EndArea = cScript_GetGlobalArgID(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_SetKillDistance()
	{
		mfBossFight_KillDistance = cScript_GetGlobalArgFloat(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_BossFight_SetAllowSlowdownTime()
	{
		BossFight_SetAllowSlowdownTime(cScript_GetGlobalArgFloat(0));
	}
	
	//------------------------------------------------------------
	
	void _Global_PlayCutsceneAtEntity()
	{
		msIdle_CutsceneAnim = cScript_GetGlobalArgString(0);
		msIdle_CutsceneAnimEnt = cScript_GetGlobalArgString(1);
		mfIdle_CutsceneAnimFadeTime = cScript_GetGlobalArgFloat(2);
		msIdle_CutsceneStartedCallback = cScript_GetGlobalArgString(3);
		mpStateMachine.ChangeState(eStalkerState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_AddGratingWall()
	{
		tID id = cScript_GetGlobalArgID(0);
		if (mvCrawlThroughVent_GratingWallIds.find(id) == -1)
			mvCrawlThroughVent_GratingWallIds.push_back(id);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetInterestAlertHoleID()
	{
		tID idHole = tID_Invalid;
		if (mbInterest_Alert && 
			mpStateMachine.GetCurrentState() == eStalkerState_WaitInHole)
		{
			idHole = m_idWaitInHole_Hole;
		}
		
		cScript_SetGlobalReturnID(idHole);
	}
	
	//------------------------------------------------------------
	
	void _Global_Debug()
	{
		mpStateMachine.ChangeState(eStalkerState_Debug);
	}
	
	//------------------------------------------------------------

	//} END GLOBAL

	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// STALKER SPECIFIC CODE
	//=======================================
	//{//////////////////////////////////////

	//===========================================================
	
	//------------------------------------------------------------
	
	void HitByProp(float afAmount, float afMass, iPhysicsBody@ apBody, cLuxProp@ apProp)
	{		
		//////////////////
		// Break prop if large and ran through it!
		if (Blackboard_GetCanBodyBlockPath(apBody) && 
			GetIsRunningQuickly() && 
			GetIsPropBreakable(apProp))
		{
			BreakPropWhileRunning(apProp);
			return;
		}
		
		//////////////////
		// Caused by player?
		mbLastHitByPropThrownByPlayer = apBody.GetThrownByPlayer();
		m_idLastHitByPropThrownByPlayerId = mbLastHitByPropThrownByPlayer && apProp !is null ? apProp.GetID() : tID_Invalid;
		
		//////////////////
		// Is it a molotov?		
		if (apProp.GetVarBool("IsMolotovCocktail"))
		{
			mbLastHitByPropWasMolotov = true;
			
			cVector3f vPos = apBody.GetWorldPosition();
			iPhysicsBody@ pCurrentBody = mBaseObj.GetCharBody().GetCurrentBody();
			int lDamageId = mBaseObj.GetMap().GetNewAttackInstanceID();
			
			mBaseObj.GiveDamage(pCurrentBody, vPos, vPos, eDamageType_Fire, 0.3f, 1, 0.f, 0.f, apProp.GetID(), lDamageId);
		}
		else
		{
			mbLastHitByPropWasMolotov = false;
		}
		
		//////////////////
		// Keep track of props collided with not caused by player
		if (mbLastHitByPropThrownByPlayer == false)
		{
			//////////////////
			// Reset track time if already exists
			for (uint i = 0; i < mvCollideProps.size(); ++i)
			{
				if (mvCollideProps[i].m_idProp == apProp.GetID())
				{
					mvCollideProps[i].mfTimeSinceCollision = 0.f;
					return;
				}
			}
			
			//////////////////
			// Track prop!
			cStalker_CollidePropData data;
			data.msPropName = apProp.GetName();
			data.m_idProp = apProp.GetID();
			data.mfTimeSinceCollision = 0.f;
			
			mvCollideProps.push_back(data);
		}
	}
	
	//------------------------------------------------------------
	
	void GiveDamage(iPhysicsBody@ apBody, const cVector3f &in avOrigin, const cVector3f &in avHitPos, cLuxDamageProperties@ apDamageProps)
	{
		/////////////////
		// State check
		int lState = mpStateMachine.GetCurrentState();
		
		if (mbHidden) return;
		if (lState == eStalkerState_KillPlayer) return;
		if (lState == eStalkerState_ThrowPlayer) return;
		if (mbBossFightJump_Fall) return;
		
		/////////////////
		// Setup vars		
		bool bEnterHurt = false;
		bool bHurtByPlayer = false;
		int lHitboxBodyId = -1;		
		
		if (apBody !is null)
		{
			for (int i = 0; i < mBaseObj.GetHitboxBodyNum(); ++i)
			{
				if (apBody is mBaseObj.GetHitboxBody(i))
				{
					lHitboxBodyId = i;
					break;
				}
			}
		}
		
		mHurt_DamageType = eDamageType(apDamageProps.mDamageType);
		
		/////////////////
		// Skip if recently hit by shotgun
		if (mHurt_DamageType == eDamageType_Gun && 
			BulletHandler_GetLastDamageBulletType() == eBulletType_Shotgun &&
			mBaseObj.Timer_Exists("Timer_ShotgunDamageCooldown"))
		{
			return;
		}
		
		/////////////////
		// Give damage
		if (GetSensesActive(false) && 
			(mbCutsceneAnimation_Active == false || 
			 lState == eStalkerState_Emerge ||
			 lState == eStalkerState_BreakDoor ||
			 lState == eStalkerState_BossFight_Jump ||
			 lState == eStalkerState_CrawlThroughVent ||
			 lState == eStalkerState_ExamineRabbit ||
			 lState == eStalkerState_BlockedByProp))
		{
			/////////////////
			// Gun
			if (apDamageProps.mDamageType == eDamageType_Gun)
			{
				bHurtByPlayer = true;
				
				/////////////////////
				// Get body that was hit
				iPhysicsBody@ pBody = mBaseObj.GetHitboxBody(lHitboxBodyId);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Shot by gun in body: '" + (pBody !is null ? pBody.GetName() : "") + "'");

				/////////////////////
				// Shot count
				if (mbHurt_RecentlyHurt == false)
				{
					Blackboard_IncStalkerShotCount();
				}
				
				GameStats_IncreaseEntryAmount(eHeroStats_StalkerHitCount);
				
				/////////////////////
				// Setup hurt
				if (lState != eStalkerState_Hurt)
				{
					if (mlHurt_RecentlyShotCount > 0 && mbRetreat_Active)
						Hurt_PlaySound(true);
					else						
						bEnterHurt = true;
				}
				else
				{
					if (mbBossFight_Active == false && Hurt_GetShouldRetreat())
						Hurt_SetupRetreat(bHurtByPlayer);
				}
				
				////////////////////
				// Shotgun cooldown
				if (BulletHandler_GetLastDamageBulletType() == eBulletType_Shotgun)
				{
					mbHurt_ShotByShotgun = true;
					mBaseObj.Timer_Add("Timer_ShotgunDamageCooldown", 1.f);
				}
			}
			
			/////////////////////
			// Grenade
			else if (apDamageProps.mDamageType == eDamageType_Grenade)
			{				
				bEnterHurt = true;
				
				cLuxProp@ pGrenade = cLux_ID_Prop(apDamageProps.m_idSource);
				if (pGrenade !is null && 
					pGrenade.GetVarBool("IsTrap") && 
					pGrenade.GetVarString("TriggerCause") == "Player")
				{
					bHurtByPlayer = true;
					Achievement_Unlock(eAchievement_Trickster);
				}
				
				if (pGrenade !is null && 
					pGrenade.GetVarBool("IsTrap") == false &&
					pGrenade.GetVarString("TriggerCause") != "Stalker")
				{
					bHurtByPlayer = true;
				}
		
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hurt by grenade!");
			}
				
			/////////////////////
			// Gas
			else if (apDamageProps.mDamageType == eDamageType_Gas)
			{
				bEnterHurt = mbHurt_RecentlyHurt == false;
				
				if (mbBossFight_Active && 
					mBaseObj.Timer_Exists(gsStalker_BossFightIgnoreEnvironmentalDamageTimer))
				{
					bEnterHurt = false;
				}
				
				if (bEnterHurt == false)
				{
					Hurt_PlaySound();
				}

				iLuxEntity@ pGas = cLux_ID_Entity(apDamageProps.m_idSource);
				if (pGas !is null && 
					pGas.GetVarBool("IsTrap") && 
					pGas.GetVarString("TriggerCause") == "Player")
				{
					bHurtByPlayer = true;
					Achievement_Unlock(eAchievement_Trickster);
				}
					
				if (pGas !is null && 
					(pGas.GetVarBool("IsTrap") == false || pGas.GetVarString("TriggerCause") != mBaseObj.GetName()))
				{
					bHurtByPlayer = true;
					Achievement_Unlock(eAchievement_ChemicalWeaponExpert);
				}				
					
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hurt by gas!");
			}
				
			/////////////////////
			// Fire
			else if (apDamageProps.mDamageType == eDamageType_Fire)
			{
				bEnterHurt = mbHurt_RecentlyHurt == false;		
				
				if (mbBossFight_Active && 
					mBaseObj.Timer_Exists(gsStalker_BossFightIgnoreEnvironmentalDamageTimer))
				{
					bEnterHurt = false;
				}
					
				if (bEnterHurt == false)
				{
					Hurt_PlaySound();
				}

				iLuxEntity@ pFire = cLux_ID_Entity(apDamageProps.m_idSource);
				if (pFire !is null)
				{
					if (pFire.GetVarBool("IsTrap") && 
						pFire.GetVarString("TriggerCause") == "Player")
					{
						bHurtByPlayer = true;
						Achievement_Unlock(eAchievement_Trickster);
					}
					
					if (pFire.GetVarBool("IsMolotovCocktail") || pFire.GetVarBool("IsTrap") == false)
					{
						bHurtByPlayer = true;
					}
				}
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hurt by fire!");
			}
		}
		
		/////////////////////
		// Enter hurt?
		if (bEnterHurt)
		{
			////////////////////////
			// Setup hurt
			if (lState == eStalkerState_BossFight_Jump)
			{
				bEnterHurt = BossFightJump_HandleHurt(apDamageProps.mDamageType);
			}
			else if (mbBossFight_Active)
			{
				bEnterHurt = true;
				mBaseObj.Timer_Add("Timer_BossFightHandleHurt", 0.05f, "OnTimer_BossFightHandleHurt", false, false);
			}
			else if (lState == eStalkerState_Emerge && mbCutsceneAnimation_Active)
			{
				mbEmerge_Hurt = true;
				Hurt_PlaySound();
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Currently emerging, will enter hurt once done!");
			}
			else if (lState == eStalkerState_CrawlThroughVent)
			{
				mbCrawlThroughVent_Hurt = true;
				Hurt_PlaySound();
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Currently crawling through vent, will enter hurt once done!");
			}
			else
			{
				////////////////
				// Enter hurt
				if (mbPlayQuickTurnAnim)
				{
					mlQuickTurnDoneState = eStalkerState_Hurt;
					mbHurt_ShotDuringQuickTurn = true;
					bEnterHurt = mHurt_DamageType != eDamageType_Gun &&
								 mHurt_DamageType != eDamageType_Grenade;
								 
					Hurt_PlaySound();
				}
				else
				{
					mpStateMachine.ChangeState(eStalkerState_Hurt);	
				}
			}
			
			////////////////////////
			// Increase escalation
			if (bHurtByPlayer)
			{
				mbHurt_HurtByPlayer = true;
				Blackboard_IncreaseStalkerEscalation(false);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Increasing escalation from damage!");
			}
		}
		
		/////////////////////
		// Play additive anim?
		bool bPlayAdditiveAnim = bEnterHurt == false;
		if (bPlayAdditiveAnim)
		{
			cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
			cAnimationState@ pAnim = pMeshEnt !is null ? pMeshEnt.GetAnimationStateFromName(gsStalkerAnim_HurtAdditive) : null;
			
			if (pMeshEnt !is null && pAnim !is null)
			{
				pMeshEnt.PlayName(pAnim.GetName(), false, false);				
				
				pAnim.SetWeight(0.f);
				pAnim.FadeIn(0.1f);
				pAnim.SetSpeed(1.f);
				pAnim.SetRelativeTimePosition(0.f);
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnPathFindingResult(bool abSuccessful)
	{
		/////////////////////////
		// Special case if in boss fight
		if (mbBossFight_Active)
		{
			BossFight_OnPathFindingResult(abSuccessful);
			return;
		}
		
		/////////////////////////
		// No path found!
		if (abSuccessful == false)
		{
			++mlPathfindingFailCount;
			
			/////////////////////////
			// Remove all path blockers and try again!
			if (mlPathfindingFailCount < 3 && mbBossFight_Active == false)
			{				
				EvaluateObstacle_RemoveAllPathBlockers(true, true, false);	
				mpPathfinder.MoveTo(mpPathfinder.GetGoalPos(), 1.f, false);
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path found, removing all existing path blockers as failsafe!", false, true);
			}
		}
	
		/////////////////////////
		// Found a path!
		else
		{
			mlPathfindingFailCount = 0;
			
			/////////////////
			// Ignore physical blocker if specifically told to head to a position inside one
			tID idBlockingBody = tID_Invalid;
			if (EvaluateObstacle_GetPointIsInsidePathBlocker(mpPathfinder.GetGoalPos(), idBlockingBody))
			{
				iPhysicsBody@ pBody = cLux_ID_Body(idBlockingBody);				
				if (pBody !is null && Blackboard_GetIsBodyDamageArea(pBody) == false)
				{
					EvaluateObstacle_RemovePathBlocker(idBlockingBody, false);
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Goal pos is inside physical blocker, removing blocker!", false, true);
				}
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnRecieveMessage(int alMessageId, cLuxEntityMessageData @apData)
	{		
		////////////////////////
		// Handle footsteps
		if (alMessageId == eLuxEntityMessage_AnimationFootStep)
		{			
			if (mbFootstepSoundsActive == false) return;
			
			tString sSoundPath = "creatures/stalker/";
			tString sSoundCategory = "";
			tString sSoundName = "";
			
			int lState = mpStateMachine.GetCurrentState();
			int lSpeedState = mpMover.GetSpeedState();
			bool bRunning = lSpeedState == eStalkerSpeed_Run;
			
			sSoundName = bRunning ? "ghoul_walk" : "ghoul_walk";
			
			////////////////////////////
			// Play sound!
			tString sSound = sSoundPath + sSoundCategory + sSoundName;
			cSoundEntity@ pSound = mBaseObj.GetMap().GetWorld().CreateSoundEntity("Sound_Footstep_" + mBaseObj.GetName(), sSound, true);
			
			if (pSound !is null)
			{
				StalkerRumbleEffect(6.f);
				
				///////////////////
				// Play at socket?
				//tString sSocket = apData.msX;			
				cNode3D@ pSocket = mBaseObj.GetMeshEntity().GetSocket(apData.msX);
				
				if (pSocket !is null)
				{
					pSocket.AddEntity(pSound);
				}
				else
				{
					pSound.SetWorldPosition(mBaseObj.GetCharBody().GetFeetPosition());
				}
				
				pSound.SetScriptableIsSaved(false);
				
				if (lState == eStalkerState_SitAndWait ||
					(lState == eStalkerState_Emerge && mbEmerge_SitAndWait))
				{
					pSound.SetUseCustomProperties(true);
					pSound.SetCustomMaxDistance(20.f);
				}
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnAttackDamage()
	{
		if (mbBossFight_Active)
		{
			BossFight_OnAttackDamage();
		}
	}
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STALKER UPDATES
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	void UpdateInPlayerProximity(float afDeltaTime)
	{
		mfIsInPlayerProximityTimer += afDeltaTime;
		if (mfIsInPlayerProximityTimer > 1.f)
		{
			mfIsInPlayerProximityTimer = 0.f;
			
			float fDist = mBaseObj.GetDistanceToPlayer2D();
			int lState = mpStateMachine.GetCurrentState();
			
			if (mbHidden) 
			{
				fDist = 1000.f;
			}
			else if (mbSitAndWait_SeenByPlayer == false &&
					 (lState == eStalkerState_SitAndWait ||
					  (lState == eStalkerState_Emerge && mbEmerge_SitAndWait)))
			{
				fDist *= 3.f;			
			}
			
			Player_AddScaredSource(fDist, mbIsOnScreen);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateHeadTracker(float afDeltaTime)
	{
		//////////////////
		// Setup vars
		iLuxEntity@ pEnt = cLux_ID_Entity(m_idHeadTracker_TargetEntity);
		
		if (pEnt is null) return;		
		if (pEnt !is mBaseObj.GetMap().GetPlayerEntity()) return;
		
		bool bActive = true;
		cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();
		
		//////////////////
		// Deactivate?
		if (mBaseObj.PlayerIsSeen() == false)
		{
			bActive = false;			
		}
		else if (mbCutsceneAnimation_Active)
		{
			bActive = false;		
		}
		else if (mAlertState == eStalkerAlertState_None)
		{
			bActive = false;
		}
		
		//////////////////
		// Any glimpse left or right anim playing?
		else if (pAnim !is null && 
				 cString_GetFirstStringPos(pAnim.GetName(), "glimpse_left") != -1 &&
				 cString_GetFirstStringPos(pAnim.GetName(), "glimpse_right") != -1)
		{
			bActive = false;
		}
		
		mpHeadTracker.SetActive(bActive);
	}
	
	//------------------------------------------------------------
	
	void UpdateHeadAnimation(float afDeltaTime)
	{		
		/////////////////
		// Setup vars
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		if (pMeshEnt is null) return;
		
		/////////////////
		// Update allowed types			
		int lAnimTypeFlags = eStalkerHeadAnimationType_Mouth | 
							 eStalkerHeadAnimationType_Twist | 
							 eStalkerHeadAnimationType_Twitch;
			
		if (mpHeadTracker.IsActive())
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
		
		if (mbHeadAdjustment_HeadColliding)
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
		
		if (mbUseCrampedAnims)
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
		
		if (mBaseObj.PlayerIsDetected())
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
		
		if (mAlertState == eStalkerAlertState_Detected)
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
				
		if (mbCutsceneAnimation_Active)
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Mouth);
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
				
		if (mpMover.GetUseMoveStateAnimations() == false)
		{
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Mouth);
			lAnimTypeFlags &= (~eStalkerHeadAnimationType_Twist);
		}
		
		/////////////////
		// Currently playing?
		if (mlHeadAnimation_CurrentId != -1)
		{
			cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationState(mlHeadAnimation_CurrentId);
			if (pAnim !is null) 
			{
				///////////////////
				// Fade out?
				bool bFadeOut = false;
				
				if (pAnim.IsOver())
				{
					bFadeOut = true;
				}
				else if ((lAnimTypeFlags & mHeadAnimation_CurrentType) == 0)
				{
					bFadeOut = true;
				}
				
				if (bFadeOut)
				{
					mlHeadAnimation_CurrentId = -1;					
					pAnim.FadeOut(0.3f);
				}
				else
				{
					return;
				}
			}
		}		
		
		/////////////////
		// Play anim?
		mfHeadAnimation_PlayCount -= afDeltaTime;
		if (mfHeadAnimation_PlayCount <= 0.f)
		{
			mfHeadAnimation_PlayCount = cMath_RandRectf(gfStalker_MinHeadAnimationDelay, gfStalker_MaxHeadAnimationDelay);
			
			tString sAnim = GetHeadAnim(lAnimTypeFlags, mHeadAnimation_CurrentType);		
			int lId = pMeshEnt.GetAnimationStateIndex(sAnim);
			cAnimationState@ pAnim = pMeshEnt.GetAnimationState(lId);
		
			if (pAnim !is null)
			{
				mlHeadAnimation_CurrentId = lId;
				
				pMeshEnt.PlayName(sAnim, false, false);
				
				pAnim.SetWeight(0.f);
				pAnim.FadeIn(0.3f);
				pAnim.SetSpeed(1.f);
				pAnim.SetRelativeTimePosition(0.f);
			}
		}	
	}
	
	//------------------------------------------------------------
	
	tString GetHeadAnim(int alAnimTypeFlags, eStalkerHeadAnimationType &out aType)
	{		
		//////////////////
		// Get index array from flags
		array<array<int>@> vAnimIndexArrays;
		array<eStalkerHeadAnimationType> vAvailableAnimTypes;
	
		if ((alAnimTypeFlags & eStalkerHeadAnimationType_Mouth) != 0)
		{
			vAnimIndexArrays.push_back(mvHeadAnimation_MouthAnimIndices);
			vAvailableAnimTypes.push_back(eStalkerHeadAnimationType_Mouth);
		}
		
		if ((alAnimTypeFlags & eStalkerHeadAnimationType_Twist) != 0)
		{
			vAnimIndexArrays.push_back(mvHeadAnimation_TwistAnimIndices);
			vAvailableAnimTypes.push_back(eStalkerHeadAnimationType_Twist);
		}
		
		if ((alAnimTypeFlags & eStalkerHeadAnimationType_Twitch) != 0)
		{
			vAnimIndexArrays.push_back(mvHeadAnimation_TwitchAnimIndices);
			vAvailableAnimTypes.push_back(eStalkerHeadAnimationType_Twitch);
		}

		int lArrayId = cMath_RandRectl(0, vAnimIndexArrays.size() - 1);
		array<int>@ pAnimIndices = vAnimIndexArrays[lArrayId];
		
		if (pAnimIndices is null)
			return "";
		
		//////////////////
		// Get anim name array
		const tString[]@ pAnims = null;
		aType = vAvailableAnimTypes[lArrayId];
			
		switch (aType)
		{
			case eStalkerHeadAnimationType_Mouth: 	@pAnims = gsStalkerAnim_Head_Mouth;		break;
			case eStalkerHeadAnimationType_Twist: 	@pAnims = gsStalkerAnim_Head_Twist;		break;
			case eStalkerHeadAnimationType_Twitch:	@pAnims = gsStalkerAnim_Head_Twitch;	break;
		}
		
		if (pAnims is null)
			return "";
		
		//////////////////
		// Index array empty? Reset it!
		if (pAnimIndices.size() == 0)
		{
			for (int i = 0; i < pAnims.size(); ++i)
				pAnimIndices.push_back(i);
		}
		
		//////////////////
		// Get random anim
		int lAnimIndicesId = cMath_RandRectl(0, pAnimIndices.size() - 1);
		int lAnimId = pAnimIndices[lAnimIndicesId];		
		tString sAnim = pAnims[lAnimId];
		
		//////////////////
		// Remove index from selection
		pAnimIndices.removeAt(lAnimIndicesId);
		
		return sAnim;
	}
	
	//------------------------------------------------------------
	
	void UpdateAdditiveHurtAnimation(float afDeltaTime)
	{
		cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(gsStalkerAnim_HurtAdditive);
		
		if (pAnim !is null && 
			pAnim.IsOver() &&
			pAnim.IsFading() == false)
		{
			pAnim.FadeOut(0.1f);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateCrawlThroughVent(float afDeltaTime)
	{
		///////////////////
		// Escape?
		int lState = mpStateMachine.GetCurrentState();
		
		if (mbHidden) return;		
		if (lState == eStalkerState_CrawlThroughVent ||
			lState == eStalkerState_Emerge ||
			lState == eStalkerState_Alert ||
			lState == eStalkerState_AttackClose ||
			lState == eStalkerState_Stunned ||
			lState == eStalkerState_BreakDoor ||
			lState == eStalkerState_Hurt ||
			lState == eStalkerState_KillPlayer ||
			lState == eStalkerState_Roar ||
			lState == eStalkerState_ThrowPlayer ||
			lState == eStalkerState_SitAndWait ||
			lState == eStalkerState_MapTransfer ||
			lState == eStalkerState_Null)
		{
			return;
		}
		
		///////////////////
		// Go through vent?
		for (int i = 0; i < mvCrawlThroughVent_GratingWallIds.size(); ++i)
		{
			cLuxProp@ pProp = cLux_ID_Prop(mvCrawlThroughVent_GratingWallIds[i]);
			if (pProp is null) continue;
			
			if (CrawlThroughVent_Setup(pProp))
			{
				if (lState != eStalkerState_BlockedByProp && 
					lState != eStalkerState_Blocked &&
					lState != eStalkerState_EvaluateObstacle &&
					lState != eStalkerState_BreakDoor)
				{
					mlCrawlThroughVent_NextState = lState;
				}
				else
				{
					mlCrawlThroughVent_NextState = mlBlocked_PrevState;
				}
				
				m_idCrawlThroughVent_GratingWallId = pProp.GetID();
				mpStateMachine.ChangeState(eStalkerState_CrawlThroughVent);
				break;
			}			
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateMusic(float afDeltaTime)
	{
		if (mlMapTransferData_SetupStage != -1) return;
		
		eTerrorMusicStage stage;
		int lCurrentState = mpStateMachine.GetCurrentState();
		
		if (mbHidden)														stage = eTerrorMusicStage_None;
		else if (mbBossFight_Active)										stage = eTerrorMusicStage_None;
		else if (lCurrentState == eStalkerState_KillPlayer)					stage = eTerrorMusicStage_None;
		else if (lCurrentState == eStalkerState_PreHunt)					stage = eTerrorMusicStage_Hunting;
		else if (lCurrentState == eStalkerState_Hunt)						stage = eTerrorMusicStage_Hunting;
		else if (mAlertState > eStalkerAlertState_None)						stage = eTerrorMusicStage_Searching;
		else																stage = eTerrorMusicStage_Default;
		
		Terror_SetEnemyMusicStage(eTerrorMusicAgentType_Stalker, stage);
	}
	
	//------------------------------------------------------------
	
	void UpdateFallingFailSafe(float afDeltaTime)
	{
		///////////////
		// Time
		mfFallingFailSafeUpdateCount -= afDeltaTime;
		if (mfFallingFailSafeUpdateCount > 0.f) return;		
		mfFallingFailSafeUpdateCount = 1.f;
		
		///////////////
		// Checks
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		if (pCharBody is null) return;
		if (pCharBody.IsOnGround()) return;
		if (mbHidden) return;
		if (mpStateMachine.GetCurrentState() == eStalkerState_Null) return;
		if (mbBossFight_Active) return;		
		
		///////////////
		// Falling? Teleport!
		float fYPosDiff = cMath_Abs(mBaseObj.GetPlayerFeetPos().y - pCharBody.GetFeetPosition().y);
		if (fYPosDiff > 100.f)
		{
			tID idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition());
			if (idHole != tID_Invalid)
			{
				SetHidden(true);
				PositionAtGhoulHole(idHole);
				mpStateMachine.ChangeState(eStalkerState_WaitInHole);
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Falling! Teleporting to closest hole.");
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateEyePosition(float afDeltaTime)
	{
		///////////////////////
		// Should eye pos be at socket or default pos?
		bool bPrevEyePositionAtHeadSocket = mbEyePositionAtHeadSocket;
		
		if (mbHeadAdjustment_HeadColliding)
		{
			mbEyePositionAtHeadSocket = false;
		}
		else if (mbCutsceneAnimation_Active)
		{
			mbEyePositionAtHeadSocket = true;
		}
		else if (mpMover.GetCustomAnimActive())
		{
			mbEyePositionAtHeadSocket = true;
		}
		else if (mlHeadAnimation_CurrentId != -1 && 
				 mHeadAnimation_CurrentType == eStalkerHeadAnimationType_Twist)
		{	
			mbEyePositionAtHeadSocket = true;
		}
		else
		{
			mbEyePositionAtHeadSocket = false;
		}
		
		if (bPrevEyePositionAtHeadSocket != mbEyePositionAtHeadSocket)
		{
			if (mbEyePositionAtHeadSocket)
				mBaseObj.SetEyePositionSocket(gsStalker_HeadSocket);
			else
				mBaseObj.ResetEyePositionSocket();
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateIsOnScreen(float afDeltaTime)
	{
		if (mbHidden == false)
			mbIsOnScreen = mBaseObj.CheckIsOnScreen(true);
	}
	
	//------------------------------------------------------------
	
	void UpdateMode(float afDeltaTime)
	{		
		///////////////
		// Setup vars
		bool bGeneratorOn = Generator_GetState() == eGeneratorState_On;		
		
		///////////////
		// Active mode 
		if (mMode == eStalkerMode_Active)
		{		
			///////////////
			// Calculate presence
			if (mbPresencePaused == false)
			{
				float fPresenceAdd = 0.f;		
				
				///////////////
				// Proximity
				float fProximityMul = 1.f;
				
				if (mbHidden == false)
				{
					float fDist = mBaseObj.GetDistanceToPlayer();
					fProximityMul += (1.f - cMath_Clamp(fDist / gfStalker_PresenceProximityMaxDist, 0.f, 1.f));
				}
				
				fPresenceAdd += gfStalker_PresenceProximityRate * fProximityMul * afDeltaTime;
				
				///////////////
				// Visibility
				if (mbIsOnScreen)
				{
					fPresenceAdd += gfStalker_PresenceOnScreenRate * afDeltaTime; 
				}
				
				///////////////
				// Aggression
				if (GetIsAggressive())
				{
					fPresenceAdd += gfStalker_PresenceAggressiveRate * afDeltaTime;
				}
				
				///////////////
				// Generator on?
				if (bGeneratorOn)
				{
					fPresenceAdd *= 1.5f;
				}
				else
				{
					float fDifficultyMul;				
					switch (Game_GetDifficultyMode())
					{
						case eGameMode_Easy: fDifficultyMul = 2.f; 	break;
						case eGameMode_Hard: fDifficultyMul = 0.5f; break;
						default:			 fDifficultyMul = 1.f; 	break;
					}
					
					fPresenceAdd *= (0.5f * fDifficultyMul);
				}
				
				////////////////
				// Tenacity
				float fTenacity = cMath_Clamp(mfTenacity, gfStalker_TenacityMin, gfStalker_TenacityMax * 0.75f);
				fPresenceAdd *= (1.f + 1.f - fTenacity);

				///////////////
				// Apply add
				mfPresence += fPresenceAdd * mfPresenceIncreaseMul;
			}			
			
			///////////////
			// Presence full, enter passive!
			if (mfPresence >= 1.f)
			{
				if (mbBossFight_Active == false)
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Presence full!");
				
				bool bEnterPassive = true;
				
				if (mbInterest_Alert)
				{
					bEnterPassive = false;
					mfPresence = 0.75f;
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Staying in active since in interest alert!");
				}

				if (mbBossFight_Active)
				{
					bEnterPassive = false;
				}
				
				///////////////
				// Enter passive?
				if (bEnterPassive)
				{
					mfPresence = 1.f;
					ChangeMode(eStalkerMode_Passive, false);		
				}		
			}			
		}
		
		///////////////
		// Passive mode
		else if (mMode == eStalkerMode_Passive)
		{
			///////////////
			// Calculate presence
			if (mbPresencePaused == false)
			{
				float fPresenceDecrease = 0.f;
				
				///////////////
				// Hidden
				if (mbHidden)
				{
					fPresenceDecrease += gfStalker_PresenceDecreaseRate * afDeltaTime; 
				}
				
				///////////////
				// Hurt
				if (mbHurt_RecentlyHurt)
				{
					float fTenacityMid = gfStalker_TenacityMax / 2.f;
					float fTenacity = cMath_Clamp(mfTenacity - fTenacityMid, gfStalker_TenacityMin, fTenacityMid);
					
					float fHurtByPlayerMul = mbHurt_HurtByPlayer ? 1.f : 2.f;
										
					float fEscalationMul;
					switch (Blackboard_GetStalkerEscalation())
					{
						case eStalkerEscalation_None: 	fEscalationMul = 1.f; 	break;
						case eStalkerEscalation_Stage1: fEscalationMul = 1.05f; break;
						case eStalkerEscalation_Stage2:	fEscalationMul = 1.15f;	break;
						case eStalkerEscalation_Stage3:	fEscalationMul = 1.3f;	break;
					}
					
					float fDifficultyMul;
					switch (Game_GetDifficultyMode())
					{
						case eGameMode_Easy: 	fDifficultyMul = 0.5f; 	break;
						case eGameMode_Hard: 	fDifficultyMul = 2.0f; 	break;
						default: 				fDifficultyMul = 1.f; 	break;
					}					
					
					fPresenceDecrease *= (0.7f + (0.3f * fTenacity)) * fHurtByPlayerMul * fEscalationMul * fDifficultyMul;
				}
				
				///////////////
				// Generator on?
				if (bGeneratorOn)
				{
					fPresenceDecrease *= 0.75f;					
				}
				else
				{
					if (mbHurt_RecentlyHurt) 	fPresenceDecrease *= 1.25f;
					else						fPresenceDecrease *= 2.f;					
				}
								
				////////////////
				// Tenacity
				fPresenceDecrease *= 1.f - ((1.f - mfTenacity) * 0.3f);
				
				///////////////
				// Apply decrease
				mfPresence -= fPresenceDecrease * mfPresenceDecreaseMul * mfRandPresenceDecreaseMul;
			}

			///////////////
			// Presence at 0!
			if (mfPresence <= 0.f)
			{
				if (mbBossFight_Active == false)
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Presence at 0!");
				
				bool bEnterActive = true;
				
				if (mbPlayerIsInSaveRoom || mfPlayerLeftSaveRoomCount > 0.f)
				{
					bEnterActive = false;
					mfPresence = 0.1f;
				}
				
				if (mbBossFight_Active)
				{
					bEnterActive = false;
				}
				
				///////////////
				// Enter active?
				if (bEnterActive)
				{
					mfPresence = 0.f;
					ChangeMode(eStalkerMode_Active, false);			
				}
			}
		}
	}
	
	//------------------------------------------------------------	
	
	void UpdateInterest(float afDeltaTime)
	{
		///////////////////
		// Setup vars
		int lState = mpStateMachine.GetCurrentState();
		bool bGeneratorOn = Generator_GetState() == eGeneratorState_On;
		bool bStalkerWithinRadius = (mvInterest_AreaPos - mBaseObj.GetPosition()).SqrLength() < mfInterest_AreaRadius * mfInterest_AreaRadius;
		
		///////////////////
		// Count
		mfInterest_IncreaseCount += afDeltaTime;		
		
		///////////////////
		// Update radius
		float fSpeed;
		float fSpeedMul = bGeneratorOn ? 1.f : 0.5f;
		
		if (mbInterest_Alert)
		{
			bool bPauseIfNotWithinRadius = mbHidden == false ||
										   lState != eStalkerState_WaitInHole;
										   
			if (bPauseIfNotWithinRadius &&
				bStalkerWithinRadius == false)
			{
				fSpeed = 0.f;
			}
			else
			{
				fSpeed = gfStalker_InterestAreaRadiusSpeedSlow * fSpeedMul;
			}
		}
		else if (mfInterest_IncreaseCount < gfStalker_StopInterestAreaRadiusIncreaseTime)
		{
			fSpeed = 0.f;
		}
		else if (mfInterest_IncreaseCount < gfStalker_SlowInterestAreaRadiusIncreaseTime)
		{
			fSpeed = gfStalker_InterestAreaRadiusSpeedSlow * 2.f * fSpeedMul;
		}
		else
		{
			fSpeed = gfStalker_InterestAreaRadiusSpeedFast;
		}
		
		mfInterest_AreaRadius += afDeltaTime * fSpeed;
		mfInterest_AreaRadius = cMath_Clamp(mfInterest_AreaRadius, gfStalker_MinInterestAreaRadius, mfInterest_MapRadius);
		
		///////////////////
		// Emerge?
		float fEmergeCountGoal;
		
		if (mbHidden && 
			lState == eStalkerState_WaitInHole &&
			mfInterest_AreaRadius < gfStalker_AlertInterestAreaRadiusMin)
		{
			fEmergeCountGoal = mfInterest_EmergeTime;
		}
		else
		{
			if (mfInterest_EmergeCount >= mfInterest_EmergeTime &&
				mfInterest_PauseEmergeCount <= 0.f)
			{
				mfInterest_PauseEmergeCount = 4.f;
			}
		
			fEmergeCountGoal = 0.f;
		}
		
		mfInterest_PauseEmergeCount = cMath_IncreaseTo(mfInterest_PauseEmergeCount, afDeltaTime, 0.f);
		
		if (mfInterest_PauseEmergeCount <= 0.f)
			mfInterest_EmergeCount = cMath_IncreaseTo(mfInterest_EmergeCount, afDeltaTime, fEmergeCountGoal);
		
		///////////////////
		// Reset alert?
		if (mfInterest_AreaRadius > gfStalker_AlertInterestAreaRadiusMax)
		{
			SetInterestAlert(false);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdatePlayerHiding(float afDeltaTime)
	{
		////////////////////////
		// Don't lose track of player if they while while spotted
		int lState = mpStateMachine.GetCurrentState();
		bool bHiding = Player_GetIsHiding();
		bool bPlayerSpotted = mBaseObj.PlayerIsDetected() ||
							  (mAlertState == eStalkerAlertState_Detected && mfTimeSincePlayerInLoS < 3.f);
		
		if (bHiding && 
			mbPlayerIsHiding == false &&
			bPlayerSpotted)
		{
			mbPlayerHidWhileSpotted = true;
		}
		
		if (bHiding && 
			mbPlayerHidWhileSpotted &&
			lState != eStalkerState_AttackClose &&
			lState != eStalkerState_BlockedByProp &&
			lState != eStalkerState_Blocked &&
			lState != eStalkerState_BreakDoor &&
			lState != eStalkerState_ThrowPlayer &&
			lState != eStalkerState_CrawlThroughVent &&
			lState != eStalkerState_SitAndWait &&
			lState != eStalkerState_ExamineRabbit &&
			lState != eStalkerState_Null &&
			lState != eStalkerState_MapTransfer &&
			lState != eStalkerState_EvaluateObstacle &&
			lState != eStalkerState_Roar &&
			lState != eStalkerState_Rage &&
			lState != eStalkerState_Hurt &&
			lState != eStalkerState_Stunned &&
			lState != eStalkerState_Retreat &&
			lState != eStalkerState_KillPlayer)
		{
			mBaseObj.RevealPlayerPos();
		}
		
		if (bHiding == false)
		{
			mbPlayerHidWhileSpotted = false;
		}
		
		mbPlayerIsHiding = bHiding;
	}
	
	//------------------------------------------------------------
	
	void UpdatePlayerLeftSaveRoom(float afDeltaTime)
	{
		if (mfPlayerLeftSaveRoomCount <= 0.f) return;
		
		mfPlayerLeftSaveRoomCount -= afDeltaTime;
		if (mfPlayerLeftSaveRoomCount <= 0.f)
		{
			if (mbWasInActiveModeWhenPlayerEnteredSaveRoom && 
				mbPlayerIsInSaveRoom == false &&
				mbHurt_RecentlyHurt == false)
			{
				mbWasInActiveModeWhenPlayerEnteredSaveRoom = false;
				ChangeMode(eStalkerMode_Active, true);
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateSoundCounter(float afTimeStep)
	{		
		mfSoundCounter -= afTimeStep;
		if (mfSoundCounter < 0.f) 
			mfSoundCounter = 0.f;
			
		mfInvestigateSound_PlayerSoundDecreaseCount -= afTimeStep;
		if (mfInvestigateSound_PlayerSoundDecreaseCount <= 0.f)
		{
			if (mlInvestigateSound_PlayerSoundCount > 0)
				--mlInvestigateSound_PlayerSoundCount;
			
			mfInvestigateSound_PlayerSoundDecreaseCount = cMath_RandRectf(10.f, 15.f);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateFlashlightDetection(float afTimeStep)
	{
		///////////////////
		// Gobo count
		if (mfGoboCount > 0.f)
		{
			if (mfGoboCount > 0.2f && mfHitByFlashlightCount <= 0.f)
			{
				mBaseObj.BroadcastMessage(eCustomEntityMessage_DetectFlashlightGobo, null, mvGoboPos, 0);
				mfGoboCount = 0.f;
			}
			
			mfGoboCount -= 0.5f * afTimeStep;
			mfGoboCount = cMath_Clamp(mfGoboCount, 0.f, 0.5f);
		}
		
		///////////////////
		// Flashlight count
		if (mfHitByFlashlightCount > 0.f)
		{
			mfHitByFlashlightCount -= afTimeStep;
			mfHitByFlashlightCount = cMath_Clamp(mfHitByFlashlightCount, 0.f, 2.f);
		}
	}
	
	//------------------------------------------------------------
		
	void UpdateObstacles(float afTimeStep)
	{
		if (mbHidden) return;
		if (mlMapTransferData_SetupStage != -1) return;
		
		/////////////////////
		// Stuck counter
		float fStuck = mpMover.GetStuckCounter();
		if (fStuck > 0.85f)
		{
			mBaseObj.BroadcastMessage(eCustomEntityMessage_StuckCounterHigh, null, mBaseObj.GetPosition(), 0);
			mpMover.ResetStuckCounter();
		}
		
		/////////////////////
		// Open door avoidance
		if (mpPathfinder.IsMoving() && 
			mpStateMachine.GetCurrentState() != eStalkerState_Hunt &&
			mpStateMachine.GetCurrentState() != eStalkerState_BossFight_Default &&
			mpStateMachine.GetCurrentState() != eStalkerState_BossFight_Pace &&
			mpStateMachine.GetCurrentState() != eStalkerState_BossFight_Retreat &&
			mpStateMachine.GetCurrentState() != eStalkerState_BossFight_Jump &&
			mBaseObj.Timer_Exists("Timer_TryingToOpenDoor") == false)
		{
			cVector3f vStart = mBaseObj.GetCharBody().GetPosition();
			cVector3f vDir = cMath_Vector3Normalize(mpPathfinder.GetNextGoalPos() - vStart);
			
			mBaseObj.GetClosestEntity("AvoidOpenDoor_RaycastResult", vStart, vDir, 1.5f, -1.f, false);
		}
		
		/////////////////////
		// Path blockers
		UpdateObstacles_RemovePathBlockers(afTimeStep);
		UpdateObstacles_CheckForPathBlockers(afTimeStep);
	}
	
	//------------------------------------------------------------
	
	void UpdateObstacles_RemovePathBlockers(float afTimeStep)
	{
		/////////////////////
		// Setup vars
		cVector3f vStalkerPos = mBaseObj.GetPosition();
		
		/////////////////////
		// Iterate obstacles
		for (uint i = 0; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];
			iPhysicsBody@ pBody = cLux_ID_Body(pData.m_idBody);
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			
			bool bRemove = false;
			bool bIsTrap = pProp !is null && 
						   pProp.GetClassName() == "cScrPropTrap";
						   				
			/////////////////////
			// Blocker gone, or inactive (unless trap or manual removal)?
			if (pBody is null || 
				 (pBody.IsActive() == false && bIsTrap == false && pData.mbManualRemovalOnly == false))
			{
				bRemove = true;
			}
			else
			{
				/////////////////////
				// Manual removal only?
				if (pData.mbManualRemovalOnly)
					continue;
				
				/////////////////////
				// Should be ignored?
				if (mvEvaluateObstacle_IgnoredBlockers.find(pBody.GetID()) != -1)
					continue;
				
				/////////////////////
				// Enough time has passed?
				float fPrevTimeUntilRemoval = pData.mfTimeUntilRemoval;
				pData.mfTimeUntilRemoval -= afTimeStep;
				
				if (pData.mfTimeUntilRemoval <= 0.f)
				{
					bRemove = true;
				}
				
				/////////////////////
				// Special case for physical blockers during boss fight
				if (mbBossFight_Active && 
					Blackboard_GetIsBodyDamageArea(pBody) == false)
				{
					float fDistToProp = (pBody.GetWorldPosition() - vStalkerPos).SqrLength();
					if (fDistToProp > 15.f * 15.f)
						bRemove = true;
				}
					
				/////////////////////
				// Open door and now it's closed?
				if (pData.mbIsOpenDoor && 
					pData.mfTimeUntilRemoval % 2.f > 1.f && 
					fPrevTimeUntilRemoval % 2 < 1.f)
				{
					if (pProp !is null && 
						SwingDoor_GetOpenAmount(pProp.GetName()) < gfStalker_SwingDoorObstacleOpenAmount)
					{
						bRemove = true;
					}						
				}
			}				
				
			/////////////////////
			// Remove?
			if (bRemove)
			{						
				EvaluateObstacle_RemovePathBlocker(pData.m_idBody, false);
				--i;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateObstacles_CheckForPathBlockers(float afTimeStep)
	{
		///////////////////
		// State check		
		int lCurrentState = mpStateMachine.GetCurrentState();
		if (lCurrentState == eStalkerState_EvaluateObstacle ||
			lCurrentState == eStalkerState_BlockedByProp ||
			lCurrentState == eStalkerState_Blocked ||
			lCurrentState == eStalkerState_Emerge ||
			lCurrentState == eStalkerState_Alert ||
			lCurrentState == eStalkerState_AttackClose ||
			lCurrentState == eStalkerState_PostHunt ||
			lCurrentState == eStalkerState_Stunned ||
			lCurrentState == eStalkerState_BreakDoor ||
			lCurrentState == eStalkerState_WaitInHole ||
			lCurrentState == eStalkerState_MoveBetweenHoles ||
			lCurrentState == eStalkerState_Hurt ||
			lCurrentState == eStalkerState_KillPlayer ||
			lCurrentState == eStalkerState_ThrowPlayer ||
			lCurrentState == eStalkerState_CrawlThroughVent ||
			lCurrentState == eStalkerState_Rage ||
			lCurrentState == eStalkerState_Retreat ||
			lCurrentState == eStalkerState_Roar ||
			lCurrentState == eStalkerState_SitAndWait ||
			lCurrentState == eStalkerState_BossFight_Jump ||
			lCurrentState == eStalkerState_BossFight_Retreat ||
			lCurrentState == eStalkerState_Null ||
			lCurrentState == eStalkerState_MapTransfer)
		{
			return;
		}
		
		if (mbCutsceneAnimation_Active) return;
		if (mbRetreat_Active) return;
		if (mbPlayQuickTurnAnim) return;
		if (mbBossFight_Active && lCurrentState != BossFight_GetCurrentState()) return;
			
		bool bDamageAreaCheckOnly = lCurrentState == eStalkerState_PreHunt ||
									lCurrentState == eStalkerState_Hunt;
			
		///////////////////
		// Get bodies ahead!
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cBoundingVolume@ pBounds = pCharBody.GetCurrentBody().GetBoundingVolume();
		
		float fBoxWidth = 3.f;
		float fBoxHeight = 0.5f;
		
		cVector3f vFwdOffset = pCharBody.GetForward() * (pCharBody.GetSize().x / 2.f) + pCharBody.GetForward() * (fBoxWidth / 2.f);
		cVector3f vBoxCenter = pCharBody.GetFeetPosition() + vFwdOffset + cVector3f(0.f, fBoxHeight / 2.f, 0.f);
		cVector3f vBoxMin = vBoxCenter - cVector3f(fBoxWidth / 2.f, fBoxHeight / 2.f, fBoxWidth / 2.f);
		cVector3f vBoxMax = vBoxCenter + cVector3f(fBoxWidth / 2.f, fBoxHeight / 2.f, fBoxWidth / 2.f);
			
		array<iPhysicsBody@> vBodies;
		mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(vBoxMin, vBoxMax, false, false, vBodies);
						
		///////////////////
		// Iterate potential blockers!
		for (uint i = 0; i < vBodies.size(); ++i)
		{
			////////////////
			// Setup vars
			iPhysicsBody@ pBody = vBodies[i];
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			cBoundingVolume@ pBodyBounds = pBody.GetBoundingVolume();
						
			///////////////
			// Is non-active prop?
			if (pProp !is null && pProp.IsActive() == false)
			{
				continue;
			}
			
			////////////////
			// Player path blocker? Handled differently!
			if (Blackboard_GetIsBodyPlayerPathBlocker(pBody))
			{
				continue;
			}
			
			////////////////
			// Should be ignored?
			if (mvEvaluateObstacle_IgnoredBlockers.find(pBody.GetID()) != -1)
			{
				continue;
			}
			
			if (pProp !is null && 
				mvEvaluateObstacle_IgnoredProps.find(pProp.GetID()) != -1)
			{
				continue;
			}
				
			if (pProp !is null && 
				mbBossFight_Active && 
				mvBossFight_BridgeEntityIds.find(pProp.GetID()) != -1)
			{
				continue;
			}
			
			////////////////
			// Is static breakable? Handled differently!
			if (pProp !is null &&
				pBodyBounds !is null &&
				pProp.GetIsBreakable() &&
				(pBody.GetMass() <= 0.f || pProp.GetStaticPhysics()))
			{								
				if (cMath_CheckAABBIntersection(pBounds.GetMin(), pBounds.GetMax(), pBodyBounds.GetMin(), pBodyBounds.GetMax()))
				{
					if (GetIsRunningQuickly())
					{
						BreakPropWhileRunning(pProp);
					}
					else
					{
						SetPreBlockedState(lCurrentState);
						m_idBlockedByProp_Entity = pProp.GetID();
						mpStateMachine.ChangeState(eStalkerState_BlockedByProp);
					}
					
					return;
				}
				
				continue;
			}
			
			////////////////
			// Already evaluated?
			if (EvaluateObstacle_GetPathBlockerExists(pBody.GetID()))
			{
				continue;
			}
				
			tString sClassName = pProp is null ? "" : pProp.GetClassName();
			bool bIsTrap = sClassName == "cScrPropTrap";
			bool bIsDamageArea = Blackboard_GetIsBodyDamageArea(pBody) && !bIsTrap;
			
			/////////////////
			// Skip non-damage areas?
			if (bDamageAreaCheckOnly && bIsDamageArea == false)
			{
				continue;
			}
			
			/////////////////
			// Skip trap if not seen by player, or detected player
			if (bIsTrap && 
				(mbIsOnScreen == false ||
				 (mAlertState == eStalkerAlertState_Detected)))
			{
				continue;
			}
			
			/////////////////
			// Skip triggered traps
			if (bIsTrap && Trap_GetCanBlockPath(pProp.GetName(), pBody.GetID())==false)
			{
				continue;
			}
			
			/////////////////
			// Can the body block the path?
			if (!bIsTrap && Blackboard_GetCanBodyBlockPath(pBody) == false)
			{
				continue;
			}
							
			/////////////////
			// Don't get blocked by flares
			// TODO: Fix nicer
			if (pProp !is null && pProp.GetVarBool("IsFlareBlocker"))
			{
				continue;
			}
			
			/////////////////
			// Just run through it?
			if (bIsTrap == false && 
				bIsDamageArea == false &&
				pProp !is null &&
				pProp.GetIsBreakable() &&
				(mBaseObj.GetPlayerPos() - mBaseObj.GetPosition()).SqrLength() < 20.f * 20.f &&
				GetIsRunningQuickly())
			{
				continue;
			}
			
			/////////////////
			// Ignore if in boss fight and it's a physical blocker!
			if (mbBossFight_Active)
			{
				if (bIsDamageArea == false)
				{
					if (cMath_CheckAABBIntersection(pBounds.GetMin(), pBounds.GetMax(), pBodyBounds.GetMin(), pBodyBounds.GetMax()))
					{
						if (GetIsRunningQuickly())
						{
							BreakPropWhileRunning(pProp);
						}
						else
						{
							SetPreBlockedState(lCurrentState);
							m_idBlockedByProp_Entity = pProp.GetID();
							mpStateMachine.ChangeState(eStalkerState_BlockedByProp);
						}
						
						return;
					}
					
					continue;
				}
				
				if (bIsDamageArea && 
					mBaseObj.Timer_Exists(gsStalker_BossFightIgnoreEnvironmentalDamageTimer))
				{
					continue;
				}
			}
				
			/////////////////
			// Body in LoS?
			// (Only do this for physical blockers!)
			if (bIsTrap == false && bIsDamageArea == false)
			{
				float fDist;
				cVector3f vNrm;
				cVector3f vDelta = (pBody.GetWorldPosition() - mBaseObj.GetPosition());

				if (cLux_GetClosestBody(mBaseObj.GetPosition(), vDelta, vDelta.Length(), fDist, vNrm) !is pBody)
					continue;
			}

			/////////////////
			// Evaluate it!
			m_idEvaluateObstacle_BlockerBodyCandidate = pBody.GetID();
			mpStateMachine.ChangeState(eStalkerState_EvaluateObstacle);
			break;
		}
	}
	
	//------------------------------------------------------------
	
	void AvoidOpenDoor_RaycastResult(bool abSuccesful, float afDistance, iPhysicsBody@ apBody, iLuxEntity@ apEntity)
	{
		/////////////////////
		// Is prop door?
		cLuxProp@ pProp = cLux_ToProp(apEntity);
		tString sPropName = pProp !is null ? pProp.GetName() : "";
			
		if (apBody is null) return;
		if (pProp is null) return;
		if (pProp.GetIsDoor() == false) return;
		
		/////////////////////
		// Can we add the door as a path blocker?
		tID idDoor = SwingDoor_GetDoorBodyID(sPropName);
		
		if (EvaluateObstacle_GetPathBlockerExists(idDoor)) return;		
		if (SwingDoor_GetOpenAmount(sPropName) < gfStalker_SwingDoorObstacleOpenAmount) return;
		
		/////////////////////
		// Add it
		EvaluateObstacle_AddPathBlocker(idDoor, true);
		
		/////////////////////
		// Update path!
		if (mpPathfinder.IsMoving())
			mpPathfinder.MoveTo(mpPathfinder.GetGoalPos(), 1.f, false);
	}
	
	//------------------------------------------------------------
	
	void UpdateQuickTurn(float afTimeStep)
	{		
		////////////////////
		// Setup
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		cLuxMap@ pMap = mBaseObj.GetMap();
		iPhysicsWorld@ pPhysicsWorld = pMap.GetPhysicsWorld();
		
		if (pCharBody is null) return;
		if (pMeshEnt is null) return;
		if (pPhysicsWorld is null) return;
		if (pPhysicsWorld is null) return;
		if (pCharBody.IsOnGround() == false) return;
		
		////////////////////
		// Play turn around anim?
		if (mbPlayQuickTurnAnim == false && 
			mbHidden == false &&
			mpPathfinder.IsMoving())
		{
			////////////////////
			// Long enough since last?
			if (mlQuickTurnTimeStamp > 0 && 
				pMap.GetElapsedTime(mlQuickTurnTimeStamp) < gfStalker_MinTimeBetweenQuickTurns)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
			
			////////////////////
			// Valid goal?
			mfQuickTurnGoalYaw = mpMover.GetTurnGoalAngles().y;
			if (cMath_Abs(mfQuickTurnGoalYaw) == 0.f)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
			
			////////////////////
			// Valid angle?
			bool bValidAngle = false;
			float fMoveSpeed = pCharBody.GetMoveSpeed(eCharDir_Forward);
			bool bIsRunning = mpMover.GetSpeedState() == eStalkerSpeed_Run && fMoveSpeed > 1.f;
			float fAngleDist = cMath_GetAngleDistanceRad(pCharBody.GetYaw(), mfQuickTurnGoalYaw);
			float fAbsAngleDist = cMath_Abs(fAngleDist);			
			
			if (bIsRunning == false &&
				fAbsAngleDist > gfStalker_PlayTurnSideAnimMinAngle && 
				fAbsAngleDist < gfStalker_PlayTurnSideAnimMaxAngle)
			{
				bValidAngle = true;
				mQuickTurnAnimType = fAngleDist > 0.f ? eStalkerQuickTurnType_Left : eStalkerQuickTurnType_Right;
			}
			else if (fAbsAngleDist >= gfStalker_PlayTurnAroundAnimMinAngle)
			{
				bValidAngle = true;
				mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
			}
			
			if (bValidAngle == false)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
			
			////////////////////
			// Moving too fast?
			if (fMoveSpeed > gfStalker_QuickTurnMaxFwdSpeed && 
				mbHeadAdjustment_HeadColliding == false)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
			
			////////////////////
			// Too small angle when walking?
			if (bIsRunning == false &&
				fMoveSpeed > 0.f &&
				 (mQuickTurnAnimType == eStalkerQuickTurnType_Left ||
				  mQuickTurnAnimType == eStalkerQuickTurnType_Right))
			{
				if (fAbsAngleDist < gfStalker_PlayTurnSideAnimWalkMinAngle)
				{
					mfQuickTurnCount = 0.f;
					return;
				}
			}
			
			////////////////////
			// Tried to turn around for long enough?
			mfQuickTurnCount += afTimeStep;
			if (mfQuickTurnCount < 0.05f)
			{
				return;
			}
			
			////////////////////
			// Quick turn not allowed?
			if (mBaseObj.Timer_Exists("Timer_QuickTurnDisallowed"))
			{
				return;
			}
			
			////////////////////
			// Play anim
			PlayQuickTurnAnim();
		}
		
		////////////////////
		// Turn around anim playing?
		if (mbPlayQuickTurnAnim)
		{
			////////////////////
			// Safety check!
			cAnimationState@ pCurrentAnim = mBaseObj.GetCurrentAnimationState();
			if (pCurrentAnim !is null && pCurrentAnim.GetName() != msQuickTurnAnim)
			{
				ResetQuickTurn();
				return;
			}
			
			////////////////////
			// Stop movement
			pCharBody.StopMovement();
			mpMover.StopTurning();
			
			////////////////////
			// Get anim
			cAnimationState@ pAnim = pMeshEnt.GetAnimationStateFromName(msQuickTurnAnim);
			if (pAnim is null)
			{
				ResetQuickTurn();
				return;
			}
			
			////////////////////
			// Anim playing?
			else if (pAnim.IsActive() && pAnim.IsOver() == false)
			{
				/////////////////
				// Align yaw
				float fT = cMath_Min(pAnim.GetRelativeTimePosition() + 0.1f, 1.f);
				
				float fYawOffset = 0.f;				
				switch (mQuickTurnAnimType)
				{
					case eStalkerQuickTurnType_TurnAround: 		fYawOffset = cMath_Pi; 			break;
					case eStalkerQuickTurnType_Left: 			fYawOffset = cMath_PiDiv2; 		break;
					case eStalkerQuickTurnType_Right: 			fYawOffset = -cMath_PiDiv2;		break;
				}				
				
				float fYawCorrection = cMath_GetAngleDistanceRad(mfQuickTurnStartYaw + fYawOffset, mfQuickTurnGoalYaw);
				float fNewYaw = mfQuickTurnStartYaw + fYawCorrection * fT;
				
				pCharBody.SetYaw(fNewYaw);
				pCharBody.UpdateEntity();	
			}
			
			////////////////////
			// Anim over?
			else if (pAnim.IsOver())
			{			
				int lNewState = mlQuickTurnDoneState;
				ResetQuickTurn();
				
				////////////////////
				// Orient char body!
				pCharBody.SetYaw(mfQuickTurnGoalYaw);
				pCharBody.UpdateEntity();
				
				////////////////////
				// Play idle anim
				mpMover.PlayAnimation(gsStalkerAnim_Idle, 0.f, false, false, "");
				mpMover.SetUseMoveStateAnimations(true);
				mpMover.StopTurning();
										
				////////////////////
				// Update path
				if (mpPathfinder.IsMoving())
				{
					mpPathfinder.MoveTo(mpPathfinder.GetGoalPos(), 1.f, false);
				}
				
				////////////////////
				// Check player LoS
				// (Since player detection isn't updated while anim is playing)
				mBaseObj.Timer_Add("Timer_QuickTurnEndCheckPlayerLoS", 0.05f, "OnTimer_QuickTurnEndCheckPlayerLoS", false, false);
				
				//////////////////
				// State change?
				if (lNewState != -1)
				{
					mpStateMachine.ChangeState(eStalkerState(lNewState));
				}
				
				//////////////////
				// Message
				mBaseObj.BroadcastMessage(eCustomEntityMessage_QuickTurnOver, null, cVector3f(0.f), lNewState != -1 ? 1 : 0);
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_QuickTurnEndCheckPlayerLoS(uint64 alId)
	{
		if (GetPlayerIsInLoS(true, false)) 
		{
			mBaseObj.RevealPlayerPos();
		}
	}
	
	//------------------------------------------------------------
	
	void PlayQuickTurnAnim()
	{
		cLuxMap@ pMap = mBaseObj.GetMap();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		if (pMap is null) return;
		if (pCharBody is null) return;
		
		////////////////////
		// Setup anim
		mbPlayQuickTurnAnim = true;
		mfQuickTurnCount = 0.f;
		mlQuickTurnTimeStamp = pMap.GetTimeStamp();
		mfQuickTurnStartYaw = pCharBody.GetYaw();
		msQuickTurnAnim = GetQuickTurnAnim(mQuickTurnAnimType);
						
		mpMover.PlayAnimation(msQuickTurnAnim, 0.3f, false, false, "");
		mpMover.SetUseMoveStateAnimations(false);
			
		////////////////////
		// Disable player detection
		mBaseObj.SetUpdatePlayerDetection(false);
	}
	
	//------------------------------------------------------------
	
	tString GetQuickTurnAnim(eStalkerQuickTurnType aType)
	{
		int lId = int(aType);
		
		tString[] vNormalAnims = { gsStalkerAnim_TurnAround, gsStalkerAnim_Turn_90_Left, gsStalkerAnim_Turn_90_Right };
		tString[] vFastAnims = { gsStalkerAnim_TurnAroundFast, gsStalkerAnim_Turn_90_Fast_Left, gsStalkerAnim_Turn_90_Fast_Right };
		
		bool bFastTurn = mbHurt_RecentlyHurt ||
						 mbRetreat_Active ||
						 mAlertState == eStalkerAlertState_Detected;
		
		return bFastTurn ? vFastAnims[lId] : vNormalAnims[lId];
	}
	
	//------------------------------------------------------------
	
	void ResetQuickTurn()
	{
		mlQuickTurnDoneState = -1;
		mbPlayQuickTurnAnim = false;
		mBaseObj.SetUpdatePlayerDetection(true);
	}
	
	//------------------------------------------------------------
	
	void UpdateHeadAdjustment(float afTimeStep)
	{
		//////////////////
		// Setup vars
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		cBoneState@ pHeadBone = pMeshEnt !is null ? pMeshEnt.GetBoneStateFromName("j_Head") : null;
		cBoneState@ pNeckBone = pMeshEnt !is null ? pMeshEnt.GetBoneStateFromName("j_Neck_1") : null;
		cAnimationState@ pCurrentAnim = mBaseObj.GetCurrentAnimationState();
		tString sCurrentAnim = pCurrentAnim !is null ? pCurrentAnim.GetName() : "";
		
		if (pPhysicsWorld is null) return;
		if (pCharBody is null) return;
		if (pMeshEnt is null) return;
		if (pHeadBone is null) return;
		if (pNeckBone is null) return;	
		
		bool bAllowNeckAdjustment = true;
		cMatrixf mtxOffsetGoal = cMatrixf_Identity;
		cMatrixf mtxNeckStart = pNeckBone.GetWorldMatrix();
		cVector3f vLocalHeadPos = cMath_MatrixMul(cMath_MatrixInverse(mtxNeckStart), pHeadBone.GetWorldPosition());
		cVector3f vHeadOffset = cVector3f(0.f);
		
		/////////////////
		// Adjustment allowed?		
		if (mbCutsceneAnimation_Active)
		{
			bAllowNeckAdjustment = false;
		}
		else if (mbHidden)
		{
			bAllowNeckAdjustment = false;
		}
		else if (mpStateMachine.GetCurrentState() == eStalkerState_Hurt)
		{
			bAllowNeckAdjustment = false;	
		}
		else
		{
			for (int i = 0; i < gsStalker_NoHeadAdjustmentAnims.length(); ++i)
			{
				if (sCurrentAnim == gsStalker_NoHeadAdjustmentAnims[i])
				{
					bAllowNeckAdjustment = false;
					break;
				}
			}
		}
		
		/////////////////
		// Adjust neck pos/rot until there's no collision
		if (bAllowNeckAdjustment)
		{			
			cMatrixf mtxHeadTranspose = pHeadBone.GetWorldMatrix().GetTranspose();
			vHeadOffset = mtxHeadTranspose.GetRight() * 15.f;
			
			for (int i = 0; i < 6; ++i)
			{				
				/////////////////
				// Check collision
				// (Only care about colliding with static geo or doors)
				cVector3f vPush;
				cMatrixf mtxNeck = cMath_MatrixMul(mtxNeckStart, mtxOffsetGoal);
				cVector3f vHeadPos = cMath_MatrixMul(mtxNeck, vLocalHeadPos) + vHeadOffset;
			
				if (CheckHeadCollision(vHeadPos, true))
				{
					/////////////////
					// Calculate offset
					cMatrixf mtxAdd = cMath_MatrixRotateXYZ(gvStalker_HeadAdjustmentRotAdd);
					mtxAdd.SetTranslation(gvStalker_HeadAdjustmentPosAdd);
					
					mtxOffsetGoal = cMath_MatrixMul(mtxAdd, mtxOffsetGoal);
				}
				else 
				{
					break;
				}
			}
		}
		
		/////////////////
		// Apply offset		
		float fSpeed = mtxOffsetGoal == cMatrixf_Identity ? 2.5f : 5.f;
		mtxHeadAdjustment_Offset = cMath_MatrixSlerp(afTimeStep * fSpeed, mtxHeadAdjustment_Offset, mtxOffsetGoal, true);
		
		cMatrixf mtxNew = cMath_MatrixMul(pNeckBone.GetWorldMatrix(), mtxHeadAdjustment_Offset);
		pNeckBone.SetWorldMatrix(mtxNew);
		
		/////////////////
		// Update flag
		mbHeadAdjustment_HeadColliding = mtxOffsetGoal != cMatrixf_Identity;
		
		/////////////////
		// Turn to another direction?
		{	
			int lCurrentState = mpStateMachine.GetCurrentState();
			if (lCurrentState == eStalkerState_AttackClose ||
				lCurrentState == eStalkerState_Stunned ||
				lCurrentState == eStalkerState_Blocked ||
				lCurrentState == eStalkerState_BlockedByProp ||
				lCurrentState == eStalkerState_BreakDoor ||
				lCurrentState == eStalkerState_EvaluateObstacle ||
				lCurrentState == eStalkerState_Roar ||
				lCurrentState == eStalkerState_ThrowPlayer ||
				lCurrentState == eStalkerState_CrawlThroughVent ||
				lCurrentState == eStalkerState_Null ||
				lCurrentState == eStalkerState_MapTransfer ||
				lCurrentState == eStalkerState_Emerge)
			{
				return;
			}
			
			if (bAllowNeckAdjustment == false)
				return;
				
			if (mbHeadAdjustment_HeadColliding == false)
				return;
				
			if (mAlertState == eStalkerAlertState_Detected)
				return;
			
			if (mpMover.GetCustomAnimActive())
				return;
				
			if (mpPathfinder.IsMoving())
				return;
			
			if (pCharBody.GetMoveSpeed(eCharDir_Forward) > 0.01f)
				return; 
			
			tString sTurnCooldownTimer = "Timer_HeadCollideTurnCooldown";
			if (mBaseObj.Timer_Exists(sTurnCooldownTimer))
				return;
			
			mBaseObj.Timer_Add(sTurnCooldownTimer, 4.f);
				
			cVector3f vPush;
			cVector3f vHeadPos = cMath_MatrixMul(mtxNeckStart, vLocalHeadPos) + vHeadOffset;
			cVector3f vBodyToHead = vHeadPos - pCharBody.GetPosition();
			cVector3f[] vDirOffsets = { cMath_MatrixMul(cMath_MatrixRotateY(cMath_PiDiv2), vBodyToHead), 
										cMath_MatrixMul(cMath_MatrixRotateY(cMath_Pi), vBodyToHead),
										cMath_MatrixMul(cMath_MatrixRotateY(cMath_Pi + cMath_PiDiv2), vBodyToHead) };
				
			for (int i = 0; i < vDirOffsets.length(); ++i)
			{
				cVector3f vDirOffset = vDirOffsets[i];
				cVector3f vNewHeadPos = pCharBody.GetPosition() + vDirOffset;
					
				if (CheckHeadCollision(vNewHeadPos, true) == false)
				{
					float fAngle = cMath_GetAngleFromPoints3D(0, vDirOffset).y;
					float fAngleDiff = cMath_GetAngleDistanceRad(pCharBody.GetYaw(), fAngle);
					float fAbsAngleDiff = cMath_Abs(fAngleDiff);
						
					mfQuickTurnGoalYaw = fAngle;
						
					if (fAbsAngleDiff >= gfStalker_PlayTurnAroundAnimMinAngle)
						mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
					else
						mQuickTurnAnimType = fAngleDiff > 0.f ? eStalkerQuickTurnType_Left : eStalkerQuickTurnType_Right;
						
					PlayQuickTurnAnim();
					break;
				}
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdatePlayerPrediction(float afTimeStep)
	{
		///////////////////
		// Check interval
		mfPlayerPrediction_UpdateCount -= afTimeStep;
		if (mfPlayerPrediction_UpdateCount <= 0.f)
		{
			mfPlayerPrediction_UpdateCount = gfStalker_PlayerPredictionIntervalTime;
			
			///////////////////
			// Keep track of specified num of positions
			if (mvPlayerPrediction_VelocityBuffer.size() == glStalker_PlayerPredictionVelocityBufferSize)
			{
				mvPlayerPrediction_VelocityBuffer.pop_front();
			}
			
			mvPlayerPrediction_VelocityBuffer.push_back(cLux_GetPlayer().GetCharacterBody().GetVelocity(afTimeStep));
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateCheckLos(float afTimeStep)
	{
		mfPlayerLosCounter -= afTimeStep;
		if (mfPlayerLosCounter >= 0.f) return;
		mfPlayerLosCounter = cMath_RandRectf(0.3f, 0.6f);
				
		mBaseObj.GetPlayerIsInLineOfSight("OnLosResult");
		
		if (mbPlayerIsInLos == false)
			mfTimeSincePlayerInLoS += afTimeStep;
		else
			mfTimeSincePlayerInLoS = 0.f;
	}
	
	//------------------------------------------------------------
	
	void OnLosResult(bool abSuccessful)
	{
		mbPlayerIsInLos = abSuccessful && GetPlayerIsInLoS(true, true); 
	}
	
	//------------------------------------------------------------
	
	void UpdateProximityDetection(float afTimeStep)
	{
		////////////////////
		// Time
		mfProximityDetectionTimer -= afTimeStep;
		if (mfProximityDetectionTimer > 0.0f) return;
		
		mfProximityDetectionTimer = cMath_RandRectf(0.1f, 0.2f);
		
		////////////////////
		// Setup vars
		bool bPlayerDetected = false;	
		int lCurrentState = mpStateMachine.GetCurrentState();
		int lPlayerState = cLux_GetPlayer().GetCurrentStateId();
		
		////////////////////
		// Checks
		if (mbHidden) return;
		if (mbProximityDetectionActive == false) return;
		if (GetSensesActive() == false) return;
		if (GetIsAggressive()) return;
		if (lCurrentState == eStalkerState_KillPlayer) return;
		if (lCurrentState == eStalkerState_Alert) return;
		if (mbBossFight_Active) return;
		if (lPlayerState == ePlayerState_Custom_Thrown) return;
		
		////////////////////
		// Player in front of object blocking us?
		if (mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerFeetPos()))
		{
			if (lCurrentState == eStalkerState_BreakDoor ||
				lCurrentState == eStalkerState_BlockedByProp)
			{
				return;
			}
		}
		
		////////////////////
		// Player hiding?
		if (mbPlayerIsHiding)
		{
			bPlayerDetected = mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Touching);
		}
		
		////////////////////
		// Player not hiding
		else
		{
			bPlayerDetected = mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Close) ||
							  mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Touching);
		}
		
		////////////////////
		// LoS check
		if (bPlayerDetected && 
			cLux_CheckLineOfSight(mBaseObj.GetPosition(), mBaseObj.GetPlayerHeadPos(), false, false, null) == false)
		{
			bPlayerDetected = false;
		}
		
		////////////////////
		// Throw player?
		if (bPlayerDetected && 
			lPlayerState != ePlayerState_Ladder)
		{
			////////////////////
			// Inside a transfer area? Kill player instead!
			for (int i = 0; i < mvMapTransferData_TransferAreaIds.size(); ++i)
			{
				cLuxArea@ pArea = cLux_ID_Area(mvMapTransferData_TransferAreaIds[i]);
				if (pArea is null) continue;
				
				if (pArea.CheckCharacterCollision(mBaseObj.GetCharBody(), mBaseObj.GetMap()))
				{
					if (cLux_GetGodModeActivated() == false)
						mpStateMachine.ChangeState(eStalkerState_KillPlayer);
					
					return;
				}
			}
			
			mpStateMachine.ChangeState(eStalkerState_ThrowPlayer);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Throw player through proximity detection in state " + StateToString(lCurrentState));
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateWalkAnims(float afTimeStep)
	{	
		///////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pCharBody is null) return;
		
		///////////////////
		// Allow upright walk?
		if (pCharBody.GetMoveSpeed(eCharDir_Forward) <= 0.f &&
			pCharBody.GetMovedLastUpdate())
		{
			if (mbAllowUprightWalk)
				mbAllowUprightWalk = false;
			else
				mbAllowUprightWalk = cMath_RandRectl(0, 2) == 1;
			
			mfAllowUprightWalkCount = cMath_RandRectf(4.f, 10.f);			
		}
		else if (mbAllowUprightWalk  &&
				pCharBody.GetMoveSpeed(eCharDir_Forward) > 0.5f)
		{
			mfAllowUprightWalkCount -= afTimeStep;
			if (mfAllowUprightWalkCount <= 0.f)
			{
				mbAllowUprightWalk = false;
				mfAllowUprightWalkCount = cMath_RandRectf(4.f, 10.f);
			}
		}
		
		float fGroundAngle = cMath_ToDeg(cMath_Vector3Angle(pCharBody.GetLastGroundNormal(), cVector3f_Up));
		if (fGroundAngle > 15.f)
			mbAllowUprightWalk = true;
		
		///////////////////
		// Timers		
		mfUpdateWalkAnimCount -= afTimeStep;		
		if (mfUpdateWalkAnimCount > 0.f)
			return;
		
		///////////////////
		// In cramped space?
		if (GetIsInCrampedSpace())
		{
			mbUseCrampedAnims = true;
			mfUpdateWalkAnimCount = 1.f;
		}
		else
		{
			mbUseCrampedAnims = false;
			mfUpdateWalkAnimCount = cMath_RandRectf(0.1f, 0.2f);
		}

		///////////////////
		// Switch walk anim!
		bool bPrevWalkUpright = mbShouldWalkUpright;
		mbShouldWalkUpright = mbAllowUprightWalk && 
							  mpMover.GetSpeedState() == eStalkerSpeed_Walk &&
							  pCharBody.GetMoveSpeed(eCharDir_Forward) > 1.f;	
		
		if (mbShouldWalkUpright != bPrevWalkUpright)
		{
			SetLocomotionAnimState(mAlertState);
			mpMover.SetUseTurnAnimations(!mbShouldWalkUpright);
			return;
		}
		
		if (mbUseCrampedAnims)
		{
			SwitchLocomotionAnim(eStalkerLocomotionAnimType_Walk, msWalkCrampedAnim, msWalkAnim);
		}
		else
		{			
			SwitchLocomotionAnim(eStalkerLocomotionAnimType_Walk, msWalkAnim, msWalkCrampedAnim);
		}	
	}
	
	//------------------------------------------------------------
	
	void UpdateNoCollisionBodies(float afTimeStep)
	{
		if (mbHidden) return;
		
		///////////////////
		// Check interval
		mfNoCollisionBodiesUpdateCount -= afTimeStep;
		if (mfNoCollisionBodiesUpdateCount > 0.f)
			return;
			
		mfNoCollisionBodiesUpdateCount = 0.1f;
		
		///////////////////
		// Setup box
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		float fBoxSize = pCharBody.GetSize().x * 1.25f;
		float fBoxHeight = pCharBody.GetSize().y;
		
		cVector3f vBoxCenter = pCharBody.GetFeetPosition() + cVector3f(0.f, fBoxHeight / 2.f, 0.f);
		cVector3f vBoxMin = vBoxCenter - cVector3f(fBoxSize / 2.f, fBoxHeight / 2.f, fBoxSize / 2.f);
		cVector3f vBoxMax = vBoxCenter + cVector3f(fBoxSize / 2.f, fBoxHeight / 2.f, fBoxSize / 2.f);
		
		///////////////////
		// Get bodies in box
		array<iPhysicsBody@> vBodies;
		mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(vBoxMin, vBoxMax, true, false, vBodies);
				
		for (uint i = 0; i < vBodies.size(); ++i)
		{
			iPhysicsBody@ pBody = vBodies[i];
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			
			///////////////////
			// Filter out certain bodies
			if (pProp is null) continue;
			if (pBody is null) continue;
			if (pProp.IsActive() == false) continue;
			if (pProp.GetStaticPhysics()) continue;
			if (pProp.GetIsDoor()) continue;
			if (pProp.IsInteractedWith()) continue;
			if (pBody.GetThrownByPlayer()) continue;
			if (pBody.IsCharacter()) continue;
			if (pBody.GetMass() == 0.f) continue;
			if (pBody.GetJointNum() > 0) continue;
			
			///////////////////
			// Already set to not collide with it?
			if (mvNoCollBodies.find(pBody.GetID()) != -1)
				continue;
			
			///////////////////
			// Set to not collide if body is small enough
			cVector3f vBodySize = pBody.GetBoundingVolume().GetSize();
			float fBodySize = cMath_Max(vBodySize.x, cMath_Max(vBodySize.y, vBodySize.z));
			float fBodyMass = pBody.GetMass();
			
			if (fBodySize < 1.f || 
				(fBodySize < 2.f && fBodyMass < 5.f))
			{
				mvNoCollBodies.push_back(pBody.GetID());
				mvNoCollBodiesCollGroups.push_back(pBody.GetCollideFlags());
				
				pBody.SetCollideFlags(mBaseObj.GetMap().GetCollideFlag("-agent"));
				
				// Add a little impulse to the body so the agent is less likely to just clip through
				cVector3f vImpulse = pCharBody.GetForward() * 1.5f;
				pBody.AddImpulse(vImpulse);
			}
		}
		
		///////////////////
		// Enable agent collision again?
		for (uint i = 0; i < mvNoCollBodies.size(); ++i)
		{
			iPhysicsBody@ pBody = cLux_ID_Body(mvNoCollBodies[i]);
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			
			if (pBody is null) continue;
			if (pProp is null) continue;
			
			bool bEnableColl = false;
			float fDistSqr = (pBody.GetWorldPosition() - pCharBody.GetFeetPosition()).SqrLength();

			if (fDistSqr > 3.f * 3.f ||
				pProp.IsInteractedWith() ||
				pBody.GetThrownByPlayer())
			{
				bEnableColl = true;
			}			
			
			if (bEnableColl)
			{
				pBody.SetCollideFlags(mvNoCollBodiesCollGroups[i]);
				
				mvNoCollBodies.removeAt(i);
				mvNoCollBodiesCollGroups.removeAt(i);
				--i;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateHitByProp(float afTimeStep)
	{
		////////////////
		// Iterate collide props
		for (uint i = 0; i < mvCollideProps.size(); ++i)
		{
			////////////////
			// Setup vars
			cStalker_CollidePropData@ pData = mvCollideProps[i];
			cLuxProp@ pProp = cLux_ID_Prop(mvCollideProps[i].m_idProp);
			
			////////////////
			// Update prop pos
			if (pProp !is null)
				mvCollideProps[i].mvLastPropPos = pProp.GetPosition();
			
			////////////////
			// Remove if tracked for long enough
			pData.mfTimeSinceCollision += afTimeStep;
			if (pData.mfTimeSinceCollision >= gfStalker_CollidePropTrackTime)
			{
				mvCollideProps.removeAt(i);
				--i;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateCheckHoleShortcut(float afDeltaTime)
	{		
		/////////////////////
		// Timer
		mfCheckHoleShortcut_UpdateCount -= afDeltaTime;
		if (mfCheckHoleShortcut_UpdateCount > 0.f) return;
		mfCheckHoleShortcut_UpdateCount = cMath_RandRectf(0.3f, 0.6f);
		
		/////////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cVector3f vFeetPos = pCharBody.GetFeetPosition() + cVector3f_Up * 0.1f;
		cVector3f vTargetPos;
		
		if (mbCheckHoleShortcut_ForceCheck)
		{
			vTargetPos = mvCheckHoleShortcut_ForcedCheckTarget;
		}
		else
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPlayerFeetPos(), 0.f, 3.f, true, false, false, null);
			vTargetPos = pNode !is null ? pNode.GetPosition() : mBaseObj.GetPlayerFeetPos() + cVector3f_Up * 0.1f;
		}
		
		/////////////////////
		// Already taking shortcut?
		if (mbRetreat_GoToLastKnownPlayerPosThroughHoles || mbRetreat_TakingShortcut)
			return;
		
		if (!mbCheckHoleShortcut_ForceCheck)
		{
			/////////////////////
			// Make sure it's aggressive!
			int lState = mpStateMachine.GetCurrentState();
			if (lState != eStalkerState_PreHunt &&
				lState != eStalkerState_Hunt)
			{
				ResetCheckHoleShortcut();
				return;
			}

			/////////////////////
			// Long enough since emege? 
			// (So it doesn't just pop back into the hole)
			if (mlEmerge_LastTimeStamp != -1 && 
				mBaseObj.GetMap().GetElapsedTime(mlEmerge_LastTimeStamp) < gfStalker_CheckHoleShortcutMinTimeSinceEmerge)
			{
				ResetCheckHoleShortcut();
				return;
			}
		}

		/////////////////////
		// Get path distance to target!
		if (mlCheckHoleShortcut_Stage == 0)
		{
			mfCheckHoleShortcut_PathDistToTarget = GetPathDistanceToPos(vFeetPos, vTargetPos, false);
			
			if (mfCheckHoleShortcut_PathDistToTarget > 0.f && 
				mfCheckHoleShortcut_PathDistToTarget < gfStalker_CheckHoleShortcutMinPathDistToTarget)
			{
				ResetCheckHoleShortcut();
				return;	
			}

			mlCheckHoleShortcut_Stage = 1;
		}
		
		/////////////////////
		// Get path distance to nearest hole!
		else if (mlCheckHoleShortcut_Stage == 1)
		{
			m_idCheckHoleShortcut_ClosestHole = GetHoleWithShortestPathToPos(vFeetPos, -1.f, -1.f, false, mfCheckHoleShortcut_PathDistToClosestHole);
			if (m_idCheckHoleShortcut_ClosestHole == tID_Invalid)
			{
				ResetCheckHoleShortcut();
				return;
			}
				
			mlCheckHoleShortcut_Stage = 2;
		}
		
		/////////////////////
		// Get path distance to hole closest to target!
		else if (mlCheckHoleShortcut_Stage == 2)
		{
			tID idTargetHole = GetHoleWithShortestPathToPos(vTargetPos, -1.f, -1.f, false, mfCheckHoleShortcut_PathDistToTargetHole);
			if (idTargetHole == tID_Invalid)
			{
				if (mbCheckHoleShortcut_ForceCheck)
					ResetCheckHoleShortcut();
				
				return;
			}
			
			/////////////////////
			// Take hole shortcut if non-hole path is much longer (or doesn't exist)
			float fShortcutDistToTarget = mfCheckHoleShortcut_PathDistToClosestHole + mfCheckHoleShortcut_PathDistToTargetHole;
			
			if (mfCheckHoleShortcut_PathDistToTarget < 0.f || 
				mfCheckHoleShortcut_PathDistToTarget > fShortcutDistToTarget * 2.f)
			{
				cLuxArea@ pHole = cLux_ID_Area(m_idCheckHoleShortcut_ClosestHole);
				if (pHole !is null)
				{
					mbRetreat_GoToLastKnownPlayerPosThroughHoles = !mbCheckHoleShortcut_ForceCheck;
					mbRetreat_TakingShortcut = mbCheckHoleShortcut_ForceCheck;
					
					if (mbRetreat_TakingShortcut)
					{
						mlRetreat_ShortcutState = mlBlocked_PrevState;
						mvRetreat_ShortcutTarget = vTargetPos;
						m_idMoveBetweenHoles_EmergeHole = idTargetHole;
					}
					
					mvRetreat_GoalPos = pHole.GetPosition();
					mpStateMachine.ChangeState(eStalkerState_Retreat);
					
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Taking shortcut through holes!", false, true);
				}
			}
			
			ResetCheckHoleShortcut();
		}		
	}
	
	//------------------------------------------------------------
	
	void ResetCheckHoleShortcut()
	{
		mbCheckHoleShortcut_ForceCheck = false;
		mlCheckHoleShortcut_Stage = 0;
		mfCheckHoleShortcut_PathDistToTarget = -1.f;
		mfCheckHoleShortcut_PathDistToClosestHole = -1.f;
		mfCheckHoleShortcut_PathDistToTargetHole = -1.f;
		m_idCheckHoleShortcut_ClosestHole = tID_Invalid;
	}
	
	//------------------------------------------------------------
	
	void UpdateLampFlickerProximity(float afDeltaTime)
	{
		if (mbMakeLampsFlicker==false || mvLampsInCurrentLevel.size()<=0) return;
		
		////////////////////////////////////
		// Don't flicker any lamps when away
		bool bIsInsideWalls = (mpStateMachine.GetCurrentState() == eStalkerState_WaitInHole ||  
							   mpStateMachine.GetCurrentState() == eStalkerState_MoveBetweenHoles);
		
		int lLampsToUpdate = 1;

		for (uint i=0; i < lLampsToUpdate; i++)
		{
			mlLampFlickerUpdateFrame%= mvLampsInCurrentLevel.size();
			tString sLamp = mvLampsInCurrentLevel[mlLampFlickerUpdateFrame];
			
			mlLampFlickerUpdateFrame++;

			iLuxEntity@ pEnt = cLux_GetCurrentMap().GetEntityByName(sLamp, eLuxEntityType_Prop, "cScrPropLamp");
			if (pEnt is null) continue;
			if (pEnt.GetVarBool("IgnoreAgentFlicker")) continue;

			/////////////////////////////////////////////////////////
			// Update lamp flicker settings based on distance from it
			float fDist = cMath_Vector3Dist(mBaseObj.GetPosition(), pEnt.GetPosition());
			float fMaxFlickerDist = bIsInsideWalls ? 15.f : 25.f;
			bool bFlicker = fDist < fMaxFlickerDist;
			
			/////////////////////////
			// Proximity stages logic
			if (bFlicker)
			{
				if (bIsInsideWalls==false && fDist < fMaxFlickerDist * 0.4f)
				{
					Lamp_SetupFlicker(sLamp, 0.015f, 0.3f, 0.15f, 1.5f, true, "", "", "", "", 0.2f, 0.f);
				}
				else if (bIsInsideWalls==false && fDist > fMaxFlickerDist * 0.4f && fDist < fMaxFlickerDist * 0.7f)
				{
					Lamp_SetupFlicker(sLamp, 1.f, 2.f, 0.15f, 1.f, true, "", "", "", "", 0.5f, 0.f);
				}
				else
				{
					Lamp_SetupFlicker(sLamp, 5.f, 10.f, 0.15f, 0.55f, true, "", "", "", "", 0.7f, 0.f);
				} 
			}
			
			Lamp_SetFlickerActive(sLamp, bFlicker);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateGrenadeTracking(float afDeltaTime)
	{
		////////////////
		// Track grenades
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		for (int i = 0; i < mvTrackedGrenades.size(); ++i)
		{
			iLuxEntity@ pEnt = cLux_ID_Entity(mvTrackedGrenades[i]);			
			if (pEnt is null)
			{
				mvTrackedGrenades.removeAt(i);
				--i;
				continue;
			}
			
			////////////////
			// Within dist?
			float fDistSqr = (pEnt.GetPosition() - pCharBody.GetFeetPosition()).SqrLength();
			if (fDistSqr > gfStalker_ReactToGrenadeDist * gfStalker_ReactToGrenadeDist)
			{
				continue;
			}
			
			////////////////
			// Seen?
			if (mBaseObj.GetPointIsInFOV(pEnt.GetPosition(), mBaseObj.GetFOV(), mBaseObj.GetLookDirection()) == false)
			{
				continue;
			}
			
			if (mBaseObj.GetPointIsInLineOfSight(pEnt.GetPosition() + cVector3f(0.f, 0.2f, 0.f)) == false)
			{
				continue;
			}
			
			////////////////
			// React to grenade!
			mvTrackedGrenades.removeAt(i);
			--i;
			
			mBaseObj.BroadcastMessage(eCustomEntityMessage_GrenadeDetected, null, pEnt.GetPosition(), 0);			
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateFirstEncounterAchievement(float afTimeStep)
	{
		if (mbHidden || mbFirstEncounterHasStarted) return;
	
		if (Achievement_GetUnlocked(eAchievement_GotIntroduced))
		{
			mbFirstEncounterHasStarted = true;
			return;
		}
		
		mfFirstEncounterUpdateTimer -= afTimeStep;
		if (mfFirstEncounterUpdateTimer > 0) return;
		
		mfFirstEncounterUpdateTimer = 0.25f;
		
		if (mBaseObj.GetDistanceToPlayer() < gfStalker_FirstEncounterMaxDist)
			mbFirstEncounterHasStarted = true;
		else if (mBaseObj.GetEntityIsInPlayerLineOfSight(true))
			mbFirstEncounterHasStarted = true;
	}
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STALKER HELPERS
	//{////////////////////////////////

	//------------------------------------------------------------
	
	bool GetPlayerIsInLoS(bool abDoVisibilityMulCheck, bool abVisibilityCheckOnly)
	{
		if (abDoVisibilityMulCheck)
		{
			bool bUseModifiers = mBaseObj.GetSightRangeAffectedByModifiers();
			float fDistToPlayer = mBaseObj.GetDistanceToPlayer();
			float fFinalFOV = mBaseObj.GetFOV() * mBaseObj.GetFOVMul();
			float fFinalRange = mBaseObj.GetSightRange()* mBaseObj.GetSightRangeMul();
			float fMaxVisibilityRange = -1.f;
			
			if (bUseModifiers)
			{
				fFinalRange *= cLux_GetPlayer().GetVisibilityRangeMul();
				fMaxVisibilityRange = cLux_GetPlayer().GetVisibilityMaxRange();
			}
			
			if ((fMaxVisibilityRange >= 0.f && fMaxVisibilityRange < fDistToPlayer) || 
			    (fDistToPlayer > fFinalRange))
			{
				return false;
			}
			
			if (abVisibilityCheckOnly)
			{
				return true;
			}
		}
		
		return mBaseObj.GetPlayerIsInLineOfSight(mBaseObj.GetFOV(), mBaseObj.GetLookDirection(), true);
	}
	
	//------------------------------------------------------------
	
	bool GetCharacterFitsAtPos(const cVector3f &in avPos, bool abFeetPos)
	{
		cVector3f vPush(0.f);
		return mBaseObj.GetCharBody().CheckCharacterFits(avPos, abFeetPos, 0, vPush);
	}
	
	//------------------------------------------------------------
	
	tID GetHoleWithShortestPathToPos(const cVector3f &in avPos, float afMinDist = -1.f, float afMaxDist = -1.f, 
									 bool abOnlyFree = false, array<tID>@ apExcludeHoles = null)
	{
		float fDist;
		return GetHoleWithShortestPathToPos(avPos, afMinDist, afMaxDist, abOnlyFree, fDist, apExcludeHoles);
	}
	
	//------------------------------------------------------------
	
	tID GetHoleWithShortestPathToPos(const cVector3f &in avPos, float afMinDist, float afMaxDist, bool abOnlyFree, 
									 float &out afDistToHole, array<tID>@ apExcludeHoles = null)
	{
		//////////////////
		// Special setup if in hole network
		int lState = mpStateMachine.GetCurrentState();
		bool bInHole = lState == eStalkerState_WaitInHole ||
					   lState == eStalkerState_MoveBetweenHoles ||
					   lState == eStalkerState_Emerge;
		
		//////////////////
		// Setup vars
		int lBlockedHoleCount = 0;
		array<tID> vHoles;
		array<tID> vExcludedHoles;
		
		if (apExcludeHoles !is null)
		{
			for (uint i = 0; i < apExcludeHoles.size(); ++i)
				vExcludedHoles.push_back(apExcludeHoles[i]);
		}		
		
		//////////////////
		// Get four closest holes
		for (uint i = 0; i < 4; ++i)
		{
			tID idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, avPos, afMinDist, afMaxDist, abOnlyFree, false, vExcludedHoles);
			if (idHole == tID_Invalid) 
				continue;
			
			vHoles.push_back(idHole);
			vExcludedHoles.push_back(idHole);
			
			if (Emerge_GetIsKnownBlockedHole(idHole))
				++lBlockedHoleCount;
		}
		
		//////////////////
		// Some are blocked, remove them from selection!
		if (bInHole && lBlockedHoleCount < int(vHoles.size()))
		{
			for (uint i = 0; i < vHoles.size(); ++i)
			{
				if (Emerge_GetIsKnownBlockedHole(vHoles[i]))
				{
					vHoles.removeAt(i);
					--i;
				}
			}
		}
		
		//////////////////
		// No holes available, escape!
		if (vHoles.size() == 0)
		{
			afDistToHole = -1.f;
			return tID_Invalid;
		}
		
		//////////////////
		// Get hole with shortest path to pos
		float fMinDist = 1000.f;
		tID idClosest = tID_Invalid;
		
		for (uint i = 0; i < vHoles.size(); ++i)
		{
			cLuxArea@ pArea = cLux_ID_Area(vHoles[i]);
			if (pArea is null) continue;

			float fDist = GetPathDistanceToPos(pArea.GetPosition(), avPos, true);
			if (fDist < fMinDist && fDist > 0.f)
			{
				fMinDist = fDist;
				idClosest = vHoles[i];
			}
		}
		
		//////////////////
		// Return
		afDistToHole = fMinDist;		
		return idClosest;
	}
	
	//------------------------------------------------------------
	
	tID GetHoleInDir(const cVector3f &in avDir, bool abPathCheck, bool abClosest)
	{
		////////////////
		// Get hole
		tID idHole = Blackboard_GetGhoulHoleInPosDir(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), avDir, -1.f, -1.f, false, abClosest, false);
		iLuxEntity@ pHole = idHole != tID_Invalid ? cLux_ID_Entity(idHole) : null;
		
		if (idHole == tID_Invalid || pHole is null)
			return tID_Invalid;
		
		////////////////
		// Available path to it?
		if (abPathCheck)
		{
			return mpPathfinder.BuildPathNodeArrayToPos(pHole.GetPosition(), 1) ? idHole : tID_Invalid;
		}
		
		return idHole;
	}
	
	//------------------------------------------------------------
	
	float GetPathDistanceToPos(const cVector3f &in avFrom, const cVector3f &in avTo, bool abGetGroundPos = false)
	{
		//////////////////
		// Make sure positions are close to ground so pathfinding works
		cVector3f[] vPositions = {avFrom, avTo};
		
		if (abGetGroundPos)
		{
			float fDist;
			cVector3f vNrm;
			for (uint i = 0; i < 2; ++i)
			{
				if (cLux_GetClosestBody(vPositions[i], cVector3f_Down, 2.f, fDist, vNrm) !is null)
					vPositions[i] = vPositions[i] + cVector3f_Down * (fDist - 0.1f);
			}
		}
		
		if (mpPathfinder.BuildPathNodeArrayFromTo(vPositions[0], vPositions[1], 1))
			return mpPathfinder.GetPathNodeArrayFullLength();
		
		return -1.f;
	}
	
	//------------------------------------------------------------
	
	bool GetShouldIgnoreSound()
	{			
		/////////////////
		// Setup vars		
		bool bCausedBySelf = false;
		
		cVector3f vSoundPos = mpStateMachine.GetCurrentMessageData().mvX;
		tID idSoundSourceBody = mpStateMachine.GetCurrentMessageData().mID;	
		tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
		bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player";
		
		iPhysicsBody@ pSourceBody = cLux_ID_Body(idSoundSourceBody);
		cLuxProp@ pSourceProp = cLux_ToProp(cLux_GetBodyEntity(pSourceBody));
		
		/////////////////
		// Senses inactive?
		if (GetSensesActive() == false)
		{
			return true;
		}
		
		/////////////////
		// Player in save room?
		if (mbPlayerIsInSaveRoom)
		{
			return true;
		}
		
		/////////////////
		// Ignore near sounds (with low enough prio)?
		int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
		float fDistToStalkerSqr = (mBaseObj.GetPosition() - vSoundPos).SqrLength();
		if (lPrio <= 4 &&
			fDistToStalkerSqr < 4.f * 4.f && 
			mBaseObj.Timer_Exists("Timer_IgnoreNearSounds"))
		{
			return true;
		}
		
		/////////////////
		// Ignore physics sounds?
		bool bIsPhysicsSound = mpStateMachine.GetCurrentMessageData().mlY == 1;
		if (bIsPhysicsSound && 
			mBaseObj.Timer_Exists("Timer_IgnorePhysicsSounds"))
		{
			return true;
		}
		
		/////////////////
		// Recently hurt?
		if (mbHurt_RecentlyHurt) 
		{
			return true;
		}
		
		///////////////
		// Is in ignore list?
		if (idSoundSourceBody != tID_Invalid && 
			mvInvestigateSound_IgnoredSoundSourceBodyIds.find(idSoundSourceBody) != -1)
		{
			return true;
		}
		
		//////////////////
		// Ignore prisoner?
		if (cScript_GetGlobalVarBool("Stalker_IgnorePrisonerSounds") &&
			sSoundName == "PrisonerScream")
		{
			return true;
		}
		
		//////////////////
		// Scrape sound and should ignore those right now?
		if (cString_GetFirstStringPos(cString_ToLowerCase(sSoundName), "scrape") != -1 &&
			mBaseObj.Timer_Exists("Timer_IgnoreScrapeSound"))
		{
			return true;
		}
		
		/////////////////
		// Physics sound close to stalker, not caused by the player?			
		if (bIsPhysicsSound && 
			fDistToStalkerSqr < 4.f * 4.f && 
			pSourceBody !is null &&
			bCausedByPlayer == false)
		{
			bCausedBySelf = true;
		}
		
		/////////////////
		// Check if caused by any of the tracked collide props
		else
		{
			for (uint i = 0; i < mvCollideProps.size(); ++i)
			{
				/////////////////
				// Does prop contain sound source body?
				cLuxProp@ pProp = cLux_ID_Prop(mvCollideProps[i].m_idProp);
				if (pProp !is null && pProp is pSourceProp) 
				{
					bCausedBySelf = true;
					break;
				}
					
				/////////////////
				// Caused by the prop being broken?
				if (pSourceProp !is null)
				{
					if (pSourceProp.GetName() == mvCollideProps[i].msPropName + "_broken")
					{
						bCausedBySelf = true;
						break;
					}
				}
					
				/////////////////
				// Sound close to prop?
				float fDistToPropSqr = (mvCollideProps[i].mvLastPropPos - vSoundPos).SqrLength();
				if (fDistToPropSqr < 2.f * 2.f)
				{
					bCausedBySelf = true;
					break;
				}
			}
		}
		
		/////////////////
		// Caused by self, ignore!
		if (bCausedBySelf)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Ignore sound made by knocking over stuff", false, true);
			return true;
		}
			
		/////////////////
		// Don't ignore!
		return false;
	}
	
	//------------------------------------------------------------
	
	bool GetIsAttacking()
	{
		int lState = mpStateMachine.GetCurrentState();
		return	lState == eStalkerState_AttackClose || 
				lState == eStalkerState_ThrowPlayer;
	}
	
	//------------------------------------------------------------

	bool GetIsAggressive()
	{
		int lState = mpStateMachine.GetCurrentState();
		return lState == eStalkerState_AttackClose ||
			   lState == eStalkerState_ThrowPlayer ||
			   lState == eStalkerState_Hunt ||
			   lState == eStalkerState_PreHunt;
	}
	
	//------------------------------------------------------------
	
	bool GetIsRunningQuickly()
	{
		return mpMover.GetSpeedState() >= eStalkerSpeed_Run && mBaseObj.GetCharBody().GetMoveSpeed(eCharDir_Forward) >= 4.f;
	}
	
	//------------------------------------------------------------

	void PositionAtGhoulHole(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pHole is null) return;		
		
		cVector3f vPos = GetHoleGroundPos(a_idHole);
		
		///////////////
		// Position as far out from the wall as the char body requires
		if (mbHidden == false)
		{
			float fDistFromWall = pHole.GetAreaBody().GetShape().GetDepth() / 2.f;
			float fDistAdd = pCharBody.GetSize().x - fDistFromWall;
		
			cVector3f vFwd = GetHoleFwd(a_idHole);
			vPos += vFwd * fDistAdd;
		}
		
		pCharBody.SetFeetPosition(vPos, false);
		pCharBody.SetYaw(GetHoleAngle(a_idHole));
	}
	
	//------------------------------------------------------------
	
	bool GetIsHoleBlocked(tID a_idHole, tID &out a_iBlockingBody)
	{
		cLuxArea@ pArea = cLux_ID_Area(a_idHole);
		if (pArea is null) return false;
		
		a_iBlockingBody = GhoulHole_GetBlockingBody(pArea.GetName());
		return a_iBlockingBody != tID_Invalid;
	}
	
	//------------------------------------------------------------
	
	cVector3f GetHoleGroundPos(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		if (pHole is null) return cVector3f(0.f);
		
		cVector3f vHolePos = pHole.GetPosition();
		vHolePos += GetHoleFwd(a_idHole) * -0.25f;
		vHolePos.y = pHole.GetAreaBody().GetBoundingVolume().GetMin().y;
		
		return vHolePos;
	}
	
	//------------------------------------------------------------
	
	cVector3f GetHoleFwd(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		return pHole !is null ? pHole.GetMatrix().GetTranspose().GetForward() : cVector3f(0.f);
	}
	
	//------------------------------------------------------------
	
	cVector3f GetHoleRight(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		return pHole !is null ? pHole.GetMatrix().GetTranspose().GetRight() : cVector3f(0.f);
	}
	
	//------------------------------------------------------------
	
	cMatrixf GetHoleMatrix(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		return pHole !is null ? pHole.GetMatrix() : cMatrixf_Identity;
	}
	
	//------------------------------------------------------------
	
	float GetHoleAngle(tID a_idHole)
	{
		return cMath_GetAngleFromPoints3D(0.f, GetHoleFwd(a_idHole)).y;;
	}
	
	//------------------------------------------------------------
	
	void SetHidden(bool abHidden)
	{
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		if (pMeshEnt is null) return;
		if (pCharBody is null) return;
		
		mbHidden = abHidden;
		mbRetreat_Active = false;
		
		if (mbHidden)
			mBaseObj.StopAllAnimations(0.f);
		
		pCharBody.SetActive(abHidden == false);
		pCharBody.SetTestCollision(abHidden == false);
		pCharBody.StopMovement();
		pMeshEnt.SetActive(abHidden == false);
		pMeshEnt.SetVisible(false);
		
		mBaseObj.SetUpdatePlayerDetection(mbHidden == false);
		mBaseObj.ResetPlayerDetectionState();
	}
	
	//------------------------------------------------------------
	
	bool ChangeMode(eStalkerMode aNewMode, bool abResetPresence)
	{
		eStalkerMode prevMode = mMode;
		mMode = aNewMode;
		
		///////////////
		// Reset presence?
		if (abResetPresence)
		{
			if (mMode == eStalkerMode_Active) 			mfPresence = 0.f;
			else if (mMode == eStalkerMode_Passive) 	mfPresence = 1.f;
		}
		
		///////////////
		// Make sure mode has changed
		if (prevMode == mMode) 
			return false;
		
		int lState = mpStateMachine.GetCurrentState();
		tString sMode = aNewMode == eStalkerMode_Active ? "Active" : "Passive";
		
		if (prevMode != mMode)
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER MODE: " + sMode + " ------");
		
		///////////////
		// Enter active!
		if (mMode == eStalkerMode_Active)
		{			
			////////////////
			// Make sure presence isn't full (or it will go back to passive immediately!)
			if (mfPresence > 0.75f)
				mfPresence = 0.75f;
			
			///////////////
			// Setup behaviour!
			mfPlayerLeftSaveRoomCount = 0.f;
			mbHurt_RecentlyHurt = false;
			mbHurt_HurtByPlayer = false;
			
			SetupModeBehaviour();
		}
		
		///////////////
		// Enter passive!
		else if (mMode == eStalkerMode_Passive)
		{			
			//////////////
			// Setup decrease mul
			mfRandPresenceDecreaseMul = cMath_RandRectf(0.7f, 1.25f);
			
			///////////////
			// Setup behaviour!			
			SetInterestAlert(false);			
			SetupModeBehaviour();
		}
		
		return true;
	}
	
	//------------------------------------------------------------
	
	void SetupModeBehaviour()
	{
		///////////////
		// Setup vars
		int lState = mpStateMachine.GetCurrentState();
		
		///////////////
		// Active
		if (mMode == eStalkerMode_Active)
		{
			///////////////
			// Already emerged?
			if (mbHidden == false) return;
			
			///////////////
			// Emerging?
			if (m_idEmerge_Hole != tID_Invalid) return;
			if (m_idMoveBetweenHoles_EmergeHole != tID_Invalid) return;
			
			///////////////
			// Generator on? Go to hole!
			if (Generator_GetState() == eGeneratorState_On)
			{				
				bool bMoved = false;				
				tID idPrevHole = tID_Invalid;
				
				switch (lState)
				{
					case eStalkerState_WaitInHole: 			idPrevHole = m_idWaitInHole_Hole; 				break;
					case eStalkerState_MoveBetweenHoles: 	idPrevHole = m_idMoveBetweenHoles_GoalHole; 	break;
				}
				
				m_idMoveBetweenHoles_GoalHole = InHole_GetGoalHole(idPrevHole);
					
				if (lState == eStalkerState_WaitInHole && 
					m_idWaitInHole_Hole != m_idMoveBetweenHoles_GoalHole)
				{
					bMoved = true;
					mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
				}
				else if (lState == eStalkerState_MoveBetweenHoles)
				{
					bMoved = true;
					MoveBetweenHoles_StartMove();
				}
				
				if (bMoved)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Generator on, moving to hole!");
				}
			}
				
			///////////////
			// Generator off? Emerge!
			else
			{
				if (mbEmergeAllowed == false) return;
				if (mbPlayerIsInSaveRoom) return;
				
				if (lState == eStalkerState_WaitInHole &&
					m_idEmerge_Hole != m_idWaitInHole_Hole)
				{
					m_idMoveBetweenHoles_EmergeHole = m_idWaitInHole_Hole;
					mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
				}
				else if (lState == eStalkerState_MoveBetweenHoles &&
						 m_idMoveBetweenHoles_EmergeHole != m_idMoveBetweenHoles_GoalHole)
				{
					m_idMoveBetweenHoles_EmergeHole = m_idMoveBetweenHoles_GoalHole;
					MoveBetweenHoles_StartMove();
				}
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Generator off, emerging!");
			}
		}
		
		///////////////
		// Passive
		else
		{
			///////////////
			// Already hidden?
			if (mbHidden) return;
			
			///////////////
			// Already retreating to a hole?	
			if (lState == eStalkerState_Hurt || 
				lState == eStalkerState_Retreat || 
				lState == eStalkerState_ReturnToHole)
			{
				return;
			}
			
			///////////////
			// Return to hole!
			cVector3f vPos = mpPathfinder.IsMoving() ? mpPathfinder.GetGoalPos() : mBaseObj.GetPosition();
			m_idReturnToHole_Hole = GetHoleWithShortestPathToPos(vPos, -1.f, -1.f, false);
			
			if (m_idReturnToHole_Hole == tID_Invalid)
			{
				m_idReturnToHole_Hole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, vPos, -1.f, -1.f, false, false);
			}
		}
	}
	
	//------------------------------------------------------------
	
	cVector3f GetAveragePlayerVelocity()
	{
		cVector3f vAvgVelocity = cVector3f(0.f);		
		
		for (int i = 0; i < mvPlayerPrediction_VelocityBuffer.size(); ++i)
			vAvgVelocity += mvPlayerPrediction_VelocityBuffer[i];
			
		vAvgVelocity /= mvPlayerPrediction_VelocityBuffer.size();		
		return vAvgVelocity;
	}
	
	//------------------------------------------------------------

	void IncreaseSoundCounter(int alPrio)
	{
		float fSoundCounterChange = (alPrio + 1.f);
		mfSoundCounter += fSoundCounterChange;
		
		if (mfSoundCounter > 12.f) 
			mfSoundCounter = 12.f;
	}
	
	//------------------------------------------------------------
	
	void SetAlertState(eStalkerAlertState aState)
	{
		if (aState == eStalkerAlertState_None &&
			mAlertState > aState)
		{
			mBaseObj.Timer_Add("Timer_JustLeftAlertState", 20.f);
		}
		
		mAlertState = aState;
		SetLocomotionAnimState(mAlertState);
	}
	
	//------------------------------------------------------------
	
	void SetLocomotionAnimState(eStalkerAlertState aState)
	{
		////////////////
		// Get prev
		tString sPrevIdleAnim = msIdleAnim;
		tString sPrevWalkAnim = msWalkAnim;
		tString sPrevWalkCrampedAnim = msWalkCrampedAnim;
		tString sPrevRunAnim = msRunAnim;
		
		////////////////
		// None
		if (mAlertState == eStalkerAlertState_None)
		{
			msIdleAnim = gsStalkerAnim_Idle;
			msWalkAnim = gsStalkerAnim_Walk;
			msWalkCrampedAnim = gsStalkerAnim_WalkCramped;
			msRunAnim = gsStalkerAnim_Run;
		}
		
		////////////////
		// Investigate
		else if (mAlertState == eStalkerAlertState_Investigating)
		{
			msIdleAnim = gsStalkerAnim_IdleStalk;
			msWalkAnim = gsStalkerAnim_WalkStalk;
			msWalkCrampedAnim = gsStalkerAnim_WalkCrampedStalk;
			msRunAnim = gsStalkerAnim_RunStalk;
		}
		
		////////////////
		// Rage
		else if (mAlertState == eStalkerAlertState_Detected)
		{
			msIdleAnim = gsStalkerAnim_IdleRage;
			msWalkAnim = gsStalkerAnim_WalkRage;
			msWalkCrampedAnim = gsStalkerAnim_WalkCrampedRage;
			msRunAnim = gsStalkerAnim_RunRage;
		}
		
		////////////////
		// Upright
		if (mbShouldWalkUpright)
		{
			msWalkAnim = gsStalkerAnim_WalkUprightB;
			msWalkCrampedAnim = gsStalkerAnim_WalkUprightBCramped;
		}
		
		////////////////
		// Switch anims
		SwitchLocomotionAnim(eStalkerLocomotionAnimType_Idle, msIdleAnim, sPrevIdleAnim);
		SwitchLocomotionAnim(eStalkerLocomotionAnimType_Run, msRunAnim, sPrevRunAnim);
		
		if (mbUseCrampedAnims)
		{
			SwitchLocomotionAnim(eStalkerLocomotionAnimType_Walk, msWalkCrampedAnim, sPrevWalkCrampedAnim);
		}
		else
		{
			SwitchLocomotionAnim(eStalkerLocomotionAnimType_Walk, msWalkAnim, sPrevWalkAnim);
		}
	}
	
	//------------------------------------------------------------
	
	bool GetSensesActive(bool abRetreatCheck = true)
	{
		if (abRetreatCheck && mbRetreat_Active) return false;
		return mBaseObj.GetSensesActive();
	}
	
	//------------------------------------------------------------
	
	tString GetLookAnimation(const cVector3f &in avLookPos, bool abLookAtPlayer)
	{
		///////////////////
		// Always use straight ahead anim + head tracker when looking at player
		if (abLookAtPlayer)
		{
			return gsStalkerAnim_Glimpse;
		}
		
		///////////////////
		// Setup vars
		tString sAnim = "";
		
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cVector3f vFwd = pCharBody.GetForward();
		cVector3f vRight = pCharBody.GetRight();		
		
		///////////////////
		// Get angle to detected pos
		cVector3f vToLookPos = avLookPos - mBaseObj.GetPosition();
		vToLookPos.y = 0;
		vToLookPos.Normalize();
		
		float fAngle = cMath_ToDeg(cMath_Vector3Angle(vToLookPos, vFwd));
		float fSign = cMath_Vector3Dot(vToLookPos, vRight) >= 0.f ? 1.f : -1.f;		

		///////////////////
		// Straight ahead
		if (fAngle <= 30.f)
		{
			sAnim = gsStalkerAnim_Glimpse;
		}
		
		///////////////////
		// Ahead and to the side
		else if (fAngle <= 70.f)
		{
			if (fSign > 0.f)
			{
				cVector3f vOffset = cVector3f(0.5f, -0.35f, 1.f);
				if (GetIsHeadColliding(vOffset) == false)
					sAnim = gsStalkerAnim_Glimpse_45_Right;
			}
			else
			{
				cVector3f vOffset = cVector3f(-0.5f, -0.35f, 1.f);
				if (GetIsHeadColliding(vOffset) == false)
					sAnim = gsStalkerAnim_Glimpse_45_Left;
			}
		}
		
		///////////////////
		// To the side
		else
		{
			if (fSign >= 0.f)
			{
				cVector3f vOffset = cVector3f(1.f, -0.35f, 0.5f);
				if (GetIsHeadColliding(vOffset) == false)
					sAnim = gsStalkerAnim_Glimpse_90_Right;
			}
			else
			{
				cVector3f vOffset = cVector3f(-1.f, -0.35f, 0.5f);
				if (GetIsHeadColliding(vOffset) == false)
					sAnim = gsStalkerAnim_Glimpse_90_Left;
			}
		}
		
		///////////////////
		// Fail safe
		if (sAnim == "")
			sAnim = gsStalkerAnim_Glimpse;
		
		return sAnim;
	}
	
	//------------------------------------------------------------
	
	bool GetCanKillPlayer(float afMaxDist = -1.f, float afMaxYDist = 1.5f)
	{
		////////////////
		// Kill player if close enough!
		float fMaxDist = afMaxDist < 0.f ? 3.f : afMaxDist;
		float fPosDiffY = cMath_Abs(mBaseObj.GetPlayerFeetPos().y - mBaseObj.GetCharBody().GetFeetPosition().y);
		
		if (fPosDiffY <= afMaxYDist && 
			mBaseObj.GetDistanceToPlayer2D() < fMaxDist &&
			mBaseObj.Timer_Exists("Timer_DontKillPlayer") == false &&
			cLux_CheckLineOfSight(mBaseObj.GetPosition(), mBaseObj.GetPlayerHeadPos(), false, false))
		{
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void SetPreBlockedState(int alState)
	{
		if (alState != eStalkerState_BlockedByProp && 
			alState != eStalkerState_Blocked &&
			alState != eStalkerState_EvaluateObstacle &&
			alState != eStalkerState_BreakDoor)
		{
			mlBlocked_PrevState = alState;
		}
	}
	
	//------------------------------------------------------------
	
	void SetSpeedState(int alSpeed)
	{
		/////////////////
		// Set speed
		mpMover.SetSpeedState(eStalkerSpeed(alSpeed));
		
		/////////////////
		// Less precise when running
		float fPathNodeReachedDistMul = 1.f;
		if (alSpeed == eStalkerSpeed_Run)
			fPathNodeReachedDistMul = 1.3f;
		
		mpPathfinder.SetPathNodeReachedDistMul(fPathNodeReachedDistMul);
		
		/////////////////
		// Detect doors earlier when running
		if (eStalkerSpeed(alSpeed) == eStalkerSpeed_Run)
			mBaseObj.SetMaxCheckDoorDistance(3.f);
		else
			mBaseObj.SetMaxCheckDoorDistance(1.7f);
	}
	
	//------------------------------------------------------------
	
	bool GetIsInCrampedSpace()
	{
		///////////////////
		// Setup vars
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		if (pPhysicsWorld is null) return false;
		if (pCharBody is null) return false;
		
		///////////////////
		// Create shape if needed
		if (mpCrampedAnimShape is null)
		{
			float fRadius = (pCharBody.GetSize().x * 1.45f) / 2.f;
			@mpCrampedAnimShape = pPhysicsWorld.CreateSphereShape(fRadius, cMatrixf_Identity);
		}	
		
		///////////////////
		// In a tight space?
		cVector3f vPush;
		cVector3f vPos = pCharBody.GetPosition() + cVector3f_Up * 0.25f + pCharBody.GetForward() * 1.25f;		
		cMatrixf mtxTransform = cMath_MatrixTranslate(vPos);
		return pPhysicsWorld.CheckShapeWorldCollision(vPush, mpCrampedAnimShape, mtxTransform, null, false, false, false, false);
	}
	
	//------------------------------------------------------------
	
	void SwitchLocomotionAnim(eStalkerLocomotionAnimType aType, const tString &in asNewAnim, const tString &in asPrevAnim)
	{
		///////////////////
		// Setup vars
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();				
		cAnimationState@ pNewAnim = pMeshEnt.GetAnimationStateFromName(asNewAnim);
		cAnimationState@ pPrevAnim = pMeshEnt.GetAnimationStateFromName(asPrevAnim);		
		cAnimationState@ pCurrentAnim = mBaseObj.GetCurrentAnimationState();
		
		if (pNewAnim is null || pPrevAnim is null || pCurrentAnim is null)
			return;
		
		///////////////////
		// Idle
		if (aType == eStalkerLocomotionAnimType_Idle)
		{
			mpMover.SetIdleAnimName(asNewAnim);
		}
		
		///////////////////
		// Walk
		else if (aType == eStalkerLocomotionAnimType_Walk)
		{
			mpMover.SetWalkAnimName(asNewAnim);
		}
		
		///////////////////
		// Run
		else if (aType == eStalkerLocomotionAnimType_Run)
		{
			mpMover.SetRunAnimName(asNewAnim);
		}
		
		///////////////////
		// Set anim
		if (asNewAnim != pCurrentAnim.GetName() &&
			pCurrentAnim.GetName() == pPrevAnim.GetName())
		{
			mBaseObj.PlayAnimation(asNewAnim, 0.3f, true, false);
			pNewAnim.SetTimePosition(pPrevAnim.GetTimePosition());
			pNewAnim.SetSpeed(pPrevAnim.GetSpeed());
		}	
	}
	
	//------------------------------------------------------------
	
	bool GetIsHeadColliding(const cVector3f &in avOffset)
	{
		//////////////////
		// Create shape by head
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
			
		if (pPhysicsWorld is null) return false;
		if (pCharBody is null) return false;
		
		cVector3f vOffset = pCharBody.GetRight() * avOffset.x +
							pCharBody.GetUp() * avOffset.y +
							pCharBody.GetForward() * avOffset.z;
							
		cVector3f vHeadPos = pCharBody.GetPosition() + cVector3f(0.f, pCharBody.GetSize().y / 2.f, 0.f) + vOffset;
			
		float fRadius = 0.35f;
		iCollideShape@ pShape = pPhysicsWorld.CreateSphereShape(fRadius, cMatrixf_Identity);		
			
		//////////////////
		// Check if there's enough space by head
		cVector3f vPush;
		cMatrixf mtxTransform = cMath_MatrixTranslate(vHeadPos);		
		bool bColl = pPhysicsWorld.CheckShapeWorldCollision(vPush, pShape, mtxTransform, pCharBody.GetCurrentBody(), false, false, false, false);
		
		//////////////////
		// Destroy shape!
		pPhysicsWorld.DestroyShape(pShape);
		
		return bColl;
	}
	
	//------------------------------------------------------------
	
	void SetLampsFlicker(bool abX)
	{
		mbMakeLampsFlicker = abX;
		if (abX) return;
		StopLampFlickerInCurrLevel();
	}
	
	//------------------------------------------------------------
	
	float GetTenacityClampedAtMid()
	{
		return cMath_Clamp(mfTenacity, gfStalker_TenacityMin, gfStalker_TenacityMax / 2.f);
	}
	
	//------------------------------------------------------------
	
	bool InHole_ShouldInvestigateSound(bool abIsGunShot, int alPrio, tID a_idHole, const cVector3f &in avPos)
	{			
		//////////////////////
		// Get source distance
		iLuxEntity@ pHole = cLux_ID_Entity(a_idHole);
		
		cVector3f vListenerPos = pHole !is null ? pHole.GetPosition() + GetHoleFwd(a_idHole) : mBaseObj.GetPosition();		
		cVector3f vPos = abIsGunShot ? mBaseObj.GetPlayerPos() : mpStateMachine.GetCurrentMessageData().mvX;
		
		float fDist = (vPos - vListenerPos).Length();
		
		/////////////////////
		// Ignore if occluded
		if (InvestigateSound_GetIsSoundOccluded(alPrio, vListenerPos, avPos)) 
		{
			////////////////////////////////
			// Ignore occlusion if too close
			if (fDist > gfStalker_InHoleAlwaysHearRadius)
				return false;
		}
	
		//////////////////
		// Player movement
		if (mpStateMachine.GetCurrentMessageData().msX == "Footstep")
		{
			///////////////////////////
			// Don't care about walking
			if (alPrio <= 2)
				return false;
			
			/////////////////
			// Special radius for running
			if (fDist > gfStalker_InHoleHearRadius)
				return false;
		}
		
		///////////////////////////
		// Only care about low prio sounds that are within special radius
		if (alPrio <= 2 && fDist > gfStalker_InHoleHearRadius)
			return false;
				
		/////////////////////
		// Increase sound counter!
		IncreaseSoundCounter(alPrio);
		
		//////////////////////
		// More noise needed if passive!
		if (mMode == eStalkerMode_Passive)
		{
			if (mfSoundCounter < 4.f)
				return false;
		}
		
		/////////////////
		// Investigate!
		return true;
	}
	
	//------------------------------------------------------------
	
	void PlayGlimpseEndAnim(const tString &in asGlimpseAnim)
	{
		tString sAnim = asGlimpseAnim;
		sAnim.resize(sAnim.length() - 4);
		sAnim += "end";
		
		mpMover.PlayAnimation(sAnim, 0.3f, false);
	}
	
	//------------------------------------------------------------
	
	void BreakPropWhileRunning(cLuxProp@ apDoor)
	{
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap is null) return;
		
		cVector3f vPos = apDoor.GetPosition();
		iPhysicsBody@ pCurrentBody = mBaseObj.GetCharBody().GetCurrentBody();
		int lDamageId = mBaseObj.GetMap().GetNewAttackInstanceID();
		
		apDoor.GiveDamage(pCurrentBody, mBaseObj.GetPosition(), vPos, eDamageType_Default, 100.f, 1.f, 100.f, 5.f, mBaseObj.GetID(), lDamageId);
		DoDoorImpact(apDoor.GetName());
	}
	
	//------------------------------------------------------------
	
	tString GetRandomLookAroundSideAnim()
	{
		tString[] sAnims = { gsStalkerAnim_LookAroundLeft, gsStalkerAnim_LookAroundRight };
		cVector3f[] vOffsets = { cVector3f(-0.8f, -0.65f, 0.85f), cVector3f(1.f, -1.f, 0.8f) };
		
		int lAnimId = cMath_RandRectl(0, 1);
		
		if (GetIsHeadColliding(vOffsets[lAnimId]))
			lAnimId = (lAnimId + 1) % 1;
					
		return sAnims[lAnimId];
	}
	
	//------------------------------------------------------------
	
	void DoDoorImpact(const tString &in asDoor)
	{
		tString sBrokenDoor = asDoor + "_broken";
		cLuxProp@ pProp = cLux_ToProp(mBaseObj.GetMap().GetEntityByName(sBrokenDoor, eLuxEntityType_Prop));
			
		if (pProp !is null)
		{
			for (int i = 0; i < pProp.GetBodyNum(); ++i)
			{
				iPhysicsBody@ pBody = pProp.GetBody(i);
				if (pBody is null) continue;
					
				pBody.SetLinearVelocity(0.f);
				cVector3f vImpulse = mBaseObj.GetCharBody().GetForward() * cMath_RandRectf(3.f, 4.f);
				cVector3f vTorque = cMath_Vector3ClampLength(cMath_RandomSphereSurfacePoint(1.f), 0.5f, 1.f);					
					
				pBody.AddImpulseAtPosition(vImpulse, mBaseObj.GetPosition());
				pBody.AddTorque(vTorque);
			}
		}	
	}
	
	//------------------------------------------------------------
	
	bool GetPathBlockerIsOpenDoor(tID a_idBlockerBody)
	{
		iLuxEntity@ pEnt = cLux_GetBodyEntity(cLux_ID_Body(a_idBlockerBody));		
		return pEnt !is null &&
			   pEnt.GetIsDoor() && 
			   SwingDoor_GetOpenAmount(pEnt.GetName()) < gfStalker_SwingDoorObstacleOpenAmount;
	}
	
	//------------------------------------------------------------
	
	void ResetRecentlyHurtIfSoundInterestingEnough(int alPrio)
	{
		/////////////////
		// Many interesting sounds played recently?
		tString sHighPrioHurtSoundTimer = "Timer_HeardHighPrioSoundWhileHurt";
		
		if (alPrio >= 5 && 
			mbHurt_RecentlyHurt && 
			mbHidden &&
			Game_GetDifficultyMode() != eGameMode_Easy &&
			mBaseObj.Timer_Exists(sHighPrioHurtSoundTimer) == false)
		{
			mBaseObj.Timer_Add(sHighPrioHurtSoundTimer, 1.f);
			
			float fPresenceDecrease = 0.25f;
			if (mfPresence - fPresenceDecrease <= 0.f)
			{
				mbHurt_RecentlyHurt = false;
				mbHurt_HurtByPlayer = false;
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reseting recently hurt, too many high prio sounds!");
				return;
			}
			else
			{
				mfPresence -= fPresenceDecrease;
			}
		}
		
		/////////////////
		// Prio is high enough?
		if (mbHurt_RecentlyHurt && 
			alPrio > glStalker_IgnoreSoundMaxPrioWhenHurt &&
			mBaseObj.Timer_Exists("Timer_InvestigatedSoundWhileHurt") == false)
		{
			mbHurt_RecentlyHurt = false;
			mbHurt_HurtByPlayer = false;
			mBaseObj.Timer_Add("Timer_InvestigatedSoundWhileHurt", cMath_RandRectf(30.f, 45.f));
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reseting recently hurt, sound is too interesting!");
		}
	}
	
	//------------------------------------------------------------
	
	cVector3f GetRootPosition()
	{
		cBoneState@ pRoot = mBaseObj.GetMeshEntity().GetBoneStateFromName("j_Root");
		return pRoot !is null ? pRoot.GetWorldPosition() : cVector3f(0.f);
	}
	
	//------------------------------------------------------------		
	
	void IncreaseInterest(cLuxEntityMessageData@ apData, bool abForceAlert = false)
	{
		if (apData is null) return;
		
		cVector3f vPos = apData.mvX;
		int lPrio = abForceAlert ? 6 : apData.mlX;
		tString sName = apData.msX;
		tID idBody = apData.mID;
		bool bIsCausedByPlayer = apData.msY == "Player";	
		bool bIsPhysicsSound = apData.mlY == 1;	
		
		IncreaseInterest(sName, vPos, lPrio, bIsCausedByPlayer, bIsPhysicsSound, idBody, abForceAlert);
	}
	
	//------------------------------------------------------------
	
	void IncreaseInterest(const tString &in asSound, const cVector3f &in avPos, int alPrio, bool abIsCausedByPlayer, 
						  bool abIsPhysicsSound, tID a_idSourceBody, bool abForceAlert = false)
	{	
		/////////////////////
		// Setup vars
		bool bGeneratorOn = Generator_GetState() == eGeneratorState_On;
		int lState = mpStateMachine.GetCurrentState();
		int lForceAlertMinPrio = bGeneratorOn ? 0 : 2;
		
		if (abForceAlert && 
			alPrio > lForceAlertMinPrio)
		{
			alPrio = 6;
		}
		
		bool bIsFootstep = cString_GetFirstStringPos(asSound, "Footstep") != -1;
		bool bIsScrapeSound = cString_GetFirstStringPos(cString_ToLowerCase(asSound), "scrape") != -1;
		iPhysicsBody@ pBody = cLux_ID_Body(a_idSourceBody);
		
		/////////////////////
		// Ignore sound?
		{
			/////////////////////
			// Boss fight?
			if (mbBossFight_Active)
			{
				return;
			}
			
			/////////////////////
			// Caused by player or scripted?
			if (abIsCausedByPlayer || asSound == "ScriptedEvent")
			{
				if (bIsFootstep && alPrio < 3) return;
			}
			
			/////////////////////
			// Other
			else
			{
				if (alPrio < 3) return;
			}
			
			/////////////////////
			// Physics sound not caused by player?
			if (abIsPhysicsSound && abIsCausedByPlayer == false)
			{
				return;
			}
			
			/////////////////////
			// Only care about very important sounds if last increase was very recent
			if (alPrio < 5 && 
				mfInterest_IncreaseCount < gfStalker_MinTimeBetweenInterestIncrease)
			{
				return;
			}
			
			/////////////////////
			// Alerted?
			if (mbInterest_Alert)
			{
				/////////////////////
				// New sound is far away?
				float fDistToPrevSqr = (mvInterest_AreaPos - avPos).SqrLength();
				if (fDistToPrevSqr > gfStalker_AlertInterestMaxDistBetweenSounds * gfStalker_AlertInterestMaxDistBetweenSounds)
				{
					return;
				}			
				
				/////////////////////
				// Sound is occluded?
				// (If in hole, and player has seen the hole while monster was there)
				if (lState == eStalkerState_WaitInHole)
				{
					iLuxEntity@ pHole = cLux_ID_Entity(m_idWaitInHole_Hole);
					cVector3f vListenerPos = pHole !is null ? pHole.GetPosition() + GetHoleFwd(m_idWaitInHole_Hole) : mBaseObj.GetPosition();	
					
					if (alPrio <= glStalker_IgnoreOccludedSoundMaxPrio &&
						mbWaitInHole_PlayerSeenHole &&
						SoundOcclusion_GetIsPointOccluded(vListenerPos, avPos))
					{
						return;
					}
				}
			}
			
			/////////////////////
			// Player in save room? Ignore!
			if (mbPlayerIsInSaveRoom)
			{
				return;
			}
		}
		
		/////////////////////
		// Get behaviour
		bool bRandomEmerge = false;
		
		if (bGeneratorOn && mbHidden)
		{
			eStalkerInterestIncreaseBehaviour behaviour = Blackboard_GetStalkerInterestIncreaseBehaviour();
			
			if (behaviour == eStalkerInterestIncreaseBehaviour_Alert && mbInterest_Alert == false)
			{
				alPrio = 6;			
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Randomly entering interest alert!");
			}
			
			if (behaviour == eStalkerInterestIncreaseBehaviour_Emerge)
			{
				alPrio = 6;
				bRandomEmerge = true;
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Randomly emerging from interest!");
			}
		}
		
		/////////////////////
		// Decrease radius
		{
			int lDecreaseNumToAlert;
			
			if (alPrio >= 5)		lDecreaseNumToAlert = glStalker_InterestDecreaseNumToAlert * 0.f;
			else if (alPrio == 4)	lDecreaseNumToAlert = glStalker_InterestDecreaseNumToAlert * 0.2f;
			else if (alPrio == 3) 	lDecreaseNumToAlert = glStalker_InterestDecreaseNumToAlert * 0.8f;
			else if (alPrio == 2)  	lDecreaseNumToAlert = glStalker_InterestDecreaseNumToAlert * 1.f;		
			else if (alPrio <= 1)  	lDecreaseNumToAlert = glStalker_InterestDecreaseNumToAlert * 1.2f;			

			switch (Game_GetDifficultyMode())
			{
				case eGameMode_Easy: lDecreaseNumToAlert *= 1.5f; break;
				case eGameMode_Hard: lDecreaseNumToAlert *= 0.75f; break;
			}
			
			lDecreaseNumToAlert = cMath_Max(lDecreaseNumToAlert, 1);
			
			float fDecrease = cMath_Abs(((gfStalker_AlertInterestAreaRadiusMax - 0.1f) - mfInterest_MapRadius)) / lDecreaseNumToAlert;
			
			/////////////////////
			// Footstep?
			if (bIsFootstep)
			{
				fDecrease *= 0.5f;
			}
			
			/////////////////////
			// Lantern?
			else if (asSound == "DynamoLanternCharge")
			{
				if (bGeneratorOn)	fDecrease *= 1.5f;
				else				fDecrease *= 0.25f;
			}
			
			/////////////////////
			// Scrape sound?
			else if (pBody !is null && bIsScrapeSound)
			{
				fDecrease *= (2.f * cMath_Clamp(pBody.GetMass() / 15.f, 0.f, 1.f));
				
				if (bGeneratorOn == false)
					fDecrease *= 0.25f;
			}
			
			/////////////////////
			// Other physics sound?
			else if (abIsPhysicsSound)
			{
				if (bGeneratorOn == false)
					fDecrease *= 0.25f;
			}
			
			/////////////////////
			// Update radius
			mfInterest_AreaRadius -= fDecrease;
		}
		
		/////////////////////
		// Update positon
		mvInterest_AreaPos = avPos;
		
		/////////////////////
		// Below or at alert radius?
		if (mfInterest_AreaRadius <= gfStalker_AlertInterestAreaRadiusMax)
		{
			bool bUpdateBehaviour = true;
			mfInterest_AreaRadius = cMath_Min(mfInterest_AreaRadius, gfStalker_AlertInterestAreaRadiusMax * 0.75f);
			
			/////////////////////
			// Change mode if not in alert!
			if (mbInterest_Alert == false)
			{
				SetInterestAlert(true);
				
				mfWaitInHole_Count = 100.f; // Set a high value so it won't affect hole selection
				
				mfInterest_EmergeCount = 0.f;
				mfInterest_EmergeTime = cMath_RandRectf(gfStalker_MinInterestEmergeTime, gfStalker_MaxInterestEmergeTime);
				
				bUpdateBehaviour = ChangeMode(eStalkerMode_Active, true) == false;
			}
			
			/////////////////////
			// Emerge?
			if (mfInterest_EmergeCount >= mfInterest_EmergeTime || bRandomEmerge)
			{
				if (bRandomEmerge == false)
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Emerging from interest! Count: " + mfInterest_EmergeCount + " Time: " + mfInterest_EmergeTime);
				
				mfInterest_EmergeCount = 0.f;
				mBaseObj.BroadcastMessage(eLuxEntityMessage_SoundHeard, null, mvInterest_AreaPos, 6);
			}
			
			/////////////////////
			// Update mode behaviour?
			else if (bUpdateBehaviour)
			{
				SetupModeBehaviour();
			}
			
			/////////////////////
			// Warning sound
			if (mbHidden)
			{
				InHole_PlayWarningSound(0.3f, false);
			}
		}				

		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Increasing interest! Sound: " + asSound + " Prio: " + alPrio + " Force: " + abForceAlert);
		
		/////////////////////
		// Update vars
		mfInterest_IncreaseCount = 0.f;
		mfInterest_AreaRadius = cMath_Clamp(mfInterest_AreaRadius, gfStalker_MinInterestAreaRadius, mfInterest_MapRadius);
		
		////////////////////
		// Scrape sound? Ignore those for a while
		if (bIsScrapeSound)
		{
			mBaseObj.Timer_Add("Timer_IgnoreScrapeSound", 5.f);
		}
	}
	
	//------------------------------------------------------------
	
	void SetInterestAlert(bool abX)
	{
		if (mbInterest_Alert == abX) return;
		
		//////////////////
		// Setup interest
		mbInterest_Alert = abX;
		
		if (abX)
		{
			mfSoundCounter = 10.f;
			mvStalk_PrevStalkPos = cVector3f(0.f);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Entering interest alert!");
		}
		else
		{
			mfInterest_AreaRadius = mfInterest_MapRadius;
		}
		
		//////////////////
		// Broadcast message
		int lMessage = abX ? eCustomEntityMessage_EnterInterestAlert : eCustomEntityMessage_LeaveInterestAlert;
		mBaseObj.BroadcastMessage(lMessage, null, cVector3f(0.f), 0);
	}
	
	//------------------------------------------------------------
	
	void GetPlayerHideAreaKillAnimData(tID a_idArea, cVector3f &out avStalkerPos, cVector3f &out avPlayerPos, 
									   float &out afStalkerAngle, float &out afPlayerAngle)
	{
		tID idArea = Player_GetCurrentHideArea();
		cLuxArea@ pArea = cLux_ID_Area(idArea);
				
		if (pArea is null) return;
			
		cVector3f vAreaPos = pArea.GetPosition();
		vAreaPos.y = pArea.GetAreaBody().GetBoundingVolume().GetMin().y;
				
		int lAreaKillDir = Player_GetCurrentHideAreaAnimKillDir();
		cVector3f vAreaKillDir;
		cVector3f vToArea = vAreaPos - mBaseObj.GetPosition();
		cMatrixf mtxArea = pArea.GetMatrix().GetTranspose();
				
		switch (lAreaKillDir)
		{
			case eAxis3D_X: vAreaKillDir = mtxArea.GetRight();	 break;
			case eAxis3D_Y: vAreaKillDir = mtxArea.GetUp();		 break;
			case eAxis3D_Z: vAreaKillDir = mtxArea.GetForward(); break;
		}
							
		float fDot = cMath_Vector3Dot(vAreaKillDir, vToArea);
		if (fDot > 0.f)
		{
			avStalkerPos = vAreaPos + vAreaKillDir * -2.5f;
			afStalkerAngle = cMath_GetAngleFromPoints3D(0.f, vAreaKillDir).y;
		}
		else
		{
			avStalkerPos = vAreaPos + vAreaKillDir * 2.5f;
			afStalkerAngle = cMath_GetAngleFromPoints3D(0.f, vAreaKillDir * -1.f).y;
		}
		
		afPlayerAngle = afStalkerAngle + cMath_Pi;
		avPlayerPos = vAreaPos;
	}
	
	//------------------------------------------------------------
	
	void OnStartGetLampsInCurrLevel()
	{
		array<iLuxEntity@> vLamps;
		cLux_GetCurrentMap().GetEntityArray("*", eLuxEntityType_Prop, "cScrPropLamp", vLamps);
		
		mvLampsInCurrentLevel.resize(0);
		
		for (uint i=0; i<vLamps.size(); i++)
		{
			tString sLampName = vLamps[i].GetName();
			if (sLampName == "SaveLamp") continue;
			
			mvLampsInCurrentLevel.push_back(sLampName);
		}
	}
	
	//------------------------------------------------------------
	
	void StopLampFlickerInCurrLevel()
	{
		for (uint i=0; i<mvLampsInCurrentLevel.size(); i++)
		{
			tString sLamp = mvLampsInCurrentLevel[i];
			Lamp_SetFlickerActive(sLamp, false);
		}
	}
	
	//------------------------------------------------------------
	
	bool CheckHeadCollision(const cVector3f &in avHeadPos, bool abCheckDoors)
	{		
		///////////////////
		// Setup vars
		float fHeadRadius = 0.3f;
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		
		if (pCharBody is null) return false;
		if (pPhysicsWorld is null) return false;
		
		///////////////////
		// Create head shape		
		if (mpHeadAdjustment_Shape is null)
		{
			@mpHeadAdjustment_Shape = pPhysicsWorld.CreateSphereShape(fHeadRadius, cMatrixf_Identity);
		}
		
		///////////////////
		// Check static
		cVector3f vPush;
		if (pPhysicsWorld.CheckShapeWorldCollision(vPush, mpHeadAdjustment_Shape, cMath_MatrixTranslate(avHeadPos), pCharBody.GetCurrentBody(), false, true, true, false))
		{
			return true;
		}
		
		///////////////////
		// Check doors
		if (abCheckDoors)
		{
			cVector3f vStart = pCharBody.GetPosition();
			cVector3f vEnd = avHeadPos;
			cVector3f vIntersection(0.f);
			float fT;
			
			for (int j = 0; j < mvDoorAABBs.size(); ++j)
			{
				cStalker_DoorAABB@ pAABB = mvDoorAABBs[j];
				iPhysicsBody@ pBody = pAABB !is null ? cLux_ID_Body(pAABB.m_idBodyId) : null;
				cBoundingVolume@ pBV = pBody !is null ? pBody.GetBoundingVolume() : null;
				
				if (pAABB is null) continue;
				if (pBody is null) continue;
				if (pBV is null) continue;				
				
				if (cMath_CheckAABBSphereCollision(pBV.GetMin(), pBV.GetMax(), avHeadPos, fHeadRadius))
					return true;
				if (cMath_CheckAABBLineIntersection(pBV.GetMin(), pBV.GetMax(), vStart, vEnd, vIntersection, fT))
					return true;
			}
		}
		
		return false;
	}
		
	//------------------------------------------------------------
	
	bool GetIsPropBreakable(cLuxProp@ apProp)
	{
		if (apProp is null) return false;
		if (apProp.GetBreakActive())
		{
			if (apProp.GetDisableBreakable() == false) return true;
			if (apProp.GetClassName() == "cScrPropExplosiveBarrel") return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void BreakProp(cLuxProp@ apProp)
	{
		if (apProp is null) return;
		
		apProp.GiveDamage(apProp.GetMainBody(), mBaseObj.GetPosition(), apProp.GetPosition(), 
						  eDamageType_Default, apProp.GetHealth() + 0.1f, 1, 100.f, 5.f, 
						  mBaseObj.GetID(), mBaseObj.GetMap().GetNewAttackInstanceID());
	}
	
	//------------------------------------------------------------
	
	//} END STALKER HELPERS

	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// STATES
	//=======================================
	/////////////////////////////////////////

	//===========================================================

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: DEFAULT
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_Default_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Default ------");
	}
	
	//------------------------------------------------------------
	
	void State_Default_Leave()
	{
		msAnimState = "";
	}
	
	//------------------------------------------------------------
	
	void State_Default_Update(float afTimeStep) {}

	//------------------------------------------------------------

	bool State_Default_Message(int alMessageId)
	{
		int lState = mpStateMachine.GetCurrentState();
		int lProximityState = mpStateMachine.GetCurrentMessageData().mlX;
		
		//////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player detected");
			
			if (mAlertState == eStalkerAlertState_Detected)
			{
				mpStateMachine.ChangeState(eStalkerState_Hunt);
			}
			else if (mAlertState == eStalkerAlertState_Investigating)
			{
				mpStateMachine.ChangeState(eStalkerState_Alert);
			}
			else
			{
				int lNewState = mBaseObj.GetDistanceToPlayer2D() <= 8.f ? eStalkerState_Alert : eStalkerState_PlayerDetected;
				mpStateMachine.ChangeState(lNewState);
			}
			
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return false;
		}
		
		//////////////////////
		// Player undetected
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player undetected");
			return false;
		}

		/////////////////////
		// Stuck counter high
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh)
		{
			mpStateMachine.ChangeState(eStalkerState_Blocked);
			return true;
		}
		
		/////////////////////
		// Heard sound
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetShouldIgnoreSound()) return true;			
			
			/////////////////////
			// Ignore sounds if we see the player
			if (mBaseObj.PlayerIsDetected() && mAlertState != eStalkerAlertState_None)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Ignoring sound because player is detected");
				return false;
			}
			
			cVector3f vGoal = mpStateMachine.GetCurrentMessageData().mvX;
			int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
			tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
			tID idSourceBody = mpStateMachine.GetCurrentMessageData().mID;
			bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player";
			
			bool bInvestigate = InvestigateSound_RegisterSound(lPrio, vGoal, sSoundName, idSourceBody, true, false, bCausedByPlayer);
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), bInvestigate);
			return false;
		}
		
		/////////////////////
		// Did not hear sound
		if (alMessageId == eLuxEntityMessage_SoundNotHeard)
		{
			if (GetShouldIgnoreSound()) return true;
			
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), false);
		}
		
		/////////////////////
		// Enter proximity
		if (alMessageId == eLuxEntityMessage_EnterProximity)
		{
			if (GetSensesActive() == false) return true;
		}
		
		/////////////////////
		// Leave proximity
		if (alMessageId == eLuxEntityMessage_LeaveProximity)
		{
			if (GetSensesActive() == false) return true;
		}		
		
		/////////////////////
		// Hit by prop
		if (alMessageId == eLuxEntityMessage_HitByProp)
		{
			if (GetSensesActive() == false) return true;		
			if (mbLastHitByPropThrownByPlayer == false) return false;
			if (lState == eStalkerState_Hunt) return false;
			if (mbBossFight_Active && Game_GetDifficultyMode() != eGameMode_Easy) return true;
			
			if (mbLastHitByPropWasMolotov) 
			{
				mbLastHitByPropWasMolotov = false;
				return false;
			}
			
			float fHitSpeed = mpStateMachine.GetCurrentMessageData().mvX.x;
			if (fHitSpeed < 0.75f) return false;

			mbStunned_Stunned = true;
			mpStateMachine.ChangeState(eStalkerState_Stunned);
			
			mbLastHitByPropThrownByPlayer = false;
		}
		
		/////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
		}
		
		/////////////////////
		// Near door
		if (alMessageId == eLuxEntityMessage_NearDoor)
		{
			bool bOpen = mpStateMachine.GetCurrentMessageData().mlX == 1;
			tID idDoor = mpStateMachine.GetCurrentMessageData().mID;
			cLuxProp@ pDoor = cLux_ID_Prop(idDoor);
			tString sDoorName = pDoor !is null ? pDoor.GetName() : "";
			
			if (pDoor is null) return true;
			if (pDoor.GetHealth() <= 0.f && pDoor.GetBreakActive()) return true;
			
			/////////////////////
			// Checks
			tID idBody = SwingDoor_GetDoorBodyID(sDoorName);
			
			if (mBaseObj.GetCharBody().GetMoveSpeed(eCharDir_Forward) < 0.1f) return true;
			if (idDoor == m_idBlockedByProp_Entity) return true;			
			if (SwingDoor_GetOpenableByAgent(sDoorName) == false) return true;
			if (SwingDoor_GetOpenAmount(sDoorName) > 0.3f) return true;
			if (EvaluateObstacle_GetPathBlockerExists(idBody)) return true;
			
			int lNodeCount = mpPathfinder.GetPathNodeCount();
			bool bPathGoesThroughDoor = false;
			iPhysicsBody@ pBody = cLux_ID_Body(idBody);
			cBoundingVolume@ pBV = pBody.GetBoundingVolume();
			
			if (pBody !is null && 
				pBV !is null)
			{			
				cVector3f vStart(0.f);
				cVector3f vEnd(0.f);
				
				if (lNodeCount > 0)
				{
					int lCount = 0;
					while (lCount < 2)
					{
						cVector3f vOffset = cVector3f(0.f, 0.3f, 0.f);
						
						if (lCount == 0)
						{
							cAINode@ pNode = mpPathfinder.GetPathNode(lNodeCount - 1);
							
							vStart = mBaseObj.GetPosition();						
							vEnd = pNode !is null ? pNode.GetPosition() : vStart;
						}
						else if (lCount == 1)
						{
							cAINode@ pNode = lNodeCount > 1 ? mpPathfinder.GetPathNode(lNodeCount - 2) : null;
							cAINode@ pPrevNode = mpPathfinder.GetPathNode(lNodeCount - 1);
							
							vStart = pPrevNode !is null ? pPrevNode.GetPosition() : mBaseObj.GetPosition();
							vEnd = pNode !is null ? pNode.GetPosition() : mpPathfinder.GetGoalPos();
						}
						
						vStart += vOffset;
						vEnd += vOffset;
										
						float fT;
						cVector3f vIntersectPos;
						if (cMath_CheckAABBLineIntersection(pBV.GetMin(), pBV.GetMax(), vStart, vEnd, vIntersectPos, fT))
						{
							bPathGoesThroughDoor = true;
							break;
						}		
						
						++lCount;
					}
				}
				else 
				{
					float fT;
					cVector3f vIntersectPos;
					cVector3f vStartPos = mBaseObj.GetPosition();
					
					if (cMath_CheckAABBLineIntersection(pBV.GetMin(), pBV.GetMax(), vStartPos, vStartPos + mBaseObj.GetCharBody().GetForward(), vIntersectPos, fT))
					{
						bPathGoesThroughDoor = true;
					}					
					else if (mpPathfinder.IsMoving() &&
							 cMath_CheckAABBLineIntersection(pBV.GetMin(), pBV.GetMax(), vStartPos, mpPathfinder.GetNextGoalPos(), vIntersectPos, fT))
					{
						bPathGoesThroughDoor = true;
					}
				}
			}
			
			if (bPathGoesThroughDoor == false) 
				return true;

			/////////////////////
			// Smash through the door if running
			float fDistToDoorSqr = (pDoor.GetPosition() - mBaseObj.GetPosition()).SqrLength();
			bool bSkipOpenDoor = SwingDoor_IsBreakable(sDoorName) && 
								 (fDistToDoorSqr > 1.7f * 1.7f || GetIsRunningQuickly());
			if (bSkipOpenDoor)
			{
				if (fDistToDoorSqr <= 1.7f * 1.7f && GetIsRunningQuickly())
					BreakPropWhileRunning(pDoor);
				
				return true;
			}
			
			/////////////////////
			// Open door?
			else
			{
				SetPreBlockedState(lState);		
				m_idBlockedByProp_Entity = idDoor;				
				mpStateMachine.ChangeState(eStalkerState_BlockedByProp);
			}		
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Near door '" + sDoorName + "', open: " + bOpen);
		}	
				
		/////////////////////
		// Flashlight detection
		if (mbDetectFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			/////////////////////
			// See gobo
			if (alMessageId == eCustomEntityMessage_SeeFlashlightGobo)
			{
				mvGoboPos = mpStateMachine.GetCurrentMessageData().mvX;
				mfGoboCount += 0.15f;
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Detect flashlight gobo");
			}
			
			/////////////////////
			// Detect gobo
			else if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
			{
				mvPlayerLightDetected_InterestPos = mpStateMachine.GetCurrentMessageData().mvX;
				
				if (mbPlayQuickTurnAnim)
					mlQuickTurnDoneState = eStalkerState_PlayerLightDetected;
				else
					mpStateMachine.ChangeState(eStalkerState_PlayerLightDetected);				
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Detect flashlight gobo");
			}
			
			/////////////////////
			// Hit by flashlight
			else if (alMessageId == eCustomEntityMessage_HitByFlashlight)
			{
				if (mBaseObj.GetDistanceToPlayer2D() <= 10.f)
				{
					mfHitByFlashlightCount += 1.f;
					
					mvPlayerLightDetected_InterestPos = mpStateMachine.GetCurrentMessageData().mvX;
					
					if (mbPlayQuickTurnAnim)
						mlQuickTurnDoneState = eStalkerState_PlayerLightDetected;
					else
						mpStateMachine.ChangeState(eStalkerState_PlayerLightDetected);
					
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hit by flashlight");
				}
			}
		}
		
		///////////////////
		// Player fired gun
		if (alMessageId == eCustomEntityMessage_PlayerShotGun)
		{
			if (GetSensesActive() == false) return true;
			if (mbHurt_RecentlyHurt) return true;
			
			/////////////////////
			// Investigate sound!
			if (mAlertState != eStalkerAlertState_Detected)
			{	
				mBaseObj.GetMap().BroadcastSoundHeardEvent("Gunshot", mBaseObj.GetPlayerPos(), 500.f, 6, false, true);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Heard gunshot");
			}
		}
		
		///////////////////
		// Generator turned on
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn)
		{	
			if (mbPlayerIsInSaveRoom) return true;
			
			///////////////////
			// Enter passive
			ChangeMode(eStalkerMode_Passive, true);
						
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Generator turned on, entering passive!");	
		}
		
		///////////////////
		// Generator turned off
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff)
		{				
			bool bGeneratorTurnedOffRecently = mBaseObj.Timer_Exists(gsStalker_GeneratorTurnedOffTimer);
			mBaseObj.Timer_Add(gsStalker_GeneratorTurnedOffTimer, 60.f);
			
			if (mbPlayerIsInSaveRoom) return true;
			if (mbHurt_RecentlyHurt) return true;
			
			///////////////////
			// Enter active
			if (ChangeMode(eStalkerMode_Active, true) == false)
				SetupModeBehaviour();

			///////////////////
			// Play roar!
			if (bGeneratorTurnedOffRecently == false)
			{
				mBaseObj.Timer_Add("Timer_PlayGeneratorOffRoar", cMath_RandRectf(2.f, 3.f), "OnTimer_PlayGeneratorOffRoar");
			}
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Generator turned off, entering active!");	
		}
		
		/////////////////////
		// Grenade impact
		if (alMessageId == eCustomEntityMessage_GrenadeImpact)
		{			
			cVector3f vImpactPos = mpStateMachine.GetCurrentMessageData().mvX;			
			cVector3f vMin = vImpactPos - cVector3f(0.5f);
			cVector3f vMax = vImpactPos + cVector3f(0.5f);
			
			array<iPhysicsBody@> vBodies;
			mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(vMin, vMax, true, false, vBodies);
			
			for (int i = 0; i < vBodies.size(); ++i)
			{
				iPhysicsBody@ pBody = vBodies[i];
				iLuxEntity@ pEnt = cLux_GetBodyEntity(pBody);
				
				if (pEnt is null) 									continue;
				if (pEnt.GetEntityType() != eLuxEntityType_Prop) 	continue;
				if (pEnt.GetClassName() != "cScrPropGrenade")		continue;
				if (mvTrackedGrenades.find(pEnt.GetID()) != -1)		continue;
				
				mvTrackedGrenades.push_back(pEnt.GetID());
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Tracking grenade: " + pEnt.GetName());
				break;				
			}
		}
		
		///////////////
		// Grenade detected
		if (alMessageId == eCustomEntityMessage_GrenadeDetected)
		{
			// TODO: Run or something?			
		}
		
		///////////////
		// Player enter save room
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom)
		{
			mbPlayerIsInSaveRoom = true;
			
			if (mfPlayerLeftSaveRoomCount <= 0.f)
				mbWasInActiveModeWhenPlayerEnteredSaveRoom = mMode == eStalkerMode_Active;
			
			mfPlayerLeftSaveRoomCount = 0.f;
			
			InvestigateSound_ResetVars();
			SetPreBlockedState(eStalkerState_Idle);
			
			SetInterestAlert(false);
			ChangeMode(eStalkerMode_Passive, false);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player entered save room!");
		}
		
		///////////////
		// Player leave save room
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom)
		{
			mbPlayerIsInSaveRoom = false;
			mfPlayerLeftSaveRoomCount = 60.f * 3.f;
		}
		
		///////////////
		// Rabbit doll attract
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract)
		{
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;			
			if (ExamineRabbit_Setup(vPos))
			{
				mpStateMachine.ChangeState(eStalkerState_ExamineRabbit);
			}			
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void OnTimer_PlayGeneratorOffRoar(uint64 alId)
	{
		bool bPlay = mbPlayerIsInSaveRoom == false &&
					 mBaseObj.GetDistanceToPlayer() > 20.f &&
					 (mbHidden || 
					  mBaseObj.CheckIsOnScreen(true) == false);
		
		if (bPlay)
		{
			cSoundEntity@ pSound = mBaseObj.PlaySound("Sound_Roar", gsStalkerSound_GeneratorOff, true, true);
			
			if (mbHidden && pSound !is null)
				SoundOcclusion_AddForceOccludedSound(pSound.GetID());
		}
	}
	
	//------------------------------------------------------------

	//} END DEFAULT

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: IDLE
	//{////////////////////////////////
	
	//-----------------------------------------------------------
	
	bool mbIdle_ActivateSensesOnLeave = false;
	float mfIdle_CutsceneAnimFadeTime = 0.3f;
	tString msIdle_CutsceneAnim = "";
	tString msIdle_CutsceneAnimEnt = "";
	tString msIdle_CutsceneStartedCallback = "";
	
	//-----------------------------------------------------------
	
	void State_Idle_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Idle ------");
		
		SetAlertState(eStalkerAlertState_None);
		
		mpPathfinder.Stop();
		
		//////////////////
		// Play cutscene?
		if (msIdle_CutsceneAnim != "")
		{
			iLuxEntity@ pEnt = mBaseObj.GetMap().GetEntityByName(msIdle_CutsceneAnimEnt);
			if (pEnt !is null)
			{
				cMatrixf mtxEnt = pEnt.GetMatrix();
				cVector3f vPos = mtxEnt.GetTranslation();		
				cVector3f vFwd = mtxEnt.GetTranspose().GetForward();
				float fAngle = cMath_GetAngleFromPoints3D(0.f, vFwd).y;
		
				PlayCutsceneAnimation(msIdle_CutsceneAnim, false, mfIdle_CutsceneAnimFadeTime, "", 1.f, 0.f, true, vPos, fAngle, false, true, false);
				
				mbIdle_ActivateSensesOnLeave = mBaseObj.GetSensesActive();
				mBaseObj.SetSensesActive(false);
				
				if (msIdle_CutsceneStartedCallback != "")
				{
					cLuxMap@ pMap = mBaseObj.GetMap();
					tString sFunc = "void " + msIdle_CutsceneStartedCallback + "(const tString &in asAnim)";
					
					if (pMap.ScriptMethodExists(sFunc) && pMap.ScriptPrepare(sFunc))
					{
						pMap.SetArgString(0, msIdle_CutsceneAnim);
						pMap.ScriptExecute();
					}
				}
			}
		}
		
		//////////////////
		// Decide behavior
		mpStateMachine.AddTimer("DecideBehaviour", 0.0f);
	}

	//------------------------------------------------------------

	void State_Idle_Leave()
	{
		mfIdle_CutsceneAnimFadeTime = 0.3f;
		msIdle_CutsceneAnim = "";
		msIdle_CutsceneAnimEnt = "";
		msIdle_CutsceneStartedCallback = "";
		
		if (mbIdle_ActivateSensesOnLeave)
			mBaseObj.SetSensesActive(true);
		
		mbIdle_ActivateSensesOnLeave = false;
	}
	
	//------------------------------------------------------------
	
	void State_Idle_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------
	
	bool State_Idle_Message(int alMessageId)
	{
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_Idle_TimerUp(uint64 alId)
	{
		if (alId == H64("DecideBehaviour"))
		{
			if (mbCutsceneAnimation_Active)
			{
				mpStateMachine.AddTimer("DecideBehaviour", 0.01f);
				return;
			}
			
			Idle_DecideBehaviour();
			mpStateMachine.AddTimer("DecideBehaviour", 0.2f);
		}
	}
	
	//------------------------------------------------------------
	
	void Idle_DecideBehaviour()
	{				
		//////////////
		// Active
		if (mMode == eStalkerMode_Active)
		{
			//////////////////
			// Generator on? Return to hole!
			if (Generator_GetState() == eGeneratorState_On)
			{
				if (mAlertState == eStalkerAlertState_None &&
					mbHidden == false)
				{
					m_idReturnToHole_Hole = GetHoleWithShortestPathToPos(mBaseObj.GetPosition());
					if (m_idReturnToHole_Hole == tID_Invalid)
						m_idReturnToHole_Hole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition());
					
					mpStateMachine.ChangeState(eStalkerState_ReturnToHole);		
				}
			}
			
			//////////////////
			// Generator off? Stalk!
			else
			{
				mpStateMachine.ChangeState(eStalkerState_Stalk);
			}
		}
		
		//////////////
		// Passive
		else if (mMode == eStalkerMode_Passive)
		{
			//////////////////
			// Return to hole!
			if (mAlertState == eStalkerAlertState_None &&
				mbHidden == false)
			{
				mpStateMachine.ChangeState(eStalkerState_ReturnToHole);		
			}
		}
	}
    
	//------------------------------------------------------------

	//} END STATE: IDLE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: EMERGE
	//{////////////////////////////////

	//------------------------------------------------------------
	
	bool mbEmerge_Hurt = false;
	bool mbEmerge_InvestigateSound = false;
	bool mbEmerge_EmergeAttack = false;
	bool mbEmerge_SearchArea = false;
	bool mbEmerge_SitAndWait = false;
	int mlEmerge_HitTimesToBreakBlockage = -1;
	int mlEmerge_LastTimeStamp = -1;
	float mfEmerge_KnockDownPlayerAnimAngle = 0.f;
	int mlEmerge_KnockDownPlayerDir = 0;
	cVector3f mvEmerge_KnockDownPlayerAnimPos = cVector3f(0.f);
	eStalkerThrowPlayerType mEmerge_KnockDownPlayerType = eStalkerThrowPlayerType_Forward;
	tID m_idEmerge_Hole = tID_Invalid;
	tID m_idEmerge_BlockedHoleBody = tID_Invalid;
	tID m_idEmerge_LastEmergeHole = tID_Invalid;
	array<tID> mvEmerge_KnownBlockedHoles;
	
	//------------------------------------------------------------

    void State_Emerge_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Emerge ------", false, true);
			
		/////////////////
		// Setup		
		if (m_idEmerge_Hole == tID_Invalid)
		{
			mpStateMachine.ChangeState(eStalkerState_WaitInHole);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Coldn't find emerge hole, return to WaitInHole!");
			return;
		}
		
		/////////////////
		// Hole blocked?
		m_idEmerge_BlockedHoleBody = tID_Invalid;
		
		if (Emerge_GetIsKnownBlockedHole(m_idEmerge_Hole) == false && 
			GetIsHoleBlocked(m_idEmerge_Hole, m_idEmerge_BlockedHoleBody))
		{			
			Emerge_AddKnownBlockedHole(m_idEmerge_Hole);
			
			/////////////////
			// Random chance of actually breaking the blockage and emerging
			// (Always break it if going to last known pos through holes!)
			mlEmerge_HitTimesToBreakBlockage = -1;			
			
			float fBreakBlockageChance;
			int lBreakBlockageHitNum;
			
			switch (Blackboard_GetStalkerEscalation())
			{
				case eStalkerEscalation_None:
				{
					fBreakBlockageChance = 0.05f;
					lBreakBlockageHitNum = cMath_RandRectl(2, 3);
					break;
				}
				case eStalkerEscalation_Stage1:
				{
					fBreakBlockageChance = 0.15f;
					lBreakBlockageHitNum = cMath_RandRectl(2, 3);
					break;
				}
				case eStalkerEscalation_Stage2:
				{
					fBreakBlockageChance = 0.30f; 
					lBreakBlockageHitNum = cMath_RandRectl(1, 2);
					break;
				}
				case eStalkerEscalation_Stage3:
				{
					fBreakBlockageChance = 0.80f;
					lBreakBlockageHitNum = cMath_RandRectl(1, 1);
					break;
				}
			}
					
			bool bBreakBlockage = fBreakBlockageChance >= cMath_RandRectf(0.f, 1.f);
			
			if (bBreakBlockage || 
				mbRetreat_GoToLastKnownPlayerPosThroughHoles || 
				mbRetreat_TakingShortcut)
			{
				mlEmerge_HitTimesToBreakBlockage = lBreakBlockageHitNum;
			}
			
			/////////////////
			// Hit the blocker
			mpStateMachine.AddTimer("PushBlockerBody", cMath_RandRectf(0.1f, 0.4f));
			return;
		}
		else
		{
			Emerge_ClearKnownBlockedHoles();
		}
		
		/////////////////
		// Prepare emerge!
		SetAlertState(eStalkerAlertState_None);		
		Emerge_PrepareEmerge();
		
		/////////////////
		// Reset ignored props!
		mvEvaluateObstacle_IgnoredProps.resize(0);
	}
	
	//------------------------------------------------------------

	void State_Emerge_Leave()
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		pCharBody.SetActive(true);
		pCharBody.SetGravityActive(true);
		
		m_idEmerge_Hole = tID_Invalid;
		mbEmerge_Hurt = false;
		mbEmerge_EmergeAttack = false;
		mbEmerge_InvestigateSound = false;
		mlEmerge_HitTimesToBreakBlockage = -1;
		mbEmerge_SearchArea = false;
		mbProximityDetectionActive = true;
		mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
		mbRetreat_TakingShortcut = false;
		mbEmerge_SitAndWait = false;
		mfEmerge_KnockDownPlayerAnimAngle = 0.f;
		mlEmerge_KnockDownPlayerDir = 0;
		mvEmerge_KnockDownPlayerAnimPos = cVector3f(0.f);
		mEmerge_KnockDownPlayerType = eStalkerThrowPlayerType_Forward;
		
		mlEmerge_LastTimeStamp = mBaseObj.GetMap().GetTimeStamp();
		
		if (mpStateMachine.GetNextState() != eStalkerState_Alert)
			mvAlert_PlayerDir = cVector3f(0.f);
		
		//////////////////////
		// Reset pre blocked state, clean slate when emerging!
		SetPreBlockedState(eStalkerState_Idle);
		
		Terror_RemoveEnemy(mBaseObj.GetID());
	}
	
	//------------------------------------------------------------

	void State_Emerge_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Emerge_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_SoundNotHeard) return false;
		if (alMessageId == eCustomEntityMessage_PlayerShotGun) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		//////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{			
			bool bLookAroundAnimJustStarted = mpStateMachine.TimerExists("LookAroundJustStarted");
			
			//////////////////////
			// Emerged?
			if (msAnimState == "InitialEmerge")
			{
				bool bHunt = mBaseObj.GetDistanceToPlayer() < 5.f && GetPlayerIsInLoS(true, false); 
				
				//////////////////////
				// Hurt?
				if (mbEmerge_Hurt)
				{
					Emerge_DecidePostEmergeBehaviour();
				}
				
				//////////////////////
				// Emerge attack?
				else if (mbEmerge_EmergeAttack)
				{
					Emerge_DecidePostEmergeBehaviour();
				}
				
				//////////////////////
				// Enter hunt?
				else if (bHunt) 
				{
					mpStateMachine.ChangeState(eStalkerState_Hunt);
				}
				
				//////////////////////
				// Investigate sound?
				else if (mbEmerge_InvestigateSound)
				{
					Emerge_DecidePostEmergeBehaviour();
				}
				
				//////////////////////
				// Have a look around!
				else
				{
					mpStateMachine.AddTimer("LookAround", 0);
					mpStateMachine.AddTimer("LookAroundJustStarted", 0.5f);
				}
				
				//////////////////////
				// Map callback
				cLuxMap@ pMap = mBaseObj.GetMap();
				tString sCallback = "void OnStalkerEmerge()";
				
				if (pMap !is null && 
					pMap.ScriptMethodExists(sCallback) &&
					pMap.ScriptPrepare(sCallback))
				{
					pMap.ScriptExecute();
				}
			}
			else if (msAnimState == "LookAround" && bLookAroundAnimJustStarted == false)
			{
				Emerge_DecidePostEmergeBehaviour();
			}
			
			if (bLookAroundAnimJustStarted == false)
				msAnimState = "";
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Emerge anim over!");
			return true;
		}
		
		//////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			if (msAnimState != "InitialEmerge") return true;
			
			Terror_AddEnemy(mBaseObj.GetID(), gfStalker_AlertTime);
			return true;
		}
		
		//////////////////////
		// Player undetected
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			Terror_RemoveEnemy(mBaseObj.GetID());
			return true;
		}
		
		//////////////////////
		// Sound heard
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetShouldIgnoreSound()) return true;
			if (mBaseObj.PlayerIsDetected()) return true;

			int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;
			tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
			tID idSourceBody = mpStateMachine.GetCurrentMessageData().mID;
			bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player";
			
			if (lPrio < 3 && mbRetreat_GoToLastKnownPlayerPosThroughHoles) return true;
			
			mbEmerge_InvestigateSound = true;
			
			IncreaseSoundCounter(lPrio);
				
			bool bInvestigate = InvestigateSound_RegisterSound(lPrio, vPos, sSoundName, idSourceBody, false, true, bCausedByPlayer);
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), bInvestigate);	
			
			mBaseObj.PlaySound("SoundHeard", gsStalkerSound_SoundHeard, true, true);			
			return true;
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Emerge_TimerUp(uint64 alId)
	{
		////////////////////////
		// Enable player detection
		if (alId == H64("EnablePlayerDetection"))
		{
			mBaseObj.SetUpdatePlayerDetection(true);
			mBaseObj.ResetPlayerDetectionState();
		}
		
		////////////////////////
		// Have a look around!
		else if (alId == H64("LookAround"))
		{
			float fMaxDist = mbEmerge_SitAndWait ? 20.f : -1.f;
			mBaseObj.PlaySound("LookAround", gsStalkerSound_LookAround, true, true, -1.f, fMaxDist);
			
			msAnimState = "LookAround";
			mpMover.PlayAnimation(gsStalkerAnim_LookAroundLong, 0.3f, false);
		}
		
		////////////////////////
		// Push props blocking hole
		else if (alId == H64("PushPropsInFrontOfHole"))
		{
			cLuxArea@ pArea = cLux_ID_Area(m_idEmerge_Hole);
			if (pArea is null) return;
			
			////////////////////////
			// Get bodies in front of hole
			cBoundingVolume@ pBounds = pArea.GetAreaBody().GetBoundingVolume();			
			array<iPhysicsBody@> vBodies;
			mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(pBounds.GetMin(), pBounds.GetMax(), true, false, vBodies);
			
			for (uint i = 0; i < vBodies.size(); ++i)
			{
				iPhysicsBody@ pBody = vBodies[i];
				cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
				
				if (pBody is null) continue;
				if (pProp is null) continue;
				if (pProp.IsActive() == false) continue;
				if (pBody.GetMass() == 0.f) continue;
				if (pBody.IsCharacter()) continue;
				if (pProp.GetIsDoor()) continue;
				
				////////////////////////
				// Break if possible
				if (GetIsPropBreakable(pProp))
				{
					BreakProp(pProp);
				}
				
				////////////////////////
				// Otherwise, push away!
				else
				{
					iPhysicsBody@ pMainBody = pProp.GetMainBody();
					
					cVector3f vFwd = pArea.GetMatrix().GetTranspose().GetForward();				
					cVector3f vImpulse = cMath_MatrixMul(cMath_MatrixRotateY(cMath_RandRectf(-cMath_PiDiv4, cMath_PiDiv4)), vFwd) * cMath_RandRectf(5.f, 6.f);
					vImpulse += cVector3f_Up;
					
					pMainBody.AddImpulse(vImpulse);
					pMainBody.AddTorque(cMath_RandomSphereSurfacePoint(cMath_RandRectf(75.f, 100.f)));	
				}
			}
		}
		
		////////////////////////
		// Push blocker body in front of hole
		else if (alId == H64("PushBlockerBody"))
		{
			////////////////////////
			// Give the blocker a little push
			cLuxArea@ pArea = cLux_ID_Area(m_idEmerge_Hole);
			iPhysicsBody@ pBody = cLux_ID_Body(m_idEmerge_BlockedHoleBody);
			bool bIsDamageArea = Blackboard_GetIsBodyDamageArea(pBody);
			
			if (pArea !is null && pBody !is null)
			{
				if (bIsDamageArea == false)
				{
					cVector3f vFwd = pArea.GetMatrix().GetTranspose().GetForward();				
					cVector3f vImpulse = cMath_MatrixMul(cMath_MatrixRotateY(cMath_RandRectf(-cMath_PiDiv4, cMath_PiDiv4)), vFwd) * cMath_RandRectf(0.5f, 1.f);
						
					pBody.AddImpulse(vImpulse);
					
					mBaseObj.PlaySound("Sound_FrustratedScream", "creatures/stalker/attack", true, false);
					mBaseObj.PlaySound("Sound_HitHoleBlocker", "level_entity_shared/item_break/door/impact", true, false);
				}
			}
			
			////////////////////////
			// Can't break it, return to wait in hole
			if (bIsDamageArea || mlEmerge_HitTimesToBreakBlockage == -1)
			{
				if (mlEmerge_HitTimesToBreakBlockage == -1 && Achievement_GetUnlocked(eAchievement_CutItOff) == false)
				{	
					iLuxEntity@ pBlockingEnt = Map_GetEntity(Body_GetEntityName(pBody.GetName()));
					float fMoveDist = (pBlockingEnt.GetBasePosition()-pBlockingEnt.GetOnLoadTransform().GetTranslation()).Length();
					
					// Use distance to original position to determine if the blockage is caused by the player or not
					if (fMoveDist > 0.5f)
						Achievement_Unlock(eAchievement_CutItOff);
				}
					
				mpStateMachine.AddTimer("ReturnToWaitInHole", cMath_RandRectf(0.75f, 1.f));		
			}
			
			////////////////////////
			// Hit it a few times, then emerge!
			else
			{
				--mlEmerge_HitTimesToBreakBlockage;
				if (mlEmerge_HitTimesToBreakBlockage > 0)
					mpStateMachine.AddTimer("PushBlockerBody", cMath_RandRectf(1.f, 1.25f));		
				else
					mpStateMachine.AddTimer("PrepareEmerge", cMath_RandRectf(1.f, 1.25f));
			}
		}
		
		////////////////////////
		// Return to wait in hole
		else if (alId == H64("ReturnToWaitInHole"))
		{			
			mpStateMachine.ChangeState(eStalkerState_WaitInHole);			
			
			cSoundEntity@ pSound = mBaseObj.PlaySound("Sound_BlockedFromEmerging", gsStalkerSound_Frustration, true, true);
			if (pSound !is null)
				SoundOcclusion_AddForceOccludedSound(pSound.GetID());
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hole is blocked, return to WaitInHole");
		}
		
		////////////////////////
		// Prepare emerge
		else if (alId == H64("PrepareEmerge"))
		{
			Emerge_PrepareEmerge();
		}
		
		////////////////////////
		// Knock down player
		else if (alId == H64("KnockDownPlayer"))
		{
			ThrowPlayer_ThrowPlayerWhileInCutscene(mEmerge_KnockDownPlayerType, mvEmerge_KnockDownPlayerAnimPos, 
												   mfEmerge_KnockDownPlayerAnimAngle, 0.5f);
		}
	}
	
	//------------------------------------------------------------
	
	void Emerge_PrepareEmerge()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Emerge from: "+ cLux_ID_Entity(m_idEmerge_Hole).GetName());
		Entity_CreateAtEntityExt("gen_1", "generator.ent", "crate_military_exupery_2", true, cVector3f(0.5, 0.5, 0.5), cVector3f(0, 0, 0), cVector3f(0, 0, 0), true);
		Entity_SetCollideCharacter("gen_1", false);
		Entity_AttachToSocket("gen_1", "Stalker_1", "Socket_Head", true, true);
		
		/////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();	
		mbProximityDetectionActive = false;
		m_idEmerge_LastEmergeHole = m_idEmerge_Hole;
		
		/////////////////
		// Enable hearing
		mpSoundListener.SetHearRadius(mfHearRadius);
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);
		
		/////////////////
		// Stop movement
		mpPathfinder.Stop();
		mpMover.StopTurning();
		pCharBody.StopMovement();
		
		/////////////////
		// Place at hole
		SetHidden(false);
		PositionAtGhoulHole(m_idEmerge_Hole);
		
		//////////////
		// Player at hole, kill or knock down?
		bool bKnockDownPlayer = false;
		bool bPlayerByHole = mBaseObj.GetDistanceToPlayer() < gfStalker_MaxAttackPlayerDistHole &&
							 cMath_Abs(mBaseObj.GetPlayerPos().y - mBaseObj.GetPosition().y) < 1.5f;
		
		mbEmerge_EmergeAttack = bPlayerByHole; 
		
		if (mbEmerge_EmergeAttack)
		{
			if (Emerge_GetShouldKillPlayer() && 
				(GetIsHoleBlocked(m_idEmerge_Hole, m_idEmerge_BlockedHoleBody) == false || mbEmergeAllowed == false))
			{
				cScript_SetGlobalVarBool(gsStalker_PlayerHasBeenAttackedOnEmergeVar, true);
				
				msAnimState = "";
				
				mbKillPlayer_PlayHoleAnimation = true;
				m_idKillPlayer_HoleId = m_idEmerge_Hole;
				mpStateMachine.ChangeState(eStalkerState_KillPlayer);
				
				SetHidden(true); // Hide again, so it doesn't pop in for one frame before the anim starts
				return;
			}
			else
			{
				bKnockDownPlayer = true;
				
				Emerge_SetupKnockDownPlayer();
				mpStateMachine.AddTimer("KnockDownPlayer", 0.3f);
				
				cScript_SetGlobalVarBool(gsStalker_PlayerHasBeenAttackedOnEmergeVar, true);
			}
		}
		
		///////////////
		// Get hole data
		float fAngle = GetHoleAngle(m_idEmerge_Hole);
		cVector3f vFwd = GetHoleFwd(m_idEmerge_Hole);
		cVector3f vRight = GetHoleRight(m_idEmerge_Hole);
		cVector3f vPos = GetHoleGroundPos(m_idEmerge_Hole);	
		cVector3f vSoundPos = vPos + cVector3f_Up * 0.5f + vFwd * 0.25f;
		
		//////////////
		// Get anim
		bool bTurnAnim = false;
		tString sAnim = gsStalkerAnim_ExitHole;
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		
		if (bKnockDownPlayer)
		{			
			switch (mlEmerge_KnockDownPlayerDir)
			{
				case 1:
				{
					bTurnAnim = true;
					sAnim = gsStalkerAnim_ExitHoleTurnRight;
					break;
				}
				case 2:
				{
					bTurnAnim = true;
					sAnim = gsStalkerAnim_ExitHoleTurnLeft;
					break;
				}
				default:
				{
					sAnim = gsStalkerAnim_ExitHole;
					break;
				}
			}
		}
		else if (pPhysicsWorld !is null)
		{
			iCollideShape@ pShape = pPhysicsWorld.CreateSphereShape(0.75f, cMatrixf_Identity);
			cMatrixf mtxShape = cMath_MatrixTranslate(vPos + cVector3f(0.f, 1.f, 0.f) + vFwd * 1.75f);	
			
			cVector3f vPush;
			if (pPhysicsWorld.CheckShapeWorldCollision(vPush, pShape, mtxShape, null, false, true, true, false))
			{
				bTurnAnim = true;
				
				//////////////////////
				// Get likely position stalker will move to after emerging
				cVector3f vGoalPos = cVector3f(0.f);
				cVector3f vNextGoalPos = cVector3f(0.f);
			
				if (mbEmerge_EmergeAttack)
					vGoalPos = mBaseObj.GetPlayerPos();
				else if (mbEmerge_InvestigateSound)
					vGoalPos = mvInvestigateSound_Goal;
				else if (mbRetreat_GoToLastKnownPlayerPosThroughHoles)
					vGoalPos = mBaseObj.GetLastKnownPlayerPos();
				else if (mbRetreat_TakingShortcut)
					vGoalPos = mvRetreat_ShortcutTarget;
				else if (mbEmerge_SitAndWait)
					vGoalPos = mvSitAndWait_Pos + mvSitAndWait_Dir * 1.f;
				
				if (vGoalPos.SqrLength() > 0.f && 
					mpPathfinder.BuildPathNodeArrayFromTo(vPos, vGoalPos, 1))
				{
					if (mpPathfinder.GetPathNodeArraySize() > 1)
						vNextGoalPos = mpPathfinder.GetPathNodeArrayNode(1).GetPosition();
					else
						vNextGoalPos = vGoalPos;
				}
				
				//////////////////////
				// Get animation based on goal position
				if (vNextGoalPos.SqrLength() > 0.f)
				{
					cVector3f vToNextGoal = cMath_Vector3Normalize(vNextGoalPos - vPos);
					if (cMath_Vector3Dot(vRight, vToNextGoal) > 0.f)
						sAnim = gsStalkerAnim_ExitHoleTurnLeft;
					else
						sAnim = gsStalkerAnim_ExitHoleTurnRight;
				}
				else
				{
					sAnim = cMath_RandRectl(0, 1) == 1 ? gsStalkerAnim_ExitHoleTurnLeft : gsStalkerAnim_ExitHoleTurnRight;
				}
			}	

			if (pShape !is null)
				pPhysicsWorld.DestroyShape(pShape);
		}		

		//////////////
		// Play anim
		vPos += vFwd * (bTurnAnim ? 0.936f : 1.536f);
		vPos += cVector3f_Up * 0.005f;				
		PlayCutsceneAnimation(sAnim, false, 0.f, "", 1.f, 0.f, true, vPos, fAngle, false, true, false);
		
		msAnimState = "InitialEmerge";
		
		//////////////
		// Push props in front of hole
		mpStateMachine.AddTimer("PushPropsInFrontOfHole", 0.2f);
		
		/////////////////
		// Disable player detection for a little while
		mBaseObj.SetUpdatePlayerDetection(false);
		
		cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(sAnim);
		float fDetectionDelay = pAnim !is null ? pAnim.GetLength() - 0.5f : 1.f;
		mpStateMachine.AddTimer("EnablePlayerDetection", fDetectionDelay);
		
		//////////////
		// Particles
		Emerge_DoEmergeParticles(m_idEmerge_Hole);
		
		//////////////
		// Sounds
		float fMinDist = 2.f;
		float fMaxDist = 50.f;
		bool bPlayRoar = true;
		
		if (mbEmerge_SitAndWait &&
			cLux_CheckLineOfSight(mBaseObj.GetPlayerHeadPos(), vPos + cVector3f(0.f, 1.f, 0.f), false, false) == false)
		{
			bPlayRoar = false;
			fMaxDist = 20.f;
		}
		
		cSoundEntity@ pSoundEmergeFoley = mBaseObj.PlaySound("EmergeFoleySound", gsStalkerSound_CrawlOutFoley, true, false, fMinDist, fMaxDist);
		if (pSoundEmergeFoley !is null)
			pSoundEmergeFoley.SetWorldPosition(vSoundPos);
		
		StalkerRumbleEffect(8.f, 0.25, 1.5f);
		
		if (bPlayRoar)
		{
			mBaseObj.PlaySound("EmergeSound", gsStalkerSound_CrawlOut, true, false, fMinDist, fMaxDist);
		}
	}
	
	//------------------------------------------------------------
	
	bool Emerge_GetShouldKillPlayer()
	{
		bool bFirstTime = cScript_GetGlobalVarBool(gsStalker_PlayerHasBeenAttackedOnEmergeVar) == false;
		if (mbEmergeAllowed &&
			(bFirstTime || Player_GetRunning() || cLux_GetGodModeActivated()))
		{
			return false;
		}
		
		return true;	
	}
	
	//------------------------------------------------------------
	
	void Emerge_DecidePostEmergeBehaviour()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Decide post emerge behaviour:");
		
		////////////////////
		// Hurt?
		if (mbEmerge_Hurt)
		{
			mbEmerge_Hurt = false;
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
			mbRetreat_TakingShortcut = false;
			mpStateMachine.ChangeState(eStalkerState_Hurt);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hurt!");
			return;
		}
		
		////////////////////
		// Player spotted?
		if (mBaseObj.PlayerIsDetected())
		{
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
			mbRetreat_TakingShortcut = false;
			mpStateMachine.ChangeState(eStalkerState_Alert);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Alert!");
			return;
		}
		
		////////////////////
		// Emerge attack?
		if (mbEmerge_EmergeAttack)
		{
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
			mbRetreat_TakingShortcut = false;
			mpStateMachine.ChangeState(eStalkerState_Alert);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Alert!");
			return;
		}
		
		////////////////////
		// Investigate sound?
		if (mbEmerge_InvestigateSound)
		{
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
			mbRetreat_TakingShortcut = false;
			mpStateMachine.ChangeState(eStalkerState_InvestigateSound);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Investigate sound!");
			return;
		}
		
		////////////////////
		// Investigate last known pos?
		if (mbRetreat_GoToLastKnownPlayerPosThroughHoles)
		{
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
			mpStateMachine.ChangeState(eStalkerState_CheckLastKnownPosition);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Check last known pos!");
			return;
		}
		
		////////////////////
		// Continue prev behavior
		if (mbRetreat_TakingShortcut)
		{
			mbRetreat_TakingShortcut = false;
			mpStateMachine.ChangeState(mlRetreat_ShortcutState);
			
			if (mlRetreat_ShortcutState == eStalkerState_Stalk)
			{
				mvStalk_PrevStalkPos = mvRetreat_ShortcutTarget;
			}
			else
			{
				mpPathfinder.MoveTo(mvRetreat_ShortcutTarget, 1.f, false);
			}			
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Shortcut!");
			return;
		}
		
		////////////////////
		// Search area?
		if (mbEmerge_SearchArea)
		{
			mbEmerge_SearchArea = false;
			mvSearchArea_SearchPos = mBaseObj.GetPosition() + GetHoleFwd(m_idEmerge_Hole) * 3.f;
			mpStateMachine.ChangeState(eStalkerState_SearchArea);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Search area!");
			return;
		}
		
		////////////////////
		// Sit and wait?
		if (mbEmerge_SitAndWait)
		{
			mbEmerge_SitAndWait = false;
			mpStateMachine.ChangeState(eStalkerState_SitAndWait);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Sit and wait!");
			return;
		}
		
		////////////////////
		// No nodes? Enter hole again
		if (mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition(), 0.f, 5.f, false, false, false, null) is null)
		{
			mReturnToHole_Speed = eStalkerSpeed_Walk;
			mpStateMachine.ChangeState(eStalkerState_ReturnToHole);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Return to hole!");
			return;
		}
		
		////////////////////
		// Default behaviour
		mpStateMachine.ChangeState(eStalkerState_Idle);
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Idle!");
	}
	
	//------------------------------------------------------------
	
	void Emerge_AddKnownBlockedHole(tID a_idHole)
	{
		if (mvEmerge_KnownBlockedHoles.find(a_idHole) == -1)
			mvEmerge_KnownBlockedHoles.push_back(a_idHole);
	}
	
	//------------------------------------------------------------
	
	bool Emerge_GetIsKnownBlockedHole(tID a_idHole)
	{
		return mvEmerge_KnownBlockedHoles.find(a_idHole) != -1;
	}
	
	//------------------------------------------------------------
	
	void Emerge_ClearKnownBlockedHoles()
	{
		mvEmerge_KnownBlockedHoles.resize(0);
	}
	
	//------------------------------------------------------------
	
	void Emerge_SetupKnockDownPlayer()
	{
		iLuxEntity@ pHole = cLux_ID_Entity(m_idEmerge_Hole);
		if (pHole is null) return;
		
		///////////////
		// Setup vars
		cMatrixf mtxHoleTranspose = pHole.GetMatrix().GetTranspose();
		cVector3f vPlayerPos = mBaseObj.GetPlayerFeetPos();
		cVector3f vPlayerFwd = cLux_GetPlayer().GetCharacterBody().GetForward();
		
		mvEmerge_KnockDownPlayerAnimPos = pHole.GetPosition() + mtxHoleTranspose.GetForward();
		mvEmerge_KnockDownPlayerAnimPos.y = pHole.GetMainBody().GetBoundingVolume().GetMin().y + 0.1f;
		
		cVector3f vToAnimPos = mvEmerge_KnockDownPlayerAnimPos - vPlayerPos;
		cVector3f vHoleRight = mtxHoleTranspose.GetRight();
		cVector3f vHoleFwd = mtxHoleTranspose.GetForward();
		
		cVector3f vProjPlayerPosSide = cMath_Vector3Project(vToAnimPos * -1.f, vHoleRight);		
		cVector3f vThrowDir;
		float fClearDist = 2.f;
		
		float fDistFwd;
		float fDistLeft;
		float fDistRight;
		cVector3f vNrm;
		
		///////////////
		// Cast rays
		cLux_GetClosestBody(mvEmerge_KnockDownPlayerAnimPos, vHoleFwd, 3.f, fDistFwd, vNrm);
		cLux_GetClosestBody(mvEmerge_KnockDownPlayerAnimPos, vHoleRight * -1.f, 3.f, fDistLeft, vNrm);
		cLux_GetClosestBody(mvEmerge_KnockDownPlayerAnimPos, vHoleRight, 3.f, fDistRight, vNrm);
		
		///////////////
		// Determine best dir
		if (fDistFwd >= fClearDist && vProjPlayerPosSide.SqrLength() <= 1.f * 1.f)
		{
			vThrowDir = vHoleFwd;
			mlEmerge_KnockDownPlayerDir = 0;
		}
		else if (fDistLeft >= fClearDist && fDistRight >= fClearDist)
		{
			bool bRightOfHole = cMath_Vector3Dot(cMath_Vector3Normalize(vToAnimPos), mtxHoleTranspose.GetRight()) > 0.f;
			if (bRightOfHole)
			{
				vThrowDir = vHoleRight * -1.f;
				mlEmerge_KnockDownPlayerDir = 1;
			}
			else
			{
				vThrowDir = vHoleRight;
				mlEmerge_KnockDownPlayerDir = 2;
			}
		}		
		else if (fDistLeft >= fClearDist)
		{
			vThrowDir = vHoleRight * -1.f;
			mlEmerge_KnockDownPlayerDir = 1;
		}
		else if (fDistRight >= fClearDist)
		{
			vThrowDir = vHoleRight;
			mlEmerge_KnockDownPlayerDir = 2;
		}
		else if (fDistFwd >= fClearDist)
		{
			vThrowDir = vHoleFwd;
			mlEmerge_KnockDownPlayerDir = 0;
		}
		else if (fDistLeft > fDistRight)
		{
			vThrowDir = vHoleRight * -1.f;
			mlEmerge_KnockDownPlayerDir = 1;
		}
		else if (fDistRight > fDistLeft)
		{
			vThrowDir = vHoleRight;
			mlEmerge_KnockDownPlayerDir = 2;
		}
		
		///////////////
		// Setup knock down
		bool bBehindPlayer = cMath_Vector3Dot(vPlayerFwd, vThrowDir) > 0.f;
		float fAngleDir = bBehindPlayer ? 1.f : -1.f;
		
		mfEmerge_KnockDownPlayerAnimAngle = cMath_GetAngleFromPoints3D(0.f, vThrowDir * fAngleDir).y;	
		mEmerge_KnockDownPlayerType = bBehindPlayer ? eStalkerThrowPlayerType_BehindPlayer : eStalkerThrowPlayerType_Forward;
		mvAlert_PlayerDir = vThrowDir;
	}
	
	//------------------------------------------------------------
	
	void Emerge_DoPreEmergeParticles(tID a_idHole)
	{		
		iLuxEntity@ pEnt = cLux_ID_Entity(a_idHole);
		if (pEnt is null) return;
		
		cParticleSystem@ pPS = pEnt.CreateParticleSystem("PS_PreEmergeDust", "ghoul_hole_dust_pre_emerge.ps", true, false);
		pPS.SetWorldMatrix(Emerge_GetEmergeParticleMatrix(pEnt));
	}
	
	//------------------------------------------------------------
	
	void Emerge_DoEmergeParticles(tID a_idHole)
	{		
		iLuxEntity@ pEnt = cLux_ID_Entity(a_idHole);
		if (pEnt is null) return;
		
		cParticleSystem@ pPS = pEnt.CreateParticleSystem("PS_EmergeDust", "ghoul_hole_dust_emerge.ps", true, false);
		pPS.SetWorldMatrix(Emerge_GetEmergeParticleMatrix(pEnt));
	}
	
	//------------------------------------------------------------
	
	cMatrixf Emerge_GetEmergeParticleMatrix(iLuxEntity@ apHole)
	{
		cMatrixf mtxHole = cMath_MatrixSetScale(apHole.GetMatrix(), cVector3f_One);
		mtxHole.SetTranslation(apHole.GetPosition() + apHole.GetMatrix().GetTranspose().GetForward() * -0.5f + cVector3f_Up * -0.4f);
		return mtxHole;
	}
	
	//------------------------------------------------------------

	//} END EMERGE
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: INVESTIGATE SOUND
	//{////////////////////////////////

	//------------------------------------------------------------

	cVector3f mvInvestigateSound_Goal = 0.f;
	int mlInvestigateSound_Prio = -1;
	int mlInvestigateSound_PlayerSoundCount = 0;
	int mlInvestigateSound_EnterFromHighPrioPlayerSoundCount = 0;
	float mfInvestigateSound_Distance = 0.f;
	float mfInvestigateSound_PlayerSoundDecreaseCount = 0.f;
	bool mbInvestigateSound_QueueSound = false;
	tString msInvestigateSound_SoundName = "";
	tID m_idInvestigateSound_SoundSourceBodyId = tID_Invalid;
	eStalkerSpeed mInvestigateSound_PrevSpeedState = eStalkerSpeed_Stopped;
	array<tID> mvInvestigateSound_IgnoredSoundSourceBodyIds;
	tString msInvestigateSound_AnimReaction = "";

	//------------------------------------------------------------

	void State_InvestigateSound_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: InvestigateSound ------", false, true);		
		
		mbInvestigateSound_QueueSound = false;
		
		if (mBaseObj.Timer_Exists("Timer_HeardHighPrioPlayerSound") &&
			mBaseObj.GetDistanceToPlayer() < 30.f)
		{
			++mlInvestigateSound_EnterFromHighPrioPlayerSoundCount;
			
			mBaseObj.Timer_Remove("Timer_HeardHighPrioPlayerSound");
			mBaseObj.Timer_Remove("Timer_ResetHighPrioPlayerSoundCount");
			mBaseObj.Timer_Add("Timer_ResetHighPrioPlayerSoundCount", 90.f, "OnTimer_ResetHighPrioPlayerSoundCount");
		}
		
		if (mInvestigateSound_PrevSpeedState == eStalkerSpeed_Stopped)
		{
			if (mAlertState == eStalkerAlertState_None)
			{
				mpPathfinder.Stop();
			}
			
			SetSpeedState(eStalkerSpeed_Walk);
		}
		else
		{
			SetSpeedState(mInvestigateSound_PrevSpeedState);
		}
		
		if (mbPlayerIsInSaveRoom)
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
			return;
		}
		
		mInvestigateSound_PrevSpeedState = eStalkerSpeed_Stopped;
		mpSoundListener.SetSoundRadiusMul(1.2f);
				
		IncreaseSoundCounter(mlInvestigateSound_Prio);
		
		//////////////////////
		// Take action
		if (mAlertState == eStalkerAlertState_None)
		{
			mpStateMachine.AddTimer("SoundReaction", 0.3f);
			mpStateMachine.AddTimer("AnimReaction", 0.0f);
		}
		else
		{
			mpStateMachine.AddTimer("GoToSource", 0.0f);	
		}
		
		mpStateMachine.AddTimer("UpdateMoveSpeed", 0.5f);
		
		SetAlertState(eStalkerAlertState_Investigating);
		
		InvestigateSound_UpdatePlayerSoundCount(mlInvestigateSound_Prio, false, true);
	}
	
	//------------------------------------------------------------

	void State_InvestigateSound_Leave()
	{
		msAnimState = "";
		
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);
		
		mpMover.SetUseMoveStateAnimations(true);
		msInvestigateSound_AnimReaction = "";
				
		///////////////////
		// Save speed if probably coming back to this state
		int lNextState = mpStateMachine.GetNextState();
		if (lNextState == eStalkerState_Blocked ||
			lNextState == eStalkerState_BlockedByProp ||
			lNextState == eStalkerState_BreakDoor ||
			lNextState == eStalkerState_EvaluateObstacle ||
			(lNextState == eStalkerState_Retreat && mbRetreat_TakingShortcut))
		{
			mInvestigateSound_PrevSpeedState = eStalkerSpeed(mpMover.GetSpeedState());
		}
		
		///////////////////
		// Reset vars if leaving state and not coming back!
		else
		{
			// Ugly fix for ignoring prisoner sound
			if (msInvestigateSound_SoundName == "PrisonerScream")
			{
				cScript_SetGlobalVarBool("Stalker_IgnorePrisonerSounds", true);
			}
			
			InvestigateSound_ResetVars();
		}			
	}
	
	//------------------------------------------------------------

	void State_InvestigateSound_Update(float afTimeStep)
	{				
	}
	
	//------------------------------------------------------------

	bool State_InvestigateSound_Message(int alMessageId)
	{		
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo && mlInvestigateSound_Prio > 3) 
			return true;
		
		///////////////////
		// Player entered save room
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom)
		{
			mpStateMachine.ChangeState(eStalkerState_Roar);
			return false;
		}
		
		///////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{			
			///////////////////
			// Sound reaction
			if (msAnimState == "SoundReactionEnd")
			{
				mpStateMachine.AddTimer("GoToSource", 0.f);
				msAnimState = "";
			}
			
			///////////////////
			// Look around
			else if (msAnimState == "LookAround")
			{
				if (mbInvestigateSound_QueueSound)
				{
					mbInvestigateSound_QueueSound = false;
					mpStateMachine.AddTimer("GoToSource", 0.f);
				}
				else 
				{					
					/////////////////////
					// Search area?
					if (true)
					{
						mvSearchArea_SearchPos = mBaseObj.GetPosition();
						mpStateMachine.ChangeState(eStalkerState_SearchArea);
					}
					
					/////////////////////
					// Otherwise, shrug it off
					else
					{
						mpStateMachine.AddTimer("NothingFound", 0.f);
					}
				}
				
				msAnimState = "";
			}
			
			///////////////////
			// Nothing found
			else if (msAnimState == "NothingFound")
			{
				/////////////////////
				// Sound queued?
				if (mbInvestigateSound_QueueSound)
				{
					mbInvestigateSound_QueueSound = false;
					mpStateMachine.AddTimer("GoToSource", 0.2f);
				}
				else
				{
					mpStateMachine.AddTimer("Exit", 0.f);
				}
				
				msAnimState = "";
			}
			
			return true;
		}
		
		///////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reached end, look around");
			
			mpPathfinder.Stop();
			mpStateMachine.StopTimer("GoToSource");
			mpStateMachine.AddTimer("LookAroundEnd", 0.5f);
			
			////////////////////
			// Ignore flare if found!
			if (msInvestigateSound_SoundName == "Flare" && m_idInvestigateSound_SoundSourceBodyId != tID_Invalid)
			{
				InvestigateSound_AddIgnoredSoundSourceBody(m_idInvestigateSound_SoundSourceBodyId);
			}
			
			////////////////////
			// Ignore low prio sound if made by same entity over and over
			else if (m_idInvestigateSound_SoundSourceBodyId != tID_Invalid && mlInvestigateSound_Prio <= 1)
			{
				iLuxEntity@ pSoundEnt = cLux_GetBodyEntity(cLux_ID_Body(m_idInvestigateSound_SoundSourceBodyId));
				if (pSoundEnt !is null && 
					msInvestigateSound_SoundName != "")
				{
					pSoundEnt.IncVarInt("SoundInvestigatedByStalkerCount", 1);
					if (pSoundEnt.GetVarInt("SoundInvestigatedByStalkerCount") > 1)
					{
						InvestigateSound_AddIgnoredSoundSourceBody(m_idInvestigateSound_SoundSourceBodyId);
					}
				}
			}
			
			return true;
		}
		
		///////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eStalkerState_Alert);
			
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return true;
		}

		//////////////////////
		// Sound heard
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetShouldIgnoreSound()) return true;
					
			mpStateMachine.StopTimer("NothingFound");
			
			int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;
			tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
			tID idSourceBody = mpStateMachine.GetCurrentMessageData().mID;
			float fDistBetweenSounds = (vPos - mvInvestigateSound_Goal).Length();
			bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player";
			
			IncreaseSoundCounter(lPrio);
			
			if (cString_GetFirstStringPos(msAnimState, "LookAround") != -1 && fDistBetweenSounds > 1.f)
			{
				mbInvestigateSound_QueueSound = true;
				
				bool bInvestigate = InvestigateSound_RegisterSound(lPrio, vPos, sSoundName, idSourceBody, false, false, bCausedByPlayer);
				IncreaseInterest(mpStateMachine.GetCurrentMessageData(), bInvestigate);				
				return true;
			}
			
			//////////////////////
			// Is new sound more important?
			bool bGunShot = sSoundName == "Gunshot";			
			bool bInvestigate = InvestigateSound_RegisterSound(lPrio, vPos, sSoundName, idSourceBody, false, bGunShot == false, bCausedByPlayer);
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), bInvestigate);
			
			if (bInvestigate)
			{
				mpStateMachine.AddTimer("SoundReaction", 0.3f);
				if (mpStateMachine.TimerExists("GoToSource") == false)
				{
					mpStateMachine.AddTimer("GoToSource", 0.2f);
				}
				
				if (bCausedByPlayer || sSoundName == "Gunshot")
				{
					InvestigateSound_UpdatePlayerSoundCount(lPrio, false, true);
				}
			}

			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_InvestigateSound_TimerUp(uint64 alId)
	{
		///////////////////////
		// Go to source
		if (alId == H64("GoToSource"))
		{		
			/////////////////////
			// Setup vars
			bool bFoundPath = false;
			bool bGoThroughHoles = false;			
			
			cVector3f vSourcePos(0.f);		
			cVector3f vSoundDir = cMath_Vector3Normalize(mvInvestigateSound_Goal - mBaseObj.GetPosition());			
			cAINode@ pNode = mpPathfinder.GetNodeInPosLOS(mvInvestigateSound_Goal - vSoundDir * 2.f, mvInvestigateSound_Goal, 0.f, 4.f);
			
			iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
			
			/////////////////////
			// Get node at source
			// (If no available path, go through holes)
			if (pNode !is null)
			{
				vSourcePos = pNode.GetPosition();
				bGoThroughHoles = GetPathDistanceToPos(pCharBody.GetFeetPosition(), vSourcePos) < 0.f;
				
				if (bGoThroughHoles == false)
				{
					bFoundPath = true;
					mpPathfinder.MoveTo(vSourcePos, 1.f, false);
				}
			}
			else
			{
				@pNode = mpPathfinder.GetNodeAtPos(mvInvestigateSound_Goal, 2.f, 7.f, true, false, false, null);
				if (pNode !is null)
				{
					vSourcePos = pNode.GetPosition();					
					bGoThroughHoles = GetPathDistanceToPos(pCharBody.GetFeetPosition(), vSourcePos) < 0.f;
					
					if (bGoThroughHoles == false)
					{
						bFoundPath = true;
						mpPathfinder.MoveTo(vSourcePos, 1.f, false);
					}
				}
			}
			
			//////////////////
			// Go through holes?
			if (bGoThroughHoles)
			{				
				tID idHoleA = GetHoleWithShortestPathToPos(vSourcePos);
				tID idHoleB = GetHoleWithShortestPathToPos(mBaseObj.GetPosition());
				cLuxArea@ pHoleA = cLux_ID_Area(idHoleA);
				cLuxArea@ pHoleB = cLux_ID_Area(idHoleB);
				
				if (pHoleA !is null && pHoleB !is null && pHoleA !is pHoleB)
				{
					mbEmerge_InvestigateSound = true;
					mbRetreat_TakingShortcut = true;
					mlRetreat_ShortcutState = eStalkerState_InvestigateSound;
					mvRetreat_ShortcutTarget = mvInvestigateSound_Goal;
					m_idMoveBetweenHoles_EmergeHole = idHoleA;
					mpStateMachine.ChangeState(eStalkerState_Retreat);
					
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Going to source through holes!");
					return;
				}
				else
				{
					bFoundPath = false;
				}			
			}
			
			/////////////////
			// No path found?
			if (bFoundPath == false)
			{
				mpStateMachine.ChangeState(eStalkerState_Idle);				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Did not find path to source, entering idle");
			}	
		}
		
		///////////////////////
		// Update move speed
		if (alId == H64("UpdateMoveSpeed"))
		{
			if (mpPathfinder.IsMoving())
			{
				int lNewSpeedState = eStalkerSpeed_Walk;
				int lCurrentSpeedState = mpMover.GetSpeedState();
				float fDistToPos = GetPathDistanceToPos(mBaseObj.GetCharBody().GetFeetPosition(), mpPathfinder.GetGoalPos());
				
				if (fDistToPos <= 15.f)
					lNewSpeedState = eStalkerSpeed_Walk;
				else if (mbInterest_Alert)
					lNewSpeedState = eStalkerSpeed_Run;
				else if (mfSoundCounter >= 6.f || lCurrentSpeedState == eStalkerSpeed_Run) 
					lNewSpeedState = eStalkerSpeed_Run;
				else if (mfSoundCounter >= 3.f || lCurrentSpeedState == eStalkerSpeed_Walk) 
					lNewSpeedState = eStalkerSpeed_Walk;
				
				if (mpMover.GetSpeedState() != lNewSpeedState)
					SetSpeedState(lNewSpeedState);
			}
				
			mpStateMachine.AddTimer("UpdateMoveSpeed", 0.5f);
		}
			
		///////////////////////
		// Sound reaction
		if (alId == H64("SoundReaction"))
		{
			mBaseObj.PlaySound("SoundHeard", gsStalkerSound_SoundHeard, true, true);
		}
		
		///////////////////////
		// Anim reaction
		if (alId == H64("AnimReaction"))
		{
			msAnimState = "SoundReaction";
			
			msInvestigateSound_AnimReaction = GetLookAnimation(mvInvestigateSound_Goal, false);
			mpMover.PlayAnimation(msInvestigateSound_AnimReaction, 0.3f, true);
			
			mpStateMachine.AddTimer("StopAnimReaction", cMath_RandRectf(0.9f, 1.5f));
		}
		
		///////////////////////
		// Stop anim reaction
		if (alId == H64("StopAnimReaction"))
		{
			msAnimState = "SoundReactionEnd";
			PlayGlimpseEndAnim(msInvestigateSound_AnimReaction);
			
			mpStateMachine.AddTimer("GoToSource", 0.f);
		}
		
		///////////////////////
		// Look around end
		if (alId == H64("LookAroundEnd"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Look around");
			mpPathfinder.Stop();
			
			mBaseObj.PlaySound("LookAround", gsStalkerSound_LookAround, true, true);
			
			msAnimState = "LookAround";
			
			tString sAnim = GetRandomLookAroundSideAnim();
			mpMover.PlayAnimation(sAnim, 0.3f, false);
		}
		
		///////////////////////
		// Nothing found
		if (alId == H64("NothingFound"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Nothing found");
			mpPathfinder.Stop();
			
			mBaseObj.PlaySound("LostTrackSmall", gsStalkerSound_LostTrackSmall, true, true);
			
			msAnimState = "NothingFound";
			mpMover.PlayAnimation(gsStalkerAnim_ShrugOff, 0.3f, false);
		}
		
		
		///////////////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Exit");
		}
	}
	
	//------------------------------------------------------------
	
	bool InvestigateSound_RegisterSound(int alPrio, const cVector3f &in avPos, const tString &in asSoundName, 
										tID a_idSourceBody, bool abChangeState, bool abCheckOverride, bool abCausedByPlayer)
	{
		///////////////
		// Occluded?
		if (InvestigateSound_GetIsSoundOccluded(alPrio, mBaseObj.GetCharBody().GetPosition(), avPos))
			return false;
				
		///////////////
		// Only care about door sounds if made by player!
		tString sSoundName = cString_ToLowerCase(asSoundName);
		bool bIsDoorInteractSound = cString_GetFirstStringPos(sSoundName, "door") >= 0 &&
									cString_GetFirstStringPos(sSoundName, "break") == -1;
		if (bIsDoorInteractSound && 
			cLux_GetPlayer().GetCurrentStateId() != ePlayerState_SwingDoor)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Ignored sound from door since the player isn't interacting with it!");
			return false;
		}
		
		///////////////
		// Setup vars
		bool bRegister = true;		
		float fSoundDistSqr = (mBaseObj.GetPosition() - avPos).SqrLength();
		
		///////////////
		// Only register if new sound is interesting enough?
		if (abCheckOverride)
		{
			bRegister = mlInvestigateSound_Prio < alPrio || 
						(mlInvestigateSound_Prio == alPrio && fSoundDistSqr < mfInvestigateSound_Distance);
		}
		
		///////////////
		// Register
		if (bRegister)
		{
			mlInvestigateSound_Prio = alPrio;
			mvInvestigateSound_Goal = avPos;
			mfInvestigateSound_Distance = fSoundDistSqr;
			msInvestigateSound_SoundName = asSoundName;
			m_idInvestigateSound_SoundSourceBodyId = a_idSourceBody;			
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Sound heard: (Prio: " + alPrio + " Name: " + mpStateMachine.GetCurrentMessageData().msX + ")");					
		}		
		
		///////////////
		// Investigate sound
		if (abChangeState)
		{
			if (mbPlayQuickTurnAnim)
			{
				mlQuickTurnDoneState = eStalkerState_InvestigateSound;
			}
			else
			{
				mpStateMachine.ChangeState(eStalkerState_InvestigateSound);
			}
		}
		
		///////////////
		// Update player sound count (no footsteps)
		if (abCausedByPlayer || asSoundName == "Gunshot")
		{
			if (cString_GetFirstStringPos(asSoundName, "Footstep") == -1 &&
				SoundOcclusion_GetIsPointOccluded(mBaseObj.GetCharBody().GetPosition(), avPos) == false)
			{
				int lPlayerSoundPrio = asSoundName == "DynamoLanternCharge" ? 3 : alPrio;
				InvestigateSound_UpdatePlayerSoundCount(lPlayerSoundPrio, true, false);
				
				if (bRegister && abChangeState && mlInvestigateSound_Prio >= 5)
					mBaseObj.Timer_Add("Timer_HeardHighPrioPlayerSound", 10.f, "", false, false);
			}
		}
		
		///////////////
		// Return
		return bRegister;		
	}
	
	//------------------------------------------------------------

	bool InvestigateSound_GetIsSoundOccluded(int alPrio, const cVector3f &in avListenerPos, const cVector3f &in avSoundPos)
	{
		if (alPrio <= glStalker_IgnoreOccludedSoundMaxPrio &&
			SoundOcclusion_GetIsPointOccluded(avListenerPos, avSoundPos))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Ignored sound with prio: " + alPrio + " since it's occluded!");
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void InvestigateSound_ResetVars()
	{
		mlInvestigateSound_Prio = -1;
		mfInvestigateSound_Distance = 0.f;
		msInvestigateSound_SoundName = "";
		m_idInvestigateSound_SoundSourceBodyId = tID_Invalid;
	}
	
	//------------------------------------------------------------
	
	void InvestigateSound_AddIgnoredSoundSourceBody(tID a_idBody)
	{
		if (mvInvestigateSound_IgnoredSoundSourceBodyIds.find(a_idBody) == -1)
			mvInvestigateSound_IgnoredSoundSourceBodyIds.push_back(a_idBody);
	}
	
	//------------------------------------------------------------
	
	void InvestigateSound_RemoveIgnoredSoundSourceBody(tID a_idBody)
	{
		int lId = mvInvestigateSound_IgnoredSoundSourceBodyIds.find(a_idBody);
		if (lId != -1)
			mvInvestigateSound_IgnoredSoundSourceBodyIds.removeAt(lId);
	}
	
	//------------------------------------------------------------
	
	void InvestigateSound_UpdatePlayerSoundCount(int alPrio, bool abIncrease, bool abChangeState)
	{
		/////////////////
		// Increase?
		bool bIsAlert = mAlertState > eStalkerAlertState_None || mBaseObj.Timer_Exists("Timer_JustLeftAlertState");
		float fDistToPlayer = mBaseObj.GetDistanceToPlayer();		
		
		if (abIncrease && 
			bIsAlert &&
			fDistToPlayer < 12.f)
		{
			int lAdd;
			if (alPrio > 5) 		lAdd = 10;
			else if (alPrio > 2) 	lAdd = 4;
			else					lAdd = 1;
			
			if (fDistToPlayer < 6.f && 
				mBaseObj.GetPlayerIsInLineOfSight())
			{
				lAdd *= 2.f;
			}
			
			mlInvestigateSound_PlayerSoundCount += lAdd;
			
			if (mbHidden)
				mlInvestigateSound_PlayerSoundCount = cMath_Min(mlInvestigateSound_PlayerSoundCount, 1);
			
			mfInvestigateSound_PlayerSoundDecreaseCount = cMath_RandRectf(10.f, 15.f);
		}
		
		/////////////////
		// Player made enough noise, find them?
		if (abChangeState && 
			(mlInvestigateSound_PlayerSoundCount >= 10 ||
			 mlInvestigateSound_EnterFromHighPrioPlayerSoundCount >= 3))
		{
			mlInvestigateSound_PlayerSoundCount = 0;
			mlInvestigateSound_EnterFromHighPrioPlayerSoundCount = 0;		
			
			mpStateMachine.ChangeState(eStalkerState_Alert);
			
			mBaseObj.Timer_Add("Timer_PlayerMadeLotsOfNoise", 20.f);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player made a lot of noise, find them!");
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_ResetHighPrioPlayerSoundCount(uint64 alId)
	{
		mlInvestigateSound_EnterFromHighPrioPlayerSoundCount = 0;
	}
	
	//------------------------------------------------------------

	//} END INVESTIGATE SOUND

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: RETURN TO HOLE
	//{////////////////////////////////

	//------------------------------------------------------------
	
	bool mbReturnToHole_EnteringHole = false;
	tID m_idReturnToHole_Hole = tID_Invalid;
	eStalkerSpeed mReturnToHole_Speed = eStalkerSpeed_Walk;

	//------------------------------------------------------------
	
    void State_ReturnToHole_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ReturnToHole ------");
		
		mbReturnToHole_EnteringHole = false;
		
		/////////////////////
		// Get new hole if current one is unreachable
		cLuxArea@ pHole = cLux_ID_Area(m_idReturnToHole_Hole);
		
		if (pHole is null ||
			mpPathfinder.BuildPathNodeArrayToPos(pHole.GetPosition(), 1) == false)
		{			
			m_idReturnToHole_Hole = GetHoleWithShortestPathToPos(mBaseObj.GetPosition(), -1.f, -1.f, false);
			
			if (m_idReturnToHole_Hole == tID_Invalid)
				m_idReturnToHole_Hole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), -1.f, -1.f, false, false);
			
			@pHole = cLux_ID_Area(m_idReturnToHole_Hole);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Going to closest hole!");
		}
		
		/////////////////////
		// Go to hole
		SetSpeedState(mbRetreat_Active ? eStalkerSpeed_Run : mReturnToHole_Speed);
		
		if (pHole !is null)
		{
			if (mBaseObj.GetDistanceToPos(pHole.GetPosition()) < 2.5f)
			{
				if (ReturnToHole_GetHoleIsInFront())
				{
					mpStateMachine.AddTimer("EnterHole", 0.f);
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Entering!");
				}
				else
				{
					mpStateMachine.AddTimer("TurnToHole", 0.f);
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Turning to hole!");
				}				
			}
			else
			{
				mpPathfinder.MoveTo(pHole.GetPosition(), 1.f, false);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Moving to hole!");
			}
		}
		
		//Entity_RemoveEntityAttachment("gen_1");
	}
	
	//------------------------------------------------------------

	void State_ReturnToHole_Leave()
	{		
		mbProximityDetectionActive = true;	
		mReturnToHole_Speed = eStalkerSpeed_Walk;
		
		if (mbHidden)
		{
			m_idReturnToHole_Hole = tID_Invalid;
		}
	}
	
	//------------------------------------------------------------
	
	void State_ReturnToHole_Update(float afTimeStep)
	{
		////////////////////
		// Enter hole?
		cLuxArea@ pHole = cLux_ID_Area(m_idReturnToHole_Hole);
		
		if (pHole is null) return;
		if (mbReturnToHole_EnteringHole) return;
		
		cVector3f vHolePos = pHole.GetPosition();
		cVector3f vHoleWallPos = vHolePos + GetHoleFwd(m_idReturnToHole_Hole) * -0.25f;

		if (mBaseObj.GetDistanceToPos(vHolePos) < 1.75f &&
			ReturnToHole_GetHoleIsInFront())
		{
			mpStateMachine.AddTimer("EnterHole", 0.f);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hole reached, entering!");
		}
	}
	
	//------------------------------------------------------------
	
	bool State_ReturnToHole_Message(int alMessageId)
	{
		Entity_RemoveEntityAttachment("gen_1");
		Entity_Destroy("gen_1");
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			////////////////////
			// Anim over, enter hole!
			if (msAnimState == "EnterHole")
			{
				tString sAnim = mpStateMachine.GetCurrentMessageData().msX;
				if (sAnim != gsStalkerAnim_EnterHole)
					return true;
				
				SetHidden(true);
				
				mbRetreat_Active = false;
				
				m_idWaitInHole_Hole = m_idReturnToHole_Hole;
				mpStateMachine.ChangeState(eStalkerState_WaitInHole);
				
				///////////////////////
				// First encounter achievement
				if (mbFirstEncounterHasStarted && 
					(mMode == eStalkerMode_Passive || (!mbRetreat_GoToLastKnownPlayerPosThroughHoles && !mbRetreat_TakingShortcut)) && 
					Achievement_GetUnlocked(eAchievement_GotIntroduced)==false)
				{
					Achievement_Unlock(eAchievement_GotIntroduced);
				}
			}
		}
		
		if (mbReturnToHole_EnteringHole) return true;
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{			
			if (mbReturnToHole_EnteringHole) return true;
			
			cLuxArea@ pHole = cLux_ID_Area(m_idReturnToHole_Hole);
			cVector3f vHolePos = pHole !is null ? pHole.GetPosition() : cVector3f(0.f);
			
			/////////////////
			// Far away still, move closer!
			if (pHole !is null && mBaseObj.GetDistanceToPos(vHolePos) > 2.5f)
			{
				mpPathfinder.MoveTo(vHolePos, 1.f, false);
			}
			
			/////////////////
			// At hole, enter!
			else
			{
				mpStateMachine.AddTimer("EnterHole", 0.f);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hole reached, entering!");
			}
			
			return true;
		}
		
		if (mbRetreat_Active) return true;
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_ReturnToHole_TimerUp(uint64 alId)
	{	
		//////////////////////
		// Enter hole
		if (H64("EnterHole") == alId)
		{
			if (mbReturnToHole_EnteringHole)
				return;
			
			mbReturnToHole_EnteringHole = true;
			
			//////////////////////
			// Stop movement
			mpMover.StopTurning();
			mBaseObj.GetCharBody().StopMovement();
			
			//////////////////////
			// Play anim
			float fAngle = GetHoleAngle(m_idReturnToHole_Hole) + cMath_Pi;
			
			cVector3f vFwd = GetHoleFwd(m_idReturnToHole_Hole);
			cVector3f vPos = GetHoleGroundPos(m_idReturnToHole_Hole);			
			vPos += vFwd * 2.073f;		

			PlayCutsceneAnimation(gsStalkerAnim_EnterHole, false, 0.3f, "", 1.f, 0.f, true, vPos, fAngle, false, false, false);
			
			msAnimState = "EnterHole";
			
			//////////////////////
			// Sounds
			cVector3f vSoundPos = vPos - vFwd * 1.5f + cVector3f(0.f, 0.5f, 0.f);
			cSoundEntity@ pSoundCrawlIn = mBaseObj.PlaySound("Sound_CrawlIn", gsStalkerSound_CrawlIn, true, false);
			cSoundEntity@ pSoundCrawlInFoley = mBaseObj.PlaySound("Sound_CrawlInFoley", gsStalkerSound_CrawlInFoley, true, false);			
			
			if (pSoundCrawlIn !is null) 
				pSoundCrawlIn.SetWorldPosition(vSoundPos);
			if (pSoundCrawlInFoley !is null) 
				pSoundCrawlInFoley.SetWorldPosition(vSoundPos);
			
			StalkerRumbleEffect(8.f, 0.25, 1.5f);
			
			//////////////////////
			// Particles
			Emerge_DoEmergeParticles(m_idReturnToHole_Hole);
			
			//////////////////////
			// Break any props in the way
			cLuxArea@ pArea = cLux_ID_Area(m_idReturnToHole_Hole);
			if (pArea !is null)
			{
				cVector3f vMin = pArea.GetAreaBody().GetBoundingVolume().GetMin() - cVector3f_One * 0.25f;
				cVector3f vMax = pArea.GetAreaBody().GetBoundingVolume().GetMax() + cVector3f_One * 0.25f;
							
				array<iPhysicsBody@> vBodies;
				mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(vMin, vMax, false, false, vBodies);
									
				for (int i = 0; i < vBodies.size(); ++i)
				{
					iPhysicsBody@ pBody = vBodies[i];
					cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));					
					
					if (pProp is null)										continue;
					if (GetIsPropBreakable(pProp) == false)					continue;
					if (pProp.GetHealth() <= 0.f)							continue;
					if (Blackboard_GetCanBodyBlockPath(pBody) == false) 	continue;
					
					BreakProp(pProp);
				}
			}
		}
		
		//////////////////////
		// Turn to hole
		else if (H64("TurnToHole") == alId)
		{
			if (ReturnToHole_GetHoleIsInFront())
			{
				mpStateMachine.AddTimer("EnterHole", 0.f);
				return;
			}
			
			cVector3f vHolePos = GetHoleGroundPos(m_idReturnToHole_Hole);
			
			mpMover.TurnToPos(vHolePos);
			mpPathfinder.MoveTo(vHolePos, 1.f, false);
			
			mpStateMachine.AddTimer("TurnToHole", 0.1f);
		}
	}
	
	//------------------------------------------------------------
	
	bool ReturnToHole_GetHoleIsInFront()
	{
		iLuxEntity@ pHole = cLux_ID_Entity(m_idReturnToHole_Hole);
		if (pHole is null) return false;
		
		cVector3f vToHole = cMath_Vector3Normalize(pHole.GetPosition() - mBaseObj.GetPosition());
		return cMath_Vector3Dot(mBaseObj.GetCharBody().GetForward(), vToHole) >= 0.5f;
	}
	
	//------------------------------------------------------------

	//} END RETURN TO HOLE

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: PLAYER DETECTED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvPlayerDetected_Pos;
	tString msPlayerDetected_GlimpseAnim = "";
	bool mbPlayerDetected_TurnFollow = false;
	bool mbPlayerDetected_TimerActive = true;
	bool mbPlayerDetected_StopTurn = true;
	bool mbPlayerDetected_Moved = false;
	float mfPlayerDetected_Timer = 0.0f;
	int mlPlayerDetected_Count = 0;
	
	//------------------------------------------------------------

    void State_PlayerDetected_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PlayerDetected ------", false, true);
		
		/////////////////////
		// Setup state
		SetAlertState(eStalkerAlertState_Investigating);
		
		mbPlayerDetected_TimerActive = true;
		mbPlayerDetected_StopTurn = true;
		mbPlayerDetected_Moved = false;
		mfPlayerDetected_Timer = 0.f;
		
		mBaseObj.Timer_Remove("Timer_PlayerDetected_ResetCount");
		
		mpPathfinder.Stop();
		mpMover.StopTurning();
		
		SetSpeedState(eStalkerSpeed_Walk);
		
		/////////////////////
		// Enter alert if detected many times in a row
		++mlPlayerDetected_Count;
		if (mlPlayerDetected_Count >= 2.f)
		{
			mpStateMachine.ChangeState(eStalkerState_Alert);
			return;
		}
		
		/////////////////////
		// Detect player behaviour
		mvPlayerDetected_Pos = mBaseObj.GetPlayerPos();
		
		mBaseObj.PlaySound("PlayerDetected", gsStalkerSound_PlayerDetected, true, true);
		
		msAnimState = "PlayerDetected";
		
		msPlayerDetected_GlimpseAnim = GetLookAnimation(mBaseObj.GetPlayerPos(), true);
		mpMover.PlayAnimation(msPlayerDetected_GlimpseAnim, 0.3f, true);
		
		mpStateMachine.AddTimer("TurnTo", 1.f);
	}
	
	//------------------------------------------------------------

	void State_PlayerDetected_Leave()
	{		
		mpMover.SetUseMoveStateAnimations(true);
		
		mbPlayerDetected_TurnFollow = false;
		msPlayerDetected_GlimpseAnim = "";
		
		mBaseObj.Timer_Add("Timer_PlayerDetected_ResetCount", 5.f, "OnTimer_PlayerDetected_ResetCount");
	}
	
	//------------------------------------------------------------

	void State_PlayerDetected_Update(float afTimeStep)
	{
		///////////////////
		// Stop turn
		if (mbPlayerDetected_StopTurn)
		{
			mpMover.StopTurning();
		}
		
		///////////////////
		// Timer
		if (mbPlayerDetected_TimerActive)
		{
			mfPlayerDetected_Timer += afTimeStep;
		}
		
		///////////////////
		// Turn follow
		if (mbPlayerDetected_TurnFollow)
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
		}
	}
	
	//------------------------------------------------------------

	bool State_PlayerDetected_Message(int alMessageId)
	{		
		///////////////
		// Detect gobo
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
		{
			if (GetSensesActive() == false) return true;
			if (mBaseObj.PlayerIsDetected()) return true;
		}
		
		///////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eStalkerState_Alert);
			
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return true;
		}
		
		///////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{		
			//////////////////
			// Stop glimpse
			if (msAnimState == "StopGlimpse")
			{
				mbPlayerDetected_StopTurn = false;
				
				mpStateMachine.AddTimer("StepForward", 3.f);
				mpMover.TurnToPos(mvPlayerDetected_Pos);
				
				msAnimState = "";
			}
	
			//////////////////
			// Nothing found
			else if (msAnimState == "NothingFound")
			{
				mpStateMachine.AddTimer("Exit", 0.f);
				msAnimState = "";
			}
			
			return true;
		}		
		
		///////////////
		// Player undetected
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{			
			mbPlayerDetected_TimerActive = false;
						
			mpStateMachine.StopTimer("EnterAlert");			
			mpStateMachine.StopTimer("StepForward");
			mpStateMachine.AddTimer("StepForward", 1.3f);		
			return true;
		}
		
		///////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.AddTimer("NothingFound", cMath_RandRectf(0.f, 0.5f));
		}
		
		///////////////
		// Rabbit doll
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract)
		{
			return mBaseObj.GetDistanceToPlayer() < gfStalker_IgnoreRabbitPlayerDistance;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_PlayerDetected_TimerUp(uint64 alId)
	{		
		///////////////
		// Turn to
		if (alId == H64("TurnTo"))
		{			
			if (mBaseObj.PlayerIsDetected())
			{
				mbPlayerDetected_TurnFollow = true;
				mbPlayerDetected_StopTurn = false;
				
				SetAlertState(eStalkerAlertState_Detected);
				
				mpStateMachine.AddTimer("EnterAlert", 1.f);
			}
		}
		
		///////////////
		// Enter alert
		if (alId == H64("EnterAlert"))
		{
			mpMover.SetUseMoveStateAnimations(true);
			mpStateMachine.ChangeState(eStalkerState_Alert);
		}
		
		///////////////
		// Step forward
		if (alId == H64("StepForward"))
		{			
			if (mbPlayerDetected_Moved == false)
			{
				mbPlayerDetected_Moved = true;
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Step forward detect timer: " + mfPlayerDetected_Timer);
				
				///////////////
				// Stop glimpse anims
				mpMover.SetUseMoveStateAnimations(true);
				
				if (mBaseObj.GetMeshEntity().GetAnimationStateFromName(msPlayerDetected_GlimpseAnim).IsActive())
				{
					msAnimState = "StopGlimpse";
					PlayGlimpseEndAnim(msPlayerDetected_GlimpseAnim);
				}
				
				///////////////
				// Move
				if (mfPlayerDetected_Timer > 0.8f)
				{
					cVector3f vDir = mvPlayerDetected_Pos - mBaseObj.GetPosition();
					vDir.y = 0;
					vDir.Normalize();
					
					float fDist;
					cVector3f vNrm;
					if (cLux_GetClosestBody(mBaseObj.GetPosition(), vDir, 3.f, fDist, vNrm) is null)
					{
						cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vDir * 4.f, 0.f, 4.f, true, false, false, null);
						if (pNode !is null)
						{
							mbPlayerDetected_StopTurn = false;
							mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
							return;
						}
					}
				}
			
				///////////////////
				// Couldn't move? Exit
				mpStateMachine.AddTimer("Exit", cMath_RandRectf(1.5f, 2.f));
			}
		}
		
		///////////////
		// Nothing found
		if (alId == H64("NothingFound"))
		{
			mpPathfinder.Stop();
			
			mBaseObj.PlaySound("LostTrackSmall", gsStalkerSound_LostTrackSmall, true, true);
			
			msAnimState = "NothingFound";
			mpMover.PlayAnimation(gsStalkerAnim_ShrugOff, 0.3f, false);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Nothing found!");
		}
		
		///////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
		}
	}

	//------------------------------------------------------------
	
	void OnTimer_PlayerDetected_ResetCount(uint64 alID)
	{
		mlPlayerDetected_Count = 0;
	}
	
	//------------------------------------------------------------

	//} END PLAYER DETECTED
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: ALERT
	//{////////////////////////////////

	//------------------------------------------------------------

	tString msAlert_Anim = "";
	cVector3f mvAlert_PlayerDir(0.f);
	int mlAlert_LastAlertTimeStamp = -1;
	float mfAlert_DistanceToPlayerWhenUndetected = 0.f;
	bool mbAlert_TurnToPlayer = false;
	
	//------------------------------------------------------------

    void State_Alert_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Alert ------", false, true);
		
		////////////////
		// Setup state
		SetAlertState(eStalkerAlertState_Detected);
		
		if (mbBossFight_Active == false)
			Terror_AddEnemy(mBaseObj.GetID(), gfStalker_AlertTime);
		
		mlAlert_LastAlertTimeStamp = mBaseObj.GetMap().GetTimeStamp();
		mbAlert_TurnToPlayer = false;
		mfAlert_DistanceToPlayerWhenUndetected = 0.f;
		
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Walk);
		
		mBaseObj.ResetPlayerDetectionState();
		
		///////////////////
		// Turn toward player?
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();		
		cVector3f vToPlayer = mvAlert_PlayerDir.SqrLength() > 0.f ? mvAlert_PlayerDir : mBaseObj.GetPlayerDir();
		
		float fAngle = cMath_GetAngleFromPoints3D(0, vToPlayer).y;
		float fAngleDiff = cMath_GetAngleDistanceRad(pCharBody.GetYaw(), fAngle);
		float fAbsAngleDiff = cMath_Abs(fAngleDiff);
		
		if (fAbsAngleDiff > cMath_PiDiv4)
		{
			mbAlert_TurnToPlayer = true;
			
			////////////////////
			// Play turn anim
			mfQuickTurnGoalYaw = fAngle;
			
			if (fAbsAngleDiff >= gfStalker_PlayTurnAroundAnimMinAngle)
				mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
			else
				mQuickTurnAnimType = fAngleDiff > 0.f ? eStalkerQuickTurnType_Left : eStalkerQuickTurnType_Right;
					
			PlayQuickTurnAnim();
		}
		
		///////////////////
		// Play alert anim
		else
		{
			Alert_PlayAnim();
		}	
	}
	
	//------------------------------------------------------------

	void State_Alert_Leave()
	{
		int lNextState = mpStateMachine.GetNextState();
		if (lNextState != eStalkerState_PreHunt && lNextState != eStalkerState_Hunt)
			Terror_RemoveEnemy(mBaseObj.GetID());
		
		msAlert_Anim = "";
		mvAlert_PlayerDir = cVector3f(0.f);
		mpMover.SetUseMoveStateAnimations(true);
	}
	
	//------------------------------------------------------------

	void State_Alert_Update(float afTimeStep)
	{		
		/////////////////////
		// Turning? Play anim when done!
		if (mbAlert_TurnToPlayer)
		{
			if (mbPlayQuickTurnAnim == false)
			{
				mbAlert_TurnToPlayer = false;
				Alert_PlayAnim();
			}
		
			return;
		}
		
		/////////////////////
		// Setup vars
		cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();
		bool bAnimOver = pAnim is null || pAnim.GetName() != msAlert_Anim;
			
		/////////////////////
		// Enter boss fight?
		if (mbBossFight_Active)
		{
			if (mBaseObj.GetDistanceToPlayer2D() < 2.f &&
				GetCanKillPlayer() && 
				cLux_GetGodModeActivated() == false)
			{
				mpStateMachine.ChangeState(eStalkerState_KillPlayer);
			}
			
			if (bAnimOver)
			{
				mpStateMachine.ChangeState(BossFight_GetCurrentState());
			}
			
			return;
		}
			
		/////////////////////
		// Enter pre hunt?
		if (bAnimOver)
		{
			int lNewState = eStalkerState_PreHunt;
			if (mBaseObj.PlayerIsDetected() == false &&
				mfAlert_DistanceToPlayerWhenUndetected > 10.f &&
				mBaseObj.Timer_Exists("Timer_PlayerMadeLotsOfNoise") == false)
			{
				lNewState = eStalkerState_CheckLastKnownPosition;
			}
			
			mpStateMachine.ChangeState(lNewState);
		}
		
		/////////////////////
		// Kill player if they get too close
		if (mBaseObj.GetDistanceToPlayer2D() < 2.5f &&
			GetCanKillPlayer() && 
			cLux_GetGodModeActivated() == false)
		{
			mpStateMachine.ChangeState(eStalkerState_KillPlayer);
		}
	}
	
	//------------------------------------------------------------

	bool State_Alert_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		if (mbAlert_TurnToPlayer) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_EndOfPath) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		
		///////////////////////
		// Hit by flashlight
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			if (mbBossFight_Active == false)
				Terror_AddEnemy(mBaseObj.GetID(), gfStalker_AlertTime * 0.3f);
				
			return true;
		}
		
		///////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			if (mbBossFight_Active == false)
				Terror_AddEnemy(mBaseObj.GetID(), gfStalker_AlertTime * 0.5f);
			
			mpStateMachine.StopTimer("CheckLastKnownPosition");
			return true;
		}
		
		///////////////////////
		// Player undetected
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			if (mbBossFight_Active) return true;
			
			mfAlert_DistanceToPlayerWhenUndetected = mBaseObj.GetDistanceToPlayer();
			if (mfAlert_DistanceToPlayerWhenUndetected < 10.f)
			{
				mpStateMachine.AddTimer("PreHunt", 2.f);
			}
			else
			{
				mpStateMachine.AddTimer("CheckLastKnownPosition", 2.f);
			}
			
			return true;
		}
		
		///////////////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_Alert_TimerUp(uint64 alId)
	{
		///////////////////////
		// Check last known pos
		if (alId == H64("CheckLastKnownPosition"))
		{
			if (mbBossFight_Active) return;
			if (mBaseObj.PlayerIsDetected() == false)
			{
				mpStateMachine.ChangeState(eStalkerState_CheckLastKnownPosition);
				return;
			}
			
			mpStateMachine.AddTimer("CheckLastKnownPosition", 0.2f);
		}
		
		///////////////////////
		// Hunt
		if (alId == H64("PreHunt"))
		{
			if (mbBossFight_Active) return;
			mpStateMachine.ChangeState(eStalkerState_PreHunt);
		}
	}
	
	//------------------------------------------------------------
	
	void Alert_PlayAnim()
	{
		////////////////
		// Play alert anim
		msAlert_Anim = Alert_GetAnim();
		mpMover.PlayAnimation(msAlert_Anim, 0.3f, false, false, "");
			
		////////////////
		// Sound
		mBaseObj.PlaySound("PlayerSpotted", gsStalkerSound_PlayerSpotted, true, true);

		////////////////
		// Check last known pos
		mpStateMachine.AddTimer("CheckLastKnownPosition", 3.f);
	}
	
	//------------------------------------------------------------
	
	tString Alert_GetAnim()
	{
		//////////////////
		// Setup vars	
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		tString sAnim = gsStalkerAnim_Alert;
		cVector3f vFwd = pCharBody.GetForward();
		
		//////////////////
		// Play cramped anim?			
		if (pPhysicsWorld !is null && pCharBody !is null)
		{		
			//////////////////
			// Create shape
			float fRadius = 0.5f;
			iCollideShape@ pShape = pPhysicsWorld.CreateSphereShape(fRadius, cMatrixf_Identity);			
			
			//////////////////
			// Get hand positions
			cVector3f vRight = cMath_Vector3Cross(vFwd, cVector3f_Up);			
			cVector3f vLeftHandOffset = vFwd * 0.7f + vRight * -1.75f + cVector3f(0.f, 0.35f, 0.f);	
			cVector3f vRightHandOffset = vFwd * 1.4f + vRight * 1.25f;	
			
			cVector3f vPos = mBaseObj.GetPosition();
			cVector3f[] vHandPos = { vPos + vLeftHandOffset, vPos + vRightHandOffset };
			
			//////////////////
			// Check collision at hands
			bool bColl = false;
			
			for (uint i = 0; i < vHandPos.length(); ++i)
			{				
				cVector3f vPush;
				cMatrixf mtxTransform = cMath_MatrixTranslate(vHandPos[i]);	
				
				if (pPhysicsWorld.CheckShapeWorldCollision(vPush, pShape, mtxTransform, pCharBody.GetCurrentBody(), false, false, false, false))
				{
					bColl = true;
					break;
				}
			}			
						
			//////////////////
			// Destroy shape!
			pPhysicsWorld.DestroyShape(pShape);
			
			//////////////////
			// Hands colliding?
			if (bColl)
			{
				sAnim = gsStalkerAnim_AlertCrampedArms;
			}
		}
		
		//////////////////
		// Head colliding?				
		if (GetIsHeadColliding(cVector3f(0.f, 0.5f, 1.3f)))
		{
			if (GetIsHeadColliding(cVector3f(0.f, 0.f, 2.f)))
			{
				sAnim = gsStalkerAnim_AlertCrampedStepBack;
			}
			else
			{
				sAnim = gsStalkerAnim_AlertCrampedFull;
			}			
		}
		
		return sAnim;
	}
	
	//------------------------------------------------------------

	//} END ALERT
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: PRE HUNT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvPreHunt_GoalPos(0.f);
	
	//------------------------------------------------------------

	void State_PreHunt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PreHunt ------", false, true);
		
		SetAlertState(eStalkerAlertState_Detected);
		
		Terror_AddEnemy(mBaseObj.GetID(), gfStalker_AlertTime);
		
		SetSpeedState(eStalkerSpeed_Walk);
		
		mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
		
		mbAllowUprightWalk = cMath_RandRectl(0, 2) > 0;
		if (mbAllowUprightWalk)
			mfAllowUprightWalkCount = cMath_RandRectf(4.f, 10.f);
		
		mpStateMachine.AddTimer("MoveTowardPlayer", 0.f);
		mpStateMachine.AddTimer("Hunt", 3.f);
	}

	//------------------------------------------------------------

	void State_PreHunt_Leave()
	{
		///////////////
		// Fail safe so it doesn't lose track of player immediately
		if (mpStateMachine.GetNextState() == eStalkerState_Hunt)
			mBaseObj.RevealPlayerPos();
	}

	//------------------------------------------------------------

	void State_PreHunt_Update(float afTimeStep)
	{
		///////////////////////
		// Enter hunt if close enough!
		if (mBaseObj.GetDistanceToPlayer2D() < gfStalker_PreHuntMinDist)
		{
			mpStateMachine.ChangeState(eStalkerState_Hunt);
		}
	}

	//------------------------------------------------------------

	bool State_PreHunt_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_EnterProximity) return true;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		if (alMessageId == eLuxEntityMessage_PlayerDetected) return true;
		
		///////////////
		// Player undetected
		if (alMessageId == eLuxEntityMessage_PlayerUndetected) 
		{
			mpStateMachine.ChangeState(eStalkerState_Hunt);
			return true;
		}
		
		///////////////
		// Rabbit doll
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract)
		{
			return mBaseObj.GetDistanceToPlayer() < gfStalker_IgnoreRabbitPlayerDistance;
		}
		
		return false;
	}

	//---------------------------------------------------------

	void State_PreHunt_TimerUp(uint64 alId)
	{
		if (H64("MoveTowardPlayer") == alId)
		{
			mvPreHunt_GoalPos = mBaseObj.GetPlayerFeetPos();			
			if (mpPathfinder.BuildPathNodeArrayToPosDelayed(mvPreHunt_GoalPos, "PreHunt_OnBuildPathNodeArray") == false)
			{
				cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvPreHunt_GoalPos, 0.f, 3.f, true, false, false, null);
				if (pNode !is null)
					mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
			}
			
			mpStateMachine.AddTimer("MoveTowardPlayer", 0.5f);
		}
		
		if (H64("Hunt") == alId)
		{
			mpStateMachine.ChangeState(eStalkerState_Hunt);
		}
	}
	
	//------------------------------------------------------------
	
	void PreHunt_OnBuildPathNodeArray(bool abSuccessful)
	{
		if (abSuccessful)
		{
			mpPathfinder.MoveTo(mvPreHunt_GoalPos, 1.f, false);
		}
		else
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvPreHunt_GoalPos, 0.f, 3.f, true, false, false, null);
			if (pNode !is null)
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
		}
	}
    
    //------------------------------------------------------------

	//} END PRE HUNT

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: HUNT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbHunt_PredictedPos = false;
	int mlHunt_AttackCount = 0;
	float mfHunt_PlayerStartHealth = 0;
	bool mbHunt_Unreachable = false;
	cVector3f mvHunt_LastPlayerDir = cVector3f(0.f);
	cVector3f mvHunt_PlayerHideKillAnimPos = cVector3f(0.f);
	cVector3f mvHunt_GoalPos(0.f);

	//------------------------------------------------------------

	void State_Hunt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Hunt ------", false, true);
		
		if (mAlertState < eStalkerAlertState_Detected)
			mBaseObj.RevealPlayerPos();
		
		SetAlertState(eStalkerAlertState_Detected);
		SetSpeedState(eStalkerSpeed_Run);
		
		Terror_AddHuntingEnemy(mBaseObj.GetID());
		Terror_RemoveEnemy(mBaseObj.GetID());
		Blackboard_SetEnemyHunt(mBaseObj.GetID(), true);
		
		//////////////////
		// Reset values
		mbHunt_PredictedPos = false;
		mbHunt_Unreachable = false;
		mvHunt_PlayerHideKillAnimPos = cVector3f(0.f);
		
		mpProximitySensor.ResetAllStates();
		mpPathfinder.SetDirectPathMaxDistanceMul(1.f);
		
		//////////////////
		// Keep track of how many times we have attacked the player without dealing damage
		int lPrevState = mpStateMachine.GetPrevState();
		bool bWasAttacking = lPrevState == eStalkerState_AttackClose;
		if (bWasAttacking)
		{
			if (cLux_GetPlayer().GetAverageMoveSpeed() <= 1.0f)
			{
				++mlHunt_AttackCount;
			}
		}
		else
		{
			mlHunt_AttackCount = 0;
		}
		
		mfHunt_PlayerStartHealth = Player_GetHealth();
		
		//////////////////
		// Retreat if the player cannot be reached
		if (cLux_GetGodModeActivated() == false && mlHunt_AttackCount >= 3)
		{
			if (Player_GetHealth() >= mfHunt_PlayerStartHealth)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Can't hit player, retreat");
				mpStateMachine.ChangeState(eStalkerState_Retreat);
			}
		}

		//////////////////
		// Senses
		mBaseObj.SetFOVMul(1.15f);
		mBaseObj.SetSightRangeMul(2.f * mfSightMul);				
		mBaseObj.ResetPlayerDetectionState();
		
		//////////////////
		// Move!
		mpStateMachine.AddTimer("Pursuit", 0.5f);
	}

	//------------------------------------------------------------

	void State_Hunt_Leave()
	{
		mBaseObj.SetFOVMul(1.f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		
		mpPathfinder.SetDirectPathMaxDistanceMul(mfDirectPathMaxDistanceMul);
		
		SetSpeedState(eStalkerSpeed_Run);
		mBaseObj.GetCharBody().SetMaxPositiveMoveSpeed(eCharDir_Forward, gfStalker_RunSpeed);
			
		mvHunt_LastPlayerDir = mBaseObj.GetPlayerPos() - mBaseObj.GetLastKnownPlayerPos();
		mvHunt_LastPlayerDir.y = 0;
		mvHunt_LastPlayerDir.Normalize();

		int lNextState = mpStateMachine.GetNextState();
		if (lNextState != eStalkerState_AttackClose && 
			lNextState != eStalkerState_ThrowPlayer &&
			lNextState != eStalkerState_Stunned &&
			lNextState != eStalkerState_BlockedByProp &&
			lNextState != eStalkerState_Blocked &&
			lNextState != eStalkerState_EvaluateObstacle &&
			lNextState != eStalkerState_BreakDoor)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
	}

	//------------------------------------------------------------

	void State_Hunt_Update(float afTimeStep)
	{
		if (mpStateMachine.GetNextState() != eStalkerState_Hunt) return;
				
		////////////////////////
		// Setup vars
		bool bDoLosCheck = true;
		
		////////////////////////
		// Player hiding
		if (mbPlayerIsHiding)
		{
			tID idProp = Player_GetCurrentHideAreaConnectedProp();
			cLuxProp@ pProp = cLux_ID_Prop(idProp);
			
			/////////////////////
			// Break prop?
			if (pProp !is null && GetIsPropBreakable(pProp))
			{
				cBoundingVolume@ pBounds = pProp.GetMainBody().GetBoundingVolume();
				float fRadius = mBaseObj.GetCharBody().GetSize().x * 1.25f;
			
				if (cMath_CheckAABBSphereCollision(pBounds.GetMin(), pBounds.GetMax(), mBaseObj.GetPosition(), fRadius))
				{
					mlBlocked_PrevState = eStalkerState_Hunt;
					m_idAttackClose_PropToAttack = idProp;
					msAttackClose_Animation = gsStalkerAnim_HitObstacle_Smash;
					mpStateMachine.ChangeState(eStalkerState_AttackClose);
				}
			}
			
			/////////////////////
			// Can't break prop, kill player if close enough!
			else
			{				
				tID idArea = Player_GetCurrentHideArea();
				float fAngle = 0.f;
				float fPlayerAngle = 0.f;
				cVector3f vPlayerPos(0.f);
				GetPlayerHideAreaKillAnimData(idArea, mvHunt_PlayerHideKillAnimPos, vPlayerPos, fAngle, fPlayerAngle);
				
				float fDistSqr = (mvHunt_PlayerHideKillAnimPos - mBaseObj.GetCharBody().GetFeetPosition()).SqrLength();
				if (fDistSqr < 1.5f * 1.5f)
				{
					bDoLosCheck = false;						
					mbKillPlayer_PlayUnderAnimation = true;
					mpStateMachine.ChangeState(eStalkerState_KillPlayer);
				}
			}
			
			return;
		}
		else
		{
			mvHunt_PlayerHideKillAnimPos = cVector3f(0.f);
		}
		
		////////////////////////
		// Check attack range
		if (bDoLosCheck && mbPlayerIsInLos == false)
			return;
		
		////////////////////////
		// Determine attack
		if (cLux_GetGodModeActivated()) 	return;
		if (GetIsAttacking()) 				return;
		if (GetCanKillPlayer() == false)	return;
		
		mpStateMachine.ChangeState(eStalkerState_KillPlayer);
	}

	//------------------------------------------------------------

	bool State_Hunt_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_EnterProximity) return true;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		
		////////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			////////////////////////
			// If player is in sight cancel giving up and reset last prediction
			if (mbPlayerIsInLos)
			{
				mpStateMachine.StopTimer("GiveUpHuntEndOfPath");
				
				mbHunt_PredictedPos = false;
				
				////////////////////////
				// Restart pursuit if it has been cancelled by last pursuit
				if (mpStateMachine.TimerExists("Pursuit") == false)
				{
					mpStateMachine.AddTimer("Pursuit", 0.0f);
				}
			}
			return true;
		}
		
		////////////////////////
		// Player undetected
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{            
            ////////////////////////
			// When losing sight of the player, reveal the position once to simulate
			// the stalker predicting/hearing where the player moved
			if (mbHunt_PredictedPos == false)
			{
				mbHunt_PredictedPos = true;
				mpStateMachine.AddTimer("RevealPlayerPos", 1.f);
			}
			
			return true;
		}
		
		////////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{						
			mpStateMachine.StopTimer("Pursuit");
			
			if (mbHunt_Unreachable)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Can't reach the player, retreat!");
				mpStateMachine.AddTimer("Retreat", 1.f);
			}
			else if (mBaseObj.PlayerIsDetected() == false)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player undetected!");
				mpStateMachine.AddTimer("GiveUpHuntEndOfPath", 1.f);
			}
			else
			{
				mpStateMachine.AddTimer("Pursuit", 0.5f);
			}
			
			return true;
		}

		return false;
	}

	//---------------------------------------------------------

	void State_Hunt_TimerUp(uint64 alId)
	{
		////////////////////////
		// Pursuit
		if (alId == H64("Pursuit"))
		{			
			///////////////////
			// Go to player hide area?
			if (mvHunt_PlayerHideKillAnimPos.SqrLength() > 0.f &&
				mpPathfinder.BuildPathNodeArrayToPos(mvHunt_PlayerHideKillAnimPos, 1))
			{
				mpPathfinder.MoveTo(mvHunt_PlayerHideKillAnimPos, 1.f, false, "");
			}
			
			///////////////////
			// Normal pursuit!
			else
			{			
				cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetLastKnownPlayerPos(), 0.0f, 5.0f, true, true, false, null);
				cVector3f vLastKnownFeetPos = mBaseObj.GetLastKnownPlayerPos() - cVector3f(0, cLux_GetPlayer().GetCharacterBody().GetSize().y / 2.0f, 0);
				
				if (pNode !is null && cMath_Vector3Dist(pNode.GetPosition(), vLastKnownFeetPos) <= 2.5f)
				{
					mbHunt_Unreachable = false;
					mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
				}
				else
				{
					/////////////////////
					// Move to player pos if hiding
					if (mbPlayerIsHiding)
					{
						mvHunt_GoalPos = mBaseObj.GetPlayerFeetPos();		
						if (mpPathfinder.BuildPathNodeArrayToPosDelayed(mvHunt_GoalPos, "Hunt_OnBuildPathNodeArray") == false)
						{
							cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvHunt_GoalPos, 0.f, 3.f, true, false, false, null);
							if (pNode !is null)
								mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
						}
					}
					
					/////////////////////
					// Otherwise, move to node near
					else
					{				
						mbHunt_Unreachable = true;
						@pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetLastKnownPlayerPos(), 0.0f, 10.0f, true, false, false, null);
						if (pNode is null)
						{
							@pNode = mpPathfinder.GetNodeAtPos((mBaseObj.GetPosition() + mBaseObj.GetPlayerPos()) / 2.0f, 0.0f, 10.0f, true, false, false, null);
						}
						
						if (pNode is null)
						{
							cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pursuit: Unreachable, retreat");
							mpStateMachine.AddTimer("Retreat", 0.5);
							return;
						}
						
						cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pursuit: Unreachable, move to closest");
						mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
					}
				}
			}
			
			mpStateMachine.AddTimer("Pursuit", 0.5f);
		}
		
		////////////////////////
		// Retreat
		if (alId == H64("Retreat"))
		{
			mpStateMachine.ChangeState(eStalkerState_Retreat);
		}
		
		////////////////////////
		// Give up hunt
		if (alId == H64("GiveUpHuntEndOfPath"))
		{
			if (mBaseObj.PlayerIsDetected() == false)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Give up hunt, lost player");
				mpStateMachine.ChangeState(eStalkerState_PostHunt);
			}
		}
		
		////////////////////////
		// Reveal player pos
		if (alId == H64("RevealPlayerPos"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reveal player position");
			mBaseObj.RevealPlayerPos();
		}
	}
	
	//------------------------------------------------------------
	
	void Hunt_OnBuildPathNodeArray(bool abSuccessful)
	{
		if (abSuccessful)
		{
			mpPathfinder.MoveTo(mvHunt_GoalPos, 1.f, false);
		}
		else
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvHunt_GoalPos, 0.f, 3.f, true, false, false, null);
			if (pNode !is null)
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
		}
	}
    
    //------------------------------------------------------------

	//} END HUNT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: POST HUNT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvPostHunt_SoundPos;
	int mlPostHunt_SoundPrio = -1;
	bool mbPostHunt_SensesEnabled = true;
	bool mbPostHunt_SoundIsCausedByPlayer = false;
	bool mbPostHunt_SoundIsPhysicsSound = false;
	tString msPostHunt_SoundName = "";
	tID m_idPostHunt_SoundSourceBodyId = tID_Invalid;

	//------------------------------------------------------------

	void State_PostHunt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PostHunt ------", false, true);

		SetAlertState(eStalkerAlertState_Investigating);
		
		mvPostHunt_SoundPos = cVector3f(0.f);
		mlPostHunt_SoundPrio = -1;
		msPostHunt_SoundName = "";
		mbPostHunt_SoundIsCausedByPlayer = false;
		mbPostHunt_SoundIsPhysicsSound = false;
		m_idPostHunt_SoundSourceBodyId = tID_Invalid;
		mbPostHunt_SensesEnabled = false;
		
		mBaseObj.ResetPlayerDetectionState();
		
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Walk);
		
		Terror_RemoveEnemy(mBaseObj.GetID());
		
		mpStateMachine.AddTimer("Scream", 0.5f);
		mpStateMachine.AddTimer("TurnToPlayer", 2.0f);
		mpStateMachine.AddTimer("EnableSenses", 2.0f);
		mpStateMachine.AddTimer("SearchForPlayer", 4.0f);
		mpStateMachine.AddTimer("Exit", 5.0f);
	}
	
	//------------------------------------------------------------

	void State_PostHunt_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_PostHunt_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_PostHunt_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		if (mbPostHunt_SensesEnabled == false) return true;
		if (GetSensesActive() == false) return true;
		
		/////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eStalkerState_Hunt);
			return true;
		}
		
		/////////////////////
		// Sound heard
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetShouldIgnoreSound()) return true;
			
			mvPostHunt_SoundPos = mpStateMachine.GetCurrentMessageData().mvX;
			mlPostHunt_SoundPrio = mpStateMachine.GetCurrentMessageData().mlX;
			msPostHunt_SoundName = mpStateMachine.GetCurrentMessageData().msX;
			mbPostHunt_SoundIsCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player";
			mbPostHunt_SoundIsPhysicsSound = mpStateMachine.GetCurrentMessageData().mlY == 1;
			m_idPostHunt_SoundSourceBodyId = mpStateMachine.GetCurrentMessageData().mID;
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_PostHunt_TimerUp(uint64 alId)
	{
		///////////////////////
		// Sream
		if (alId == H64("Scream"))
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			
			int lPrevState = mpStateMachine.GetPrevState();
			if (lPrevState != eStalkerState_Blocked || 
				lPrevState != eStalkerState_BlockedByProp)
			{
				mBaseObj.PlaySound("Scream", gsStalkerSound_Frustration, true, true);
				mpMover.PlayAnimation(Alert_GetAnim(), 0.3f, false);
			}
		}
		
		///////////////////////
		// Enable senses
		if (alId == H64("EnableSenses"))
		{
			mbPostHunt_SensesEnabled = true;
		}
		
		///////////////////////
		// Turn to player
		if (alId == H64("TurnToPlayer"))
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			mpStateMachine.AddTimer("TurnToPlayer", 0.5f);
		}
		
		///////////////////////
		// Search for player
		if (alId == H64("SearchForPlayer"))
		{
			if (mBaseObj.PlayerIsDetected() == false)
			{
				if (mlPostHunt_SoundPrio < 0)
				{
					mvSearchArea_SearchPos = mBaseObj.GetPosition() + mvHunt_LastPlayerDir * 4.f;
					mpStateMachine.ChangeState(eStalkerState_SearchArea);
				}
				else
				{
					bool bInvestigate = InvestigateSound_RegisterSound(mlPostHunt_SoundPrio, mvPostHunt_SoundPos, msPostHunt_SoundName, 
																	   m_idPostHunt_SoundSourceBodyId, true, false, mbPostHunt_SoundIsCausedByPlayer);
					IncreaseInterest(msPostHunt_SoundName, mvPostHunt_SoundPos, mlPostHunt_SoundPrio, 
									 mbPostHunt_SoundIsCausedByPlayer, mbPostHunt_SoundIsPhysicsSound, 
									 m_idPostHunt_SoundSourceBodyId, bInvestigate);
				}
			}
			else
			{
				mpStateMachine.ChangeState(eStalkerState_Hunt);
			}
		}
		
		///////////////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
		}
	}
	
	//------------------------------------------------------------

	//} END POSTHUNT
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: SEARCH AREA
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlSearchArea_CurrentInterestPosId = -1;
	int mlSearchArea_SearchCount = 0;
	int mlSearchArea_MaxSearchCount = 6;
	cVector3f mvSearchArea_SearchPos(0.f);
	array<cStalker_InterestPosition> mvSearchArea_InterestPositions;
	array<tID> mvSearchArea_BreakPropIds;
	
	//------------------------------------------------------------

	void State_SearchArea_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: SearchArea ------", false, true);
		
		//////////////////
		// Setup state
		SetAlertState(eStalkerAlertState_Investigating);		
		SetSpeedState(eStalkerSpeed_Walk);
		
		//////////////////
		// Get interest positions
		if (mvSearchArea_SearchPos.SqrLength() <= 0.f)
		{
			mvSearchArea_SearchPos = mBaseObj.GetPosition();
		}
		
		if (mvSearchArea_InterestPositions.size() == 0)
		{			
			float fMinDist = 2.f;
			float fMaxDist = 10.f;
			cVector3f vStalkerPos = mBaseObj.GetPosition();			
			
			//////////////////
			// Doors are interesting
			for (int i = 0; i < mvDoorAABBs.size(); ++i)
			{
				cStalker_DoorAABB@ pDoorAABB = mvDoorAABBs[i];
				cVector3f vDoorPos = pDoorAABB !is null ? (pDoorAABB.mvMin + pDoorAABB.mvMax) / 2.f : cVector3f(0.f);
				if (pDoorAABB is null) continue;
				
				//////////////////
				// Skip small doors
				float fSize = pDoorAABB.mvMax.y - pDoorAABB.mvMin.y;
				if (fSize < 1.f) continue;
				
				//////////////////
				// Within dist?
				float fDistToStalkerSqr = (vDoorPos - vStalkerPos).SqrLength();
				if (fDistToStalkerSqr < fMinDist * fMinDist)
					continue;
						
				float fDistToSearchPosSqr = (vDoorPos - mvSearchArea_SearchPos).SqrLength();
				if (fDistToSearchPosSqr > fMaxDist * fMaxDist)
					continue;
				
				//////////////////
				// Add!
				cLuxProp@ pDoor = cLux_ToProp(cLux_GetBodyEntity(cLux_ID_Body(pDoorAABB.m_idBodyId)));
				tID idDoor = pDoor !is null ? pDoor.GetID() : tID_Invalid;
				
				cStalker_InterestPosition interestPos;
				interestPos.mvPos = vDoorPos;
				interestPos.m_idBreakProp = pDoor !is null && pDoor.GetBreakActive() && pDoor.GetDisableBreakable() == false ? idDoor : tID_Invalid;
				mvSearchArea_InterestPositions.push_back(interestPos);
			}
			
			//////////////////
			// Hide areas are also interesting
			for (int i = 0; i < mvHideAreaIds.size(); ++i)
			{
				cLuxArea@ pArea = cLux_ID_Area(mvHideAreaIds[i]);
				cVector3f vAreaPos = pArea !is null ? pArea.GetPosition() : cVector3f(0.f);
				if (pArea is null) continue;
				
				//////////////////
				// Within dist?
				float fDistToStalkerSqr = (vAreaPos - vStalkerPos).SqrLength();
				if (fDistToStalkerSqr < fMinDist * fMinDist)
					continue;
				
				float fDistToSearchPosSqr = (vAreaPos - mvSearchArea_SearchPos).SqrLength();
				if (fDistToSearchPosSqr > fMaxDist * fMaxDist)
					continue;
				
				//////////////////
				// Add!				
				cStalker_InterestPosition interestPos;
				interestPos.mvPos = vAreaPos;
				interestPos.m_idBreakProp = HideArea_GetConnectedProp(pArea.GetName());
				mvSearchArea_InterestPositions.push_back(interestPos);
			}
			
			//////////////////
			// Get some random positions if too few!
			int lWantedPositions = 8;
			if (mvSearchArea_InterestPositions.size() < lWantedPositions)
			{
				int lRandomPosNum = lWantedPositions - mvSearchArea_InterestPositions.size();
				for (int i = 0; i < lRandomPosNum; ++i)
				{
					cVector3f vDir = cMath_MatrixMul(cMath_MatrixRotateY(cMath_RandRectf(0.f, cMath_PiMul2)), cVector3f_Forward);
					cVector3f vPos = mvSearchArea_SearchPos + vDir * cMath_RandRectf(fMinDist, fMaxDist);
					
					cStalker_InterestPosition interestPos;
					interestPos.mvPos = vPos;
					interestPos.m_idBreakProp = tID_Invalid;
					mvSearchArea_InterestPositions.push_back(interestPos);
				}
			}
			
			//////////////////
			// Skip positions too close to each other
			for (int i = 0; i < mvSearchArea_InterestPositions.size(); ++i)
			{				
				for (int j = 0; j < mvSearchArea_InterestPositions.size(); ++j)
				{
					if (j == i) continue;
					
					cVector3f vPosA = mvSearchArea_InterestPositions[i].mvPos;
					cVector3f vPosB = mvSearchArea_InterestPositions[j].mvPos;
					vPosB.y = vPosA.y;
					
					float fDistSqr = (vPosA - vPosB).SqrLength();
					if (fDistSqr > 3.f * 3.f)
						continue;
					
					if (cMath_RandRectl(0, 1) == 0)
					{
						mvSearchArea_InterestPositions.removeAt(i);
						--i;
					}
					else
					{
						mvSearchArea_InterestPositions.removeAt(j);
					}		
		
					break;
				}
			}
			
			//////////////////
			// Store array of break prop ids
			mvSearchArea_BreakPropIds.resize(mvSearchArea_InterestPositions.size());
			for (int i = 0; i < mvSearchArea_InterestPositions.size(); ++i)
			{
				cStalker_InterestPosition@ pInterestPos = mvSearchArea_InterestPositions[i];
				
				if (pInterestPos is null) continue;
				if (pInterestPos.m_idBreakProp == tID_Invalid) continue;
				
				mvSearchArea_BreakPropIds[i] = pInterestPos.m_idBreakProp;
			}
			
			//////////////////
			// Max search count
			int lMaxSearchCount;
			switch (Blackboard_GetStalkerEscalation())
			{
				case eStalkerEscalation_None: 	lMaxSearchCount = 2;	break;
				case eStalkerEscalation_Stage1: lMaxSearchCount = 2; 	break;
				case eStalkerEscalation_Stage2: lMaxSearchCount = 5;	break;
				case eStalkerEscalation_Stage3: lMaxSearchCount = 6;	break;
			}
			
			mlSearchArea_SearchCount = 0;
			mlSearchArea_MaxSearchCount = lMaxSearchCount;
		}
		
		//////////////////
		// Start searching!
		mpStateMachine.AddTimer("GoToInterestPos", 0.1f);
	}
	
	//------------------------------------------------------------

	void State_SearchArea_Leave()
	{
		msAnimState = "";
		mvSearchArea_SearchPos = cVector3f(0.f);
	}
	
	//------------------------------------------------------------

	void State_SearchArea_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_SearchArea_Message(int alMessageId)
	{
		/////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			//////////////////
			// Break prop by interest pos?
			cStalker_InterestPosition@ pInterestPos = mvSearchArea_InterestPositions[mlSearchArea_CurrentInterestPosId];
			if (pInterestPos !is null &&
				cLux_ID_Prop(pInterestPos.m_idBreakProp) !is null)
			{
				float fChance;
				switch (Blackboard_GetStalkerEscalation())
				{
					case eStalkerEscalation_None: 	fChance = 0.10f; 	break;
					case eStalkerEscalation_Stage1: fChance = 0.20f; 	break;
					case eStalkerEscalation_Stage2: fChance = 0.70f; 	break;
					case eStalkerEscalation_Stage3:	fChance = 0.80f;	break;
				}
				
				if (cMath_RandRectf(0.f, 1.f) <= fChance)
				{
					SearchArea_Advance(false);
				
					SetPreBlockedState(eStalkerState_SearchArea);		
					m_idBlockedByProp_Entity = pInterestPos.m_idBreakProp;
					mpStateMachine.ChangeState(eStalkerState_BlockedByProp);
					return true;
				}
			}
			
			//////////////////
			// Look around!
			msAnimState = "LookAround";
			
			tString sAnim = GetRandomLookAroundSideAnim();
			mpMover.PlayAnimation(sAnim, 0.3f, false);
			return true;
		}
		
		/////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "LookAround")
			{				
				SearchArea_Advance(true);
			}
			
			msAnimState = "";
			return true;
		}
		
		return false;
	}
		
	//------------------------------------------------------------

	void State_SearchArea_TimerUp(uint64 alId)
	{
		////////////////
		// Go to interest pos
		if (H64("GoToInterestPos") == alId)
		{			
			cVector3f vPos = SearchArea_GetSearchPos();				
			if (vPos.SqrLength() <= 0.f)
			{
				SearchArea_LeaveState();
				return;
			}
			
			mpPathfinder.MoveTo(vPos, 1.f, false);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Moving to interest pos!", false, true);
		}
	}
	
	//------------------------------------------------------------
	
	int SearchArea_GetRandomInterestPosId()
	{
		return mvSearchArea_InterestPositions.size() == 0 ? -1 : cMath_RandRectl(0, mvSearchArea_InterestPositions.size() - 1);
	}
	
	//------------------------------------------------------------
	
	cVector3f SearchArea_GetSearchPos()
	{						
		while (mvSearchArea_InterestPositions.size() > 0)
		{
			if (mlSearchArea_CurrentInterestPosId == -1)
			{
				mlSearchArea_CurrentInterestPosId = SearchArea_GetRandomInterestPosId();
				if (mlSearchArea_CurrentInterestPosId == -1) break;
			}
				
			cVector3f vPos = mvSearchArea_InterestPositions[mlSearchArea_CurrentInterestPosId].mvPos;
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(vPos, 1.5f, 4.5f, true, false, false, null);
			
			if (pNode !is null &&
				SearchArea_GetIsValidInterestPos(pNode.GetPosition()))
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found valid interest pos!", false, true);
				return pNode.GetPosition();
			}
			else
			{
				SearchArea_RemoveCurrentInterestPos();
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Removing invalid interst pos!", false, true);
			}
		}
		
		return cVector3f(0.f);
	}
	
	//------------------------------------------------------------
	
	void SearchArea_RemoveCurrentInterestPos()
	{
		if (mlSearchArea_CurrentInterestPosId > -1 && 
			mlSearchArea_CurrentInterestPosId < mvSearchArea_InterestPositions.size())
		{
			mvSearchArea_InterestPositions.removeAt(mlSearchArea_CurrentInterestPosId);
		}
		
		mlSearchArea_CurrentInterestPosId = -1;
	}
	
	//------------------------------------------------------------
	
	bool SearchArea_GetIsValidInterestPos(const cVector3f &in avPos)
	{
		////////////////
		// Can get there, not too far away?
		if (avPos.SqrLength() <= 0.f)
			return false;		
		if (mpPathfinder.BuildPathNodeArrayToPos(avPos, 1) == false)
			return false;			
		if (mpPathfinder.GetPathNodeArrayFullLength() > 15.f)
			return false;
		
		////////////////
		// Not going through too many doors?
		int lDoorCount = 0;		
		for (int i = 1; i < mpPathfinder.GetPathNodeArraySize(); ++i)
		{
			cAINode@ pNode = mpPathfinder.GetPathNodeArrayNode(i);
			cAINode@ pPrevNode = mpPathfinder.GetPathNodeArrayNode(i - 1);
			
			if (pNode is null) continue;
			if (pPrevNode is null) continue;
			
			cVector3f vStart = pPrevNode.GetPosition();
			cVector3f vEnd = pNode.GetPosition();
			
			for (int j = 0; j < mvDoorAABBs.size(); ++j)
			{
				cStalker_DoorAABB@ pAABB = mvDoorAABBs[j];
				if (pAABB is null) continue;
				
				float fT;
				cVector3f vIntersectPos;
				if (cMath_CheckAABBLineIntersection(pAABB.mvMin, pAABB.mvMax, vStart, vEnd, vIntersectPos, fT))
				{
					++lDoorCount;					
					if (lDoorCount > 2)
						return false;
				}
			}
		}
			
		return true;
	}
	
	//------------------------------------------------------------
	
	void SearchArea_Advance(bool abMove)
	{
		//////////////////
		// Remove current pos index
		if (mlSearchArea_CurrentInterestPosId >= 0 &&
			mlSearchArea_CurrentInterestPosId < mvSearchArea_InterestPositions.size())
		{
			SearchArea_RemoveCurrentInterestPos();
		}
			
		//////////////////
		// Searched enough?
		++mlSearchArea_SearchCount;
		if (mlSearchArea_SearchCount >= mlSearchArea_MaxSearchCount)
		{
			SearchArea_LeaveState();
			return;
		}
				
		//////////////////
		// No more positions?
		if (mvSearchArea_InterestPositions.size() == 0)
		{
			SearchArea_LeaveState();
			return;
		}
				
		//////////////////
		// Go again!
		if (abMove)
		{
			mpStateMachine.AddTimer("GoToInterestPos", 0.f);
		}
	}
	
	//------------------------------------------------------------
	
	void SearchArea_LeaveState()
	{
		mlSearchArea_CurrentInterestPosId = -1;
		mvSearchArea_InterestPositions.resize(0);
		
		mpStateMachine.ChangeState(eStalkerState_Idle);
					
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No search positions, entering idle.", false, true);
	}
	
	//------------------------------------------------------------

	//} END SEARCH AREA
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: CHECK LAST KNOWN POSITION
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvCheckLastKnownPosition_Goal = 0.f;
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CheckLastKnownPosition ------", false, true);
				
		if (mAlertState == eStalkerAlertState_None) 
			mpPathfinder.Stop();
					
		SetSpeedState(eStalkerSpeed_Run);
				
		mvCheckLastKnownPosition_Goal = mBaseObj.GetLastKnownPlayerPos();			
		mpStateMachine.AddTimer("MoveToLastKnownPos", mAlertState == eStalkerAlertState_None ? 0.5f : 0.0f);
		SetAlertState(eStalkerAlertState_Investigating);
	}
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_CheckLastKnownPosition_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo && mbPlayerIsInLos) return true;
		
		///////////////////////
		// Hit by flashlight
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			int lNewState = mpStateMachine.GetPrevState() == eStalkerState_Alert ? eStalkerState_PreHunt : eStalkerState_Alert;
			mpStateMachine.ChangeState(lNewState);
			return true;
		}
		
		///////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			int lNewState = mpStateMachine.GetPrevState() == eStalkerState_Alert ? eStalkerState_PreHunt : eStalkerState_Alert;
			mpStateMachine.ChangeState(lNewState);
			
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return true;
		}
		
		///////////////////////
		// Ignore sound if it's too close to the last known position
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetShouldIgnoreSound()) return true;
			if (mpStateMachine.GetCurrentMessageData().msX == "Gunshot") return false;
			if ((mvCheckLastKnownPosition_Goal - mpStateMachine.GetCurrentMessageData().mvX).Length() < 2.f) return true;
		}	
		
		///////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mBaseObj.PlaySound("LostTrackSmall", gsStalkerSound_LostTrackSmall, true, true);
			
			msAnimState = "NothingFound";
			mpMover.PlayAnimation(gsStalkerAnim_ShrugOff, 0.3f, false);
			return true;
		}
		
		///////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "NothingFound")
			{
				msAnimState = "";
				mpStateMachine.AddTimer("Exit", cMath_RandRectf(0.f, 0.5f));
			}
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_TimerUp(uint64 alId)
	{
		///////////////////////
		// Go to pos
		if (alId == H64("MoveToLastKnownPos"))
		{
			cAINode@ pNode = mpPathfinder.GetNodeInPosLOS(mvCheckLastKnownPosition_Goal - mBaseObj.GetPlayerDir() * 2.f, mvCheckLastKnownPosition_Goal, 0.0f, 5.0f);
			
			if (mBaseObj.Timer_Exists("Timer_PlayerMadeLotsOfNoise"))
				@pNode = mpPathfinder.GetNodeAtPos(mvCheckLastKnownPosition_Goal, 0.f, 5.f, true, false, false, null);
			
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
			}
			else
			{
				mpStateMachine.ChangeState(eStalkerState_Idle);
			}
		}
		
		///////////////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
		}
	}
	
	//------------------------------------------------------------

	//} END CHECK LAST KNOWN POSITION
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: PLAYER LIGHT DETECTED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbPlayerLightDetected_DetectedGobo = false;
	bool mbPlayerLightDetected_DetectedFlash = false;
	cVector3f mvPlayerLightDetected_LastPlayerPos = cVector3f(0.f);
	cVector3f mvPlayerLightDetected_InterestPos = cVector3f(0.f);
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PlayerLightDetected ------");
		
		////////////////
		// Setup state
		SetAlertState(eStalkerAlertState_Investigating);
		
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Walk);
		
		mbPlayerLightDetected_DetectedGobo = false;
		mbPlayerLightDetected_DetectedFlash = false;
		mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
		
		////////////////
		// Do behaviour
		mpStateMachine.AddTimer("PlayAnim", cMath_RandRectf(0.3f, 0.5f));
	}
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_Leave()
	{
		mvPlayerLightDetected_InterestPos = cVector3f(0.f);
		mpMover.SetUseMoveStateAnimations(true);
	}
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_Update(float afTimeStep)
	{
		///////////////////////
		// Enter alert?
		if (mBaseObj.GetDistanceToPlayer() < 8.f && mBaseObj.PlayerIsDetected())
		{
			mpStateMachine.ChangeState(eStalkerState_Alert);
		}
	}
	
	//------------------------------------------------------------

	bool State_PlayerLightDetected_Message(int alMessageId)
	{
		////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			////////////////////
			// Player light detected
			if (msAnimState == "PlayerLightDetected")
			{
				msAnimState = "PlayerLightDetectedEnd";
				
				tString sAnim = mpStateMachine.GetCurrentMessageData().msX;
				PlayGlimpseEndAnim(sAnim);
			}			
			else if (msAnimState == "PlayerLightDetectedEnd")
			{
				if (mBaseObj.PlayerIsDetected())
				{
					mpStateMachine.ChangeState(eStalkerState_Alert);
				}
				else if (mbPlayerLightDetected_DetectedFlash)
				{
					mpStateMachine.ChangeState(eStalkerState_CheckFlashlightHit);
				}
				else if (mbPlayerLightDetected_DetectedGobo)
				{
					mpStateMachine.ChangeState(eStalkerState_CheckGobo);
				}
				else
				{
					mpStateMachine.AddTimer("Exit", cMath_RandRectf(1.f, 1.5f));
				}
				
				msAnimState = "";
			}

			return true;
		}
		
		////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			return false;
		}
		
		////////////////////
		// Detect gobo
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
		{
			mbPlayerLightDetected_DetectedGobo = true;
			mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
			return true;
		}
		
		////////////////////
		// Hit by flashlight
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			mbPlayerLightDetected_DetectedFlash = true;
			mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
			
			if (Player_GetIsHiding() && mBaseObj.GetDistanceToPlayer() < 5.f)
			{
				mBaseObj.RevealPlayerPos();
			}
			
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_TimerUp(uint64 alId)
	{				
		////////////////////
		// Play anim
		if (alId == H64("PlayAnim"))
		{
			mBaseObj.PlaySound("Sound_PlayerLightDetected", gsStalkerSound_PlayerDetected, true, true);
			
			msAnimState = "PlayerLightDetected";
			
			tString sAnim = GetLookAnimation(mvPlayerLightDetected_InterestPos, false);
			mpMover.PlayAnimation(sAnim, 0.3f, false, false, "");
		}
		
		////////////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
		}
	}
	
	//------------------------------------------------------------

	//} END PLAYER LIGHT DETECTED
	
	///////////////////////////////////
	// STATE: CHECK GOBO
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvCheckGobo_GoboToPlayer = cVector3f(0.f);
	cVector3f mvCheckGobo_GoboPos = cVector3f(0.f);
	
	//------------------------------------------------------------

	void State_CheckGobo_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CheckGobo ------", false, true);
		
		//////////////////
		// Setup state
		SetSpeedState(eStalkerSpeed_Walk);
		
		mvCheckGobo_GoboPos = mvGoboPos;
		mvCheckGobo_GoboToPlayer = mvPlayerLightDetected_LastPlayerPos - mvGoboPos;
		mvCheckGobo_GoboToPlayer.y = 0;
		
		SetAlertState(eStalkerAlertState_Investigating);
		
		//////////////////
		// Move
		mpStateMachine.AddTimer("MoveTo", 0.f);
	}
	
	//------------------------------------------------------------

	void State_CheckGobo_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_CheckGobo_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_CheckGobo_Message(int alMessageId)
	{		
		////////////////////
		// Detect gobo
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
		{
			if (mpStateMachine.TimerExists("MoveTo") == false)
			{
				mvCheckGobo_GoboPos = mvGoboPos;
				mvCheckGobo_GoboToPlayer = mBaseObj.GetPlayerPos() - mvGoboPos;
				mvCheckGobo_GoboToPlayer.y = 0.f;
				
				mpStateMachine.AddTimer("MoveTo", 0.2f);
			}
			
			return true;
		}
		
		////////////////////
		// Hit by flashlight
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			mpStateMachine.ChangeState(eStalkerState_CheckFlashlightHit);
			return true;
		}
		
		////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			mpStateMachine.ChangeState(eStalkerState_Alert);
			
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return true;
		}
		
		////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Nothing found");
			
			mBaseObj.PlaySound("LostTrackSmall", gsStalkerSound_LostTrackSmall, true, true);
			
			msAnimState = "NothingFound";
			mpMover.PlayAnimation(gsStalkerAnim_ShrugOff, 0.3f, false);
		}
		
		////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "NothingFound")
			{
				msAnimState = "";
				mpStateMachine.AddTimer("Exit", cMath_RandRectf(0.f, 0.5f));
			}
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_CheckGobo_TimerUp(uint64 alId)
	{
		////////////////////
		// Move to
		if (alId == H64("MoveTo"))
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvCheckGobo_GoboPos + mvCheckGobo_GoboToPlayer * 0.6f, 0.f, 5.f, true, false, false, null);
			cVector3f vPos = pNode is null ? mvGoboPos : pNode.GetPosition();
			
			mpPathfinder.MoveTo(vPos, 1.f, false);
		}
		
		////////////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
		}
	}
	
	//------------------------------------------------------------

	//} END CHECK GOBO
	
	///////////////////////////////////
	// STATE: CHECK FLASHLIGHT HIT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvCheckFlashlightHit_PlayerPos = cVector3f(0.f);
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CheckFlashlightHit ------", false, true);
		
		////////////////
		// Setup state		
		SetSpeedState(eStalkerSpeed_Walk);
		mBaseObj.ResetPlayerDetectionState();
		
		SetAlertState(eStalkerAlertState_Investigating);
		
		mvCheckFlashlightHit_PlayerPos = mvPlayerLightDetected_LastPlayerPos;		
		
		////////////////
		// Move
		mpStateMachine.AddTimer("MoveTo", 0.f);
	}
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_CheckFlashlightHit_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		
		////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			mpStateMachine.ChangeState(eStalkerState_Alert);
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return true;
		}
		
		////////////////////
		// Hit by flashlight
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (Player_GetIsHiding() && mBaseObj.GetDistanceToPlayer() < 5.f)
			{
				mBaseObj.RevealPlayerPos();
			}
			return true;
		}
		
		////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Nothing found");
			
			mBaseObj.PlaySound("LostTrackSmall", gsStalkerSound_LostTrackSmall, true, true);
			
			msAnimState = "NothingFound";
			mpMover.PlayAnimation(gsStalkerAnim_ShrugOff, 0.3f, false);
		}
		
		////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "NothingFound")
			{
				msAnimState = "";
				mpStateMachine.AddTimer("Exit", cMath_RandRectf(0.f, 0.5f));
			}
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_TimerUp(uint64 alId)
	{		
		////////////////////
		// Move to
		if (alId == H64("MoveTo"))
		{
			cVector3f vToPlayer = mvCheckFlashlightHit_PlayerPos - mBaseObj.GetPosition();
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vToPlayer * 0.6f, 0.f, 5.f, true, false, false, null);
			
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
			}
			else
			{
				mpStateMachine.AddTimer("Exit", 2.f);
			}
		}
		
		////////////////////
		// Exit
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eStalkerState_Idle);
		}
	}
	
	//------------------------------------------------------------

	//} END FLASHLIGHT HIT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: ATTACK (CLOSE)
	//{////////////////////////////////

	//------------------------------------------------------------
	
	int mlAttackClose_AnimEventId = 0;
	tString msAttackClose_Animation = "";
	tID m_idAttackClose_PropToAttack = tID_Invalid;

	//------------------------------------------------------------

	void State_AttackClose_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: AttackClose ------", false, true);
		
		mpProximitySensor.ResetAllStates();
		mpPathfinder.Stop();
		
		mlAttackClose_AnimEventId = 0;
		if (msAttackClose_Animation == "")
			msAttackClose_Animation = cMath_RandRectl(0, 1) == 0 ? gsStalkerAnim_HitObstacle_Sweep : gsStalkerAnim_HitObstacle_Smash;
		
		mBaseObj.Timer_Add("Timer_IgnorePhysicsSounds", 3.f);
		mBaseObj.Timer_Add("Timer_IgnoreNearSounds", 3.f);
		
		mpStateMachine.AddTimer("Attack", 0.2);
	}

	//------------------------------------------------------------

	void State_AttackClose_Leave()
	{		
		m_idAttackClose_PropToAttack = tID_Invalid;
		msAttackClose_Animation = "";
		
		mBaseObj.ResetPlayerDetectionState();
		
		mpAttackDamage.Stop(0);
		
		if (mpStateMachine.GetPrevState() == eStalkerState_Hunt && mpStateMachine.GetNextState() != eStalkerState_Hunt)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
	}

	//------------------------------------------------------------

	void State_AttackClose_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------
	
	bool State_AttackClose_Message(int alMessageId)
	{				
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
	
		////////////////////
		// Anim message
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			////////////////////
			// Start damage!
			if (mlAttackClose_AnimEventId == 0)
			{				
				mpAttackDamage.Start(0, 1.f, 30.f);
			}
			
			////////////////////
			// Stop damage!
			else if (mlAttackClose_AnimEventId == 1)
			{
				mpAttackDamage.Stop(0);
				
				////////////////////
				// Deal with prop!
				cLuxProp@ pProp = cLux_ID_Prop(m_idAttackClose_PropToAttack);
				if (pProp !is null)
				{
					////////////////////
					// Break if possible
					if (GetIsPropBreakable(pProp))
					{
						BreakProp(pProp);
					}
					
					////////////////////
					// Otherwise, disable agent collision and push away
					else if (pProp.GetIsDoor() == false)
					{
						iCharacterBody@ pCharBody = mBaseObj.GetCharBody();						
						cVector3f vDir = cMath_RandRectl(0, 1) == 1 ? pCharBody.GetRight() : pCharBody.GetRight() * -1.f;
						vDir += pCharBody.GetForward();					
						
						for (int i = 0; i < pProp.GetBodyNum(); ++i)
						{
							iPhysicsBody@ pBody = pProp.GetBody(i);				
							
							pBody.SetCollideFlags(mBaseObj.GetMap().GetCollideFlag("-agent"));
							pBody.AddImpulse(vDir * 4.f);
							pBody.AddTorque(cMath_RandomSphereSurfacePoint(cMath_RandRectf(75.f, 100.f)));
						}						
						
						////////////////////
						// Add prop to ignore list!
						mvEvaluateObstacle_IgnoredProps.push_back(pProp.GetID());
					}					
				}
			}
			
			++mlAttackClose_AnimEventId;			
			return true;
		}
		
		////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			////////////////////
			// Leave state
			if (mlAttackClose_AnimEventId > 0)
			{						
				if (mbBossFight_Active)
				{
					mpStateMachine.ChangeState(BossFight_GetCurrentState());
					return true;
				}
				
				mpStateMachine.ChangeState(mlBlocked_PrevState);
				
				if (mBlockedByProp_PrevSpeedState != eStalkerSpeed_Stopped)
					SetSpeedState(mBlockedByProp_PrevSpeedState);
			}
			
			return true;
		}

		return true;
	}
	
	//------------------------------------------------------------

	void State_AttackClose_TimerUp(uint64 alId)
	{
		if (alId == H64("Attack"))
		{
			mBaseObj.PlaySound("AttackSound", gsStalkerSound_Attack, true, true);
			mpMover.PlayAnimation(msAttackClose_Animation, 0.3f);
		}
	}

	//------------------------------------------------------------

	//} END ATTACK CLOSE		
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: STUNNED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbStunned_Stunned = false;
	bool mbStunned_Detected = false;

	//------------------------------------------------------------

	void State_Stunned_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Stunned ------", false, true);
		
		SetAlertState(eStalkerAlertState_Detected);
		
		////////////////////
		// Setup state
		mbStunned_Stunned = true;
		mbStunned_Detected = false;
		
		mpPathfinder.Stop();		
		SetSpeedState(eStalkerSpeed_Stopped);
		
		////////////////////
		// Increase player detection
		mBaseObj.SetFOVMul(1.3f);
		mBaseObj.SetSightRangeMul(2.f * mfSightMul);
		
		////////////////////
		// Decide action
		bool bPlayAnim = true;
		cAnimationState@ pState = mBaseObj.GetCurrentAnimationState();
		
		if (pState !is null && 
			cString_GetFirstStringPos(pState.GetName(), "alert") != -1)
		{
			bPlayAnim = false;
		}
		
		if (mlAlert_LastAlertTimeStamp > 0 && 
			mBaseObj.GetMap().GetElapsedTime(mlAlert_LastAlertTimeStamp) < 5.f)
		{
			bPlayAnim = false;
		}		
		
		if (bPlayAnim)
		{
			msAnimState = "Stunned";
			mpMover.PlayAnimation(gsStalkerAnim_Hurt, 0.3f, false, true);
			
			mpStateMachine.AddTimer("HitSound", 0.1f);
		}
		else
		{
			mpStateMachine.AddTimer("DecideAction", 0.3f);
		}
	}

	//------------------------------------------------------------

	void State_Stunned_Leave()
	{		
		mpMover.SetUseMoveStateAnimations(true);
		
		////////////////////
		// Reset player detection
		mBaseObj.SetFOVMul(1.f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		
		if (mpStateMachine.GetPrevState() == eStalkerState_Hunt && mpStateMachine.GetNextState() != eStalkerState_Hunt)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
	}

	//------------------------------------------------------------

	void State_Stunned_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Stunned_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_SoundNotHeard) return true;
		
		////////////////////
		// Stunned anim over?
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "Stunned")
			{
				Stunned_DecideAction();
			}
		}
		
		////////////////////
		// Player detected
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (mbBossFight_Active) return true;
			
			mbStunned_Detected = true;
			if (mbStunned_Stunned == false)
			{
				mpStateMachine.ChangeState(eStalkerState_Hunt);
			}
			
			GameStats_IncreaseEntryAmount(eHeroStats_TimesSpottedByStalker);
			return true;
		}
		
		////////////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_Stunned_TimerUp(uint64 alId)
	{		
		///////////////////
		// Hit sound
		if (alId == H64("HitSound"))
		{
			mBaseObj.PlaySound("Hit", gsStalkerSound_BeHit, true, true);
		}
		
		///////////////////
		// Search for player
		else if (alId == H64("SearchForPlayer"))
		{
			mvSearchArea_SearchPos = mBaseObj.GetPosition() + mBaseObj.GetPlayerDir() * 4.f;
			mpStateMachine.ChangeState(eStalkerState_SearchArea);
		}
		
		///////////////////
		// Decide action
		else if (alId == H64("DecideAction"))
		{
			Stunned_DecideAction();
		}
	}
	
	//------------------------------------------------------------
	
	void Stunned_DecideAction()
	{
		mbStunned_Stunned = false;
		
		///////////////
		// Boss fight active?
		if (mbBossFight_Active)
		{
			cLuxProp@ pProp = cLux_ID_Prop(m_idLastHitByPropThrownByPlayerId);
			if (pProp !is null && 
				pProp.GetClassName() == "cScrPropGrenade" &&
				BossFightRetreat_Setup())
			{
				BossFight_UpdateBehaviour(eStalkerBossFightBehaviour_Retreat);
				return;
			}
			
			mpStateMachine.ChangeState(BossFight_GetCurrentState());
			return;
		}
		
		///////////////
		// Hunt or search for player!
		int lPrevState = mpStateMachine.GetPrevState();				
		if (mbStunned_Detected || 
			mBaseObj.PlayerIsDetected() || 
			lPrevState == eStalkerState_Hunt || 
			lPrevState == eStalkerState_PreHunt)
		{
			mpStateMachine.ChangeState(eStalkerState_Hunt);
		}
		else
		{
			mpStateMachine.AddTimer("SearchForPlayer", cMath_RandRectf(1.f, 2.f));
		}
	}

	//------------------------------------------------------------

	//} END STUNNED    
   
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: BLOCKED
	//{////////////////////////////////

	//------------------------------------------------------------

	int mlBlocked_PrevState = eStalkerState_Idle;
	
	//------------------------------------------------------------

	void State_Blocked_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Blocked ------", false, true);
		
		mpPathfinder.Stop();
		mBaseObj.ResetPlayerDetectionState();
		
		//////////////////
		// Update no collision bodies
		mfNoCollisionBodiesUpdateCount = 0.f;
		UpdateNoCollisionBodies(0.f);
		
		///////////////////
		// Set state before being blocked
		SetPreBlockedState(mpStateMachine.GetPrevState());		
		
		///////////////////
		// Check if we are blocked by a prop	
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		cVector3f vBoxCenter = pCharBody.GetPosition() + pCharBody.GetForward() * 0.5f;
		cVector3f vBoxMin = vBoxCenter - cVector3f(1.f);
		cVector3f vBoxMax = vBoxCenter + cVector3f(1.f);
		
		array<iPhysicsBody@> vBodies;
		mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(vBoxMin, vBoxMax, false, false, vBodies);
		
		int lBlockingProps = 0;
		array<cLuxProp@> vBreakableProps;
		array<cLuxProp@> vPushableProps;
		
		for (uint i = 0; i < vBodies.size(); ++i)
		{
			iPhysicsBody@ pBody = vBodies[i];
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			
			if (pBody is null) continue;
			if (pProp is null) continue;
			if (pProp.IsActive() == false) continue;
			if (pBody.GetMass() == 0.f && GetIsPropBreakable(pProp) == false) continue;
			if (pBody.IsCharacter()) continue;
			
			if (mbBossFight_Active)
			{
				if (mvBossFight_BridgeEntityIds.find(pProp.GetID()) != -1)
					continue;
			}
			
			++lBlockingProps;
			
			///////////////////
			// If we can break it/interact with it, save it!
			if ((pProp.GetIsDoor() || GetIsPropBreakable(pProp)) && pProp.GetHealth() > 0.f)
			{
				vBreakableProps.push_back(pProp);
			}
			
			///////////////////
			// Otherwise, we can still push it!
			else
			{
				vPushableProps.push_back(pProp);
			}
		}
		
		///////////////////
		// If many, prioritize the ones colliding with the agent!
		cLuxProp@ pPropToBreak = null;
		cLuxProp@ pPropToPush = null;
		cBoundingVolume@ pStalkerBV = pCharBody.GetCurrentBody().GetBoundingVolume();
		
		for (uint i = 0; i < vBreakableProps.size(); ++i)
		{
			@pPropToBreak = vBreakableProps[i];
			cBoundingVolume@ pPropBV = pPropToBreak !is null ? pPropToBreak.GetMainBody().GetBoundingVolume() : null;
			
			if (pPropToBreak is null) continue;
			if (pPropBV is null) continue;		
			
			if (cMath_CheckAABBIntersection(pStalkerBV.GetMin(), pStalkerBV.GetMax(), pPropBV.GetMin(), pPropBV.GetMax()))
				break;
		}
		
		for (uint i = 0; i < vPushableProps.size(); ++i)
		{
			@pPropToPush = vPushableProps[i];
			cBoundingVolume@ pPropBV = pPropToPush !is null ? pPropToPush.GetMainBody().GetBoundingVolume() : null;
			
			if (pPropToPush is null) continue;
			
			if (cMath_CheckAABBIntersection(pStalkerBV.GetMin(), pStalkerBV.GetMax(), pPropBV.GetMin(), pPropBV.GetMax()))
				break;
		}
		
		///////////////////
		// Enter blocked by prop!
		if (pPropToBreak !is null)
		{
			m_idBlockedByProp_Entity = pPropToBreak.GetID();
			mpStateMachine.ChangeState(eStalkerState_BlockedByProp);
			return;
		}
		
		///////////////////
		// Try pushing the blockage!
		if (lBlockingProps > 0 && mBaseObj.Timer_Exists("BlockagePushCooldown") == false)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Cannot break, push away blockage");
			
			m_idAttackClose_PropToAttack = pPropToPush !is null ? pPropToPush.GetID() : tID_Invalid;
			msAttackClose_Animation = gsStalkerAnim_HitObstacle_Shove;
			mpStateMachine.ChangeState(eStalkerState_AttackClose);
				
			mBaseObj.Timer_Add("BlockagePushCooldown", 5.f);
			return;
		}
		
		///////////////////
		// Final fail safe -- retreat!
		int lNewState = eStalkerState_Retreat;		
		if (mbBossFight_Active)
		{
			if (BossFightRetreat_Setup())
			{
				mBossFight_Behaviour = eStalkerBossFightBehaviour_Retreat;
				lNewState = eStalkerState_BossFight_Retreat;
			}
			else
			{
				lNewState = eStalkerState_BossFight_Default;
			}
		}
		
		mpStateMachine.ChangeState(lNewState);
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Blocked and can't do anything about it, retreating!");
	}

	//------------------------------------------------------------

	void State_Blocked_Leave()
	{
	}

	//------------------------------------------------------------

	void State_Blocked_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_Blocked_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return true;
		if (alMessageId == eLuxEntityMessage_EndOfPath) return false;
		
		///////////////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}
		
		return false;
	}

	//------------------------------------------------------------

	void State_Blocked_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------

	//} END BLOCKED

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: BLOCKED BY PROP
	//{////////////////////////////////

	//------------------------------------------------------------
	
	array<bool> mvBlockedByProp_BodyCollideChar;
	cVector3f mvBlockedByProp_DoorDir = 0.f;
	cVector3f mvBlockedByProp_PathGoalPos(0.f);
	tID m_idBlockedByProp_Entity = tID_Invalid;
	eStalkerSpeed mBlockedByProp_PrevSpeedState = eStalkerSpeed_Walk;
	
	//------------------------------------------------------------

	void State_BlockedByProp_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BlockedByProp ------");
		
		mvBlockedByProp_PathGoalPos = mpPathfinder.GetGoalPos();
		mpPathfinder.Stop();
		
		mBlockedByProp_PrevSpeedState = eStalkerSpeed(mpMover.GetSpeedState());
		SetSpeedState(eStalkerSpeed_Walk);
		
		//////////////////////
		// Get blocked prop info
		cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
		tString sPropName = pProp !is null ? pProp.GetName() : "";
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Blocked by: " + sPropName);
		
		//////////////////////
		// Deal with blockage		
		if (pProp.GetIsDoor())
		{
			//////////////////////
			// Is it a slide door?
			bool bSlideDoor = pProp.GetClassName() == "cScrPropSlideDoor";
			if (bSlideDoor)
			{
				// Slide doors are used only in the prison atm and are not supposed to be opened by the agent. 
				mpStateMachine.ChangeState(eStalkerState_Retreat);
				return;
			}
			
			//////////////////////
			// Is it a swing door?
			bool bBlockedDoor = SwingDoor_GetBlocked(sPropName);
			bool bLockedDoor = SwingDoor_GetLocked(sPropName);
			
			//////////////////////
			// Open door
			bool bForceBreak = false;
			for (int i = 0; i < mvSearchArea_BreakPropIds.size(); ++i)
			{								
				if (pProp.GetID() == mvSearchArea_BreakPropIds[i])
				{
					bForceBreak = true;
					break;
				}
			}
			
			if (bForceBreak == false &&
				bLockedDoor == false && 
				bBlockedDoor == false && 
				SwingDoor_GetOpenAmount(sPropName) < gfStalker_SwingDoorObstacleOpenAmount)
			{
				tString sAnim = "";
				cMatrixf mtxDoor = pProp.GetOnLoadTransform();
				cVector3f vDoorDir = SwingDoor_GetDoorwayOpenDir(sPropName);
				cVector3f vToAgent = cMath_Vector3Normalize(mBaseObj.GetPosition() - pProp.GetPosition());
				
				bool bInFront = cMath_Vector3Dot(vToAgent, vDoorDir) > 0.f;
				cVector3f vPositioningDir = bInFront ? vDoorDir : vDoorDir * -1.f;
				cVector3f vAnimPos = mtxDoor.GetTranslation() + vPositioningDir * 1.6f;
				float fAnimAngle = cMath_GetAngleFromPoints3D(0.f, vPositioningDir).y + cMath_Pi;				
				
				bool bHingeToTheRight = true;
				iPhysicsJoint@ pHinge = pProp.GetJoint(0);
				if (pHinge !is null)
				{
					cVector3f vHingeDelta = cMath_Vector3Normalize(pHinge.GetPivotPoint() - mtxDoor.GetTranslation());
					cVector3f vDoorRight = cMath_Vector3Normalize(cMath_Vector3Cross(vPositioningDir, cVector3f_Down));
					bHingeToTheRight = cMath_Vector3Dot(vDoorRight, vHingeDelta) > 0.f;
				}
				
				float fOpenTime;
				if (cMath_Vector3Dot(vPositioningDir, vDoorDir) >= 0.f)
				{	
					fOpenTime = 0.8f * 0.7f;
					sAnim = bHingeToTheRight ? gsStalkerAnim_OpenDoorInLeft : gsStalkerAnim_OpenDoorInRight;
					
					if (SwingDoor_GetOpenAmount(sPropName) > 0.001f)
						SwingDoor_Push(sPropName, -1, 1, 2, 0.1f);
				}
				else
				{
					fOpenTime = 0.6f * 0.7f;
					sAnim = bHingeToTheRight ?  gsStalkerAnim_OpenDoorOutLeft : gsStalkerAnim_OpenDoorOutRight;
				}				
				
				msIdleAnim = gsStalkerAnim_Idle;
				msAnimState = "OpenDoor";
				PlayCutsceneAnimation(sAnim, false, 0.3f, "", 1.f, 0.f, true, vAnimPos, fAnimAngle, false, false, false);
				
				mpStateMachine.AddTimer("TryToOpenDoor", fOpenTime);
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Trying to open door!");
			}
			else
			{
				mBaseObj.PlaySound("AngryShout", gsStalkerSound_AngryShout, true, true);
				mpStateMachine.AddTimer("AttackObstacle", 0.2f);			
			}
		}
		
		//////////////////////
		// Push blockage away
		else if (mBaseObj.Timer_Exists("BlockagePushCooldown") == false)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Try to attack blockage!");
			
			if (GetIsPropBreakable(pProp) == false)
				msAttackClose_Animation = gsStalkerAnim_HitObstacle_Shove;
			
			m_idAttackClose_PropToAttack = m_idBlockedByProp_Entity;
			mpStateMachine.ChangeState(eStalkerState_AttackClose);
			
			mBaseObj.Timer_Add("BlockagePushCooldown", 1.f);
		}
		
		//////////////////////
		// Final fallback
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Can't deal with blockage! This shouldn't happen!");
		}
	}

	//------------------------------------------------------------

	void State_BlockedByProp_Leave()
	{		
		msAnimState = "";
		m_idBlockedByProp_Entity = tID_Invalid;
		
		int lNextState = mpStateMachine.GetNextState();
		if (lNextState == mlBlocked_PrevState)
		{
			SetSpeedState(mBlockedByProp_PrevSpeedState);
			mBlockedByProp_PrevSpeedState = eStalkerSpeed_Stopped;
		}
		
		BlockedByProp_ResetAgentPropColl();
	}

	//------------------------------------------------------------

	void State_BlockedByProp_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_BlockedByProp_Message(int alMessageId)
	{				
		///////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "OpenDoor")
			{
				mBaseObj.ResetPlayerDetectionState();
				
				mpStateMachine.StopTimer("CheckDoorOpen");
				mpStateMachine.AddTimer("CheckDoorOpen", 0.f);
			}
			
			msAnimState = "";
			return true;
		}
		
		///////////////////////
		// Checks
		if (mbCutsceneAnimation_Active && msAnimState == "OpenDoor") return true;		
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return true;
		
		///////////////////////
		// Near door
		if (alMessageId == eLuxEntityMessage_NearDoor)
		{
			cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
			if (pProp !is null && pProp.GetIsDoor()) return true;
		}
		
		///////////////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}
		
		return false;
	}

	//------------------------------------------------------------

	void State_BlockedByProp_TimerUp(uint64 alId)
	{
		////////////////////
		// Try to open door
		if (alId == H64("TryToOpenDoor"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Apply force to door");
			
			////////////////////
			// Push open door
			BlockedByProp_DisableAgentPropColl();
			SwingDoor_PushOpen(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName(), 1.0f, 10, 0.1f);			
			
			////////////////////
			// Timers
			mpStateMachine.AddTimer("CheckDoorOpen", 3.f);
			mBaseObj.Timer_Add("Timer_TryingToOpenDoor", 2.f);
		}
			
		////////////////////
		// Attack obstacle
		if (alId == H64("AttackObstacle"))
		{
			m_idBreakDoor_Door = m_idBlockedByProp_Entity;
			mpStateMachine.ChangeState(eStalkerState_BreakDoor);
		}
		
		////////////////////
		// Check door open
		if (alId == H64("CheckDoorOpen"))
		{			
			BlockedByProp_ResetAgentPropColl();
			
			cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
			if (pProp is null) return;
			
			if (SwingDoor_GetOpenAmount(pProp.GetName()) < gfStalker_SwingDoorObstacleOpenAmount)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door isn't open, break it down!");
				mpStateMachine.AddTimer("AttackObstacle", 0.8f);
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door is open, return to previous!");
				mpStateMachine.ChangeState(mlBlocked_PrevState);
			}
		}
	}
	
	//------------------------------------------------------------
	
	void BlockedByProp_DisableAgentPropColl()
	{
		cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
		if (pProp is null) return;
		
		mvBlockedByProp_BodyCollideChar.resize(0);		
		for (int i = 0; i < pProp.GetBodyNum(); ++i)
		{
			iPhysicsBody@ pBody = pProp.GetBody(i);
			
			mvBlockedByProp_BodyCollideChar.push_back(pBody.GetCollideCharacter());
			pBody.SetCollideCharacter(false);
		}
	}
	
	//------------------------------------------------------------
	
	void BlockedByProp_ResetAgentPropColl()
	{
		cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
		if (pProp is null) return;
		
		if (mvBlockedByProp_BodyCollideChar.size() > 0)
		{
			for (int i = 0; i < pProp.GetBodyNum(); ++i)
			{
				iPhysicsBody@ pBody = pProp.GetBody(i);
				pBody.SetCollideCharacter(mvBlockedByProp_BodyCollideChar[i]);
			}
		}
		
		mvBlockedByProp_BodyCollideChar.resize(0);
	}
	
	//------------------------------------------------------------

	//} END BLOCKED BY PROP

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: BREAK DOOR
	//{////////////////////////////////

	//------------------------------------------------------------

	bool mbBreakDoor_DoorIsOpen = false;
	bool mbBreakDoor_DoorCanBeBroken = true;
	bool mbBreakDoor_InvestigateSound = false;
	bool mbBreakDoor_MoveToBreakPos = false;
	int mlBreakDoor_Hits = 0;
	int mlBreakDoor_BlockedByLockedDoorCount = 0;
	cVector3f mvBreakDoor_GoalPos = 0.f;
	tString msBreakDoor_DoorName = "";
	tID m_idBreakDoor_Door = tID_Invalid;

	//------------------------------------------------------------

    void State_BreakDoor_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BreakDoor ------", false, true);
		
		//////////////////
		// Setup state
		mlBreakDoor_Hits = 0;
		mbBreakDoor_InvestigateSound = false;
		mbBreakDoor_DoorCanBeBroken = true;
		mbBreakDoor_MoveToBreakPos = false;
		
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cLuxProp@ pProp = cLux_ID_Prop(m_idBreakDoor_Door);
		msBreakDoor_DoorName = pProp !is null ? pProp.GetName() : "";
		
		//////////////////
		// Fail safe
		if (pProp is null)
		{
			mpStateMachine.ChangeState(eStalkerState_Retreat);
			return;
		}
		
		//////////////////
		// Get door break data
		mbBreakDoor_DoorCanBeBroken = SwingDoor_IsBreakable(msBreakDoor_DoorName);
		mbBreakDoor_DoorIsOpen = SwingDoor_GetOpenAmount(msBreakDoor_DoorName) > 0.1f;
			
		cVector3f vDoorDir = SwingDoor_GetDoorwayOpenDir(msBreakDoor_DoorName);
		cVector3f vToDoor = cMath_Vector3Normalize(pProp.GetPosition() - pCharBody.GetPosition());
		cVector3f vGoalDir = cMath_Vector3Dot(vToDoor, vDoorDir) >= 0.f ? vDoorDir * -1.f : vDoorDir;
			
		mvBreakDoor_GoalPos = pProp.GetPosition();
		mvBreakDoor_GoalPos += vGoalDir * 2.4f;
		mvBreakDoor_GoalPos.y = pCharBody.GetFeetPosition().y;
		
		//////////////////
		// Decide what to do
		mpStateMachine.AddTimer("DecideOnDoorAction", 0.1f);
	}

	//------------------------------------------------------------

	void State_BreakDoor_Leave()
	{
		mBaseObj.GetCharBody().SetTestCollision(true);
	}

	//------------------------------------------------------------
	
	void State_BreakDoor_Update(float afTimeStep)
	{
		/////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();		
		if (pAnim is null) return;
		
		/////////////////
		// Move to break pos
		if (mbBreakDoor_MoveToBreakPos)
		{
			if (pAnim.GetName() != gsStalkerAnim_BreakDoorAlign)
			{
				mpMover.PlayAnimation(gsStalkerAnim_BreakDoorAlign, 0.3f, true);
			}
				
			cVector3f vDir = (mvBreakDoor_GoalPos - pCharBody.GetFeetPosition());
			float fDist = vDir.Length();			
			float fFrameMove = cMath_Clamp(1.3f * afTimeStep, 0.f, fDist);					
			cVector3f vNewPos = pCharBody.GetFeetPosition() + cMath_Vector3Normalize(vDir) * fFrameMove;	
			
			float fYaw = cMath_GetAngleFromPoints3D(0.f, vDir).y + cMath_Pi;
			float fYawAdd = cMath_GetAngleDistanceRad(pCharBody.GetYaw(), fYaw) * afTimeStep * 2.f;
			
			pCharBody.SetTestCollision(false);
			pCharBody.SetFeetPosition(vNewPos, true);
			pCharBody.AddYaw(fYawAdd);
			
			if (mBaseObj.GetDistanceToPos2D(mvBreakDoor_GoalPos) < 0.1f)
			{			
				mbBreakDoor_MoveToBreakPos = false;
				
				mpStateMachine.StopTimer("BreakDoor");
				mpStateMachine.AddTimer("BreakDoor", 0.f);
			}
		}
	}

	//------------------------------------------------------------

	bool State_BreakDoor_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_NearDoor) return true;
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		
		//////////////////////
		// Skip detection while breaking the door
		if (msAnimState == "BreakDoor")
		{
			bool bPointInFront = mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos());
			
			if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
			if (alMessageId == eCustomEntityMessage_HitByFlashlight && bPointInFront) return true;
			if (alMessageId == eLuxEntityMessage_PlayerDetected && bPointInFront) return true;
		}
		
		//////////////////////
		// Animation message
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			//////////////////////
			// Break the door!
			if (msAnimState == "BreakDoor")
			{
				++mlBreakDoor_Hits;
				
				cLuxProp@ pProp = cLux_ID_Prop(m_idBreakDoor_Door);
				if (pProp !is null)
				{				
					/////////////////
					// Break door
					if (mbBreakDoor_DoorCanBeBroken)
					{
						BreakProp(pProp);
						DoDoorImpact(msBreakDoor_DoorName);
						
						mBaseObj.Timer_Add("Timer_IgnorePhysicsSounds", 3.f);
						mBaseObj.Timer_Add("Timer_IgnoreNearSounds", 3.f);
					}
					
					/////////////////
					// Impact effects on unbreakable door
					else
					{
						tID idDoorBody = SwingDoor_GetDoorBodyID(pProp.GetName());
						iPhysicsBody@ pBody = cLux_ID_Body(idDoorBody);
						if (pBody !is null)
						{
							cVector3f vHitDir = mBaseObj.GetCharBody().GetForward();
							pBody.AddImpulse(vHitDir);
							
							cParticleSystem@ pPS = pProp.CreateParticleSystem("PS_DoorHit", "dust_impact_door_hit.ps", true, false);
							if (pPS !is null)
							{
								pPS.SetBrightness(0.3f);
								
								cMatrixf mtxParticle = pPS.GetWorldMatrix();
								mtxParticle.SetRotation(cMath_MatrixRotateY(mBaseObj.GetCharBody().GetYaw()));
								pPS.SetWorldPosition(pPS.GetWorldPosition() + vHitDir * 0.2f);
							}
							
							mBaseObj.PlaySound("Sound_BangOnDoor", gsStalkerSound_HitMetalDoor, true, false);
						}
					}
				}				
			}
		}
		
		//////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "BreakDoor")
			{
				mBaseObj.ResetPlayerDetectionState();
				mpStateMachine.AddTimer("DecideOnDoorAction", 0.f);
			}
			
			msAnimState = "";
		}
		
		//////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mpStateMachine.TimerExists("DecideOnDoorAction") == false)
				mpStateMachine.AddTimer("DecideOnDoorAction", 0.1f);
		}
		
		//////////////////////
		// Sound heard
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetShouldIgnoreSound()) return true;
			
			//////////////////////
			// If high enough prio, investigate after breaking the door
			int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;
			tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
			tID idSourceBody = mpStateMachine.GetCurrentMessageData().mID;
			bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player";
			
			if (lPrio >= 3)
			{
				mbBreakDoor_InvestigateSound = InvestigateSound_RegisterSound(lPrio, vPos, sSoundName, idSourceBody, false, false, bCausedByPlayer);
			}
			
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), mbBreakDoor_InvestigateSound);			
			return true;
		}
		
		///////////////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}

		return false;
	}

	//------------------------------------------------------------

	void State_BreakDoor_TimerUp(uint64 alId)
	{
		////////////////////
		// Decide action
		if (alId == H64("DecideOnDoorAction"))
		{		
			cLuxProp@ pProp = cLux_ID_Prop(m_idBreakDoor_Door);			
			if (pProp !is null)
			{
				////////////////
				// Setup vars
				bool bBreakDoor = true;
				tString sDoorName = pProp.GetName();
				tID idDoor = SwingDoor_GetDoorBodyID(sDoorName);
				
				////////////////
				// Door unbreakable?
				bool bTriedUnbreakable = mlBreakDoor_Hits >= 1 && mbBreakDoor_DoorCanBeBroken == false;
				if (bTriedUnbreakable)
				{
					bBreakDoor = false;
					
					////////////////
					// Is there a way around?
					array<tID> vOut;
					if (EvaluateObstacle_GetPathAroundBlockerBody(idDoor, vOut))
					{
						mpStateMachine.AddTimer("Exit", 0.1f);
						cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door can't be broken, taking alternative way around");					
					}
					
					//////////////////////////
					// No way around
					else
					{
						////////////////
						// Add as blocker
						EvaluateObstacle_AddPathBlocker(idDoor);
						
						////////////////
						// Blocked count
						++mlBreakDoor_BlockedByLockedDoorCount;
						mBaseObj.Timer_Add("Timer_ReduceBlockedByDoorCount", 10.f, "OnTimer_ReduceBlockedByDoorCount", false, false);
						
						////////////////
						// Go to next search pos if in SearchArea
						if (mlBlocked_PrevState == eStalkerState_SearchArea)
						{
							mlSearchArea_CurrentInterestPosId = -1;
							mpStateMachine.ChangeState(eStalkerState_SearchArea);
							
							cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around door found, going to next search pos!");
							return;
						}
						
						////////////////
						// Can we get a path around through holes?
						cVector3f vGoalPos = mvBlockedByProp_PathGoalPos;
						
						if (mbBreakDoor_InvestigateSound)
						{
							if (mpPathfinder.BuildPathNodeArrayToPos(mvInvestigateSound_Goal, 1))
							{
								mpStateMachine.AddTimer("Exit", 0.1f);
								cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Heard sound while breaking door, going to it!");
								return;
							}
							
							vGoalPos = mvInvestigateSound_Goal;
						}
						
						tID idHoleA = GetHoleWithShortestPathToPos(vGoalPos);
						tID idHoleB = GetHoleWithShortestPathToPos(mBaseObj.GetPosition());
						cLuxArea@ pHoleA = cLux_ID_Area(idHoleA);
						cLuxArea@ pHoleB = cLux_ID_Area(idHoleB);
						
						if (pHoleA !is null && pHoleB !is null && pHoleA !is pHoleB)
						{
							if (mbBreakDoor_InvestigateSound ||
								mlBlocked_PrevState == eStalkerState_InvestigateSound)
							{
								mbEmerge_InvestigateSound = true;
							}
								
							mbRetreat_TakingShortcut = true;
							mvRetreat_ShortcutTarget = vGoalPos;
							mlRetreat_ShortcutState = mlBlocked_PrevState;
							m_idRetreat_GoalHoleId = idHoleB;			
							m_idMoveBetweenHoles_EmergeHole = idHoleA;
							mpStateMachine.ChangeState(eStalkerState_Retreat);
							
							cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found path around door through holes!");
							return;
						}					
						
						////////////////
						// Retreat if hunting/alert, or stuck here!
						if (mAlertState == eStalkerAlertState_Detected ||
							mlBreakDoor_BlockedByLockedDoorCount > 1)
						{
							mpStateMachine.ChangeState(eStalkerState_Retreat);					
							cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around door found, retreating!");	
						}
						
						////////////////
						// Otherwise, return to default behaviour
						else
						{
							mpStateMachine.ChangeState(eStalkerState_Idle);			
							cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around door found, return to default behaviour!");	
						}		
					}
					
					return;
				}
				
				////////////////
				// Door blocked/locked?
				else if (mbRetreat_Active == false &&
						 (SwingDoor_GetBlocked(sDoorName) || 
						  SwingDoor_GetLocked(sDoorName)))
				{
					////////////////
					// Find a way around if not very alerted!
					if (mAlertState <= eStalkerAlertState_Investigating)
					{
						array<tID> vOut;
						if (EvaluateObstacle_GetPathAroundBlockerBody(idDoor, vOut))
						{
							bBreakDoor = false;							
							mpStateMachine.AddTimer("Exit", 0.1f);
							
							cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door is locked/blocked, taking alternative way around!");
							return;	
						}		
					}
				}
				
				////////////////
				// Try to break it!
				if (bBreakDoor)
				{
					////////////////
					// Need to move closer?
					if (mBaseObj.GetDistanceToPos2D(mvBreakDoor_GoalPos) > 0.5f && 
						mbBreakDoor_DoorIsOpen == false)
					{
						mpPathfinder.Stop();
						mpMover.StopTurning();
						
						mbBreakDoor_MoveToBreakPos = true;						
						cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Moving to door to break it!");	
					}
					
					////////////////
					// Door is broken, exit!
					else if (pProp.GetHealth() <= 0.f && mbBreakDoor_DoorCanBeBroken)
					{
						mpStateMachine.AddTimer("Exit", 0.1f);
						cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door is broken, exit!");
					}
					
					////////////////
					// Try to break it!
					else
					{
						mpStateMachine.AddTimer("BreakDoor", 0.1f);
						cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Close enough to door, break it!");	
					}
				}
			}
			
			////////////////
			// Door doesn't exist, exit!
			else
			{
				mpStateMachine.AddTimer("Exit", 0.1f);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door doesn't exist, exit!");
			}
		}
		
		////////////////////
		// Break door!
		if (alId == H64("BreakDoor"))
		{			
			////////////////////
			// Play anim
			msAnimState = "BreakDoor";
			
			if (mbBreakDoor_DoorIsOpen)
			{
				mvBreakDoor_GoalPos = 0.f;
				mpMover.PlayAnimation(gsStalkerAnim_HitObstacle_Sweep, 0.3f);
			}
			else
			{
				cLuxProp@ pProp = cLux_ID_Prop(m_idBreakDoor_Door);						
				if (pProp !is null)
				{
					cVector3f vDoorDir = SwingDoor_GetDoorwayOpenDir(pProp.GetName());
					cVector3f vToDoor = cMath_Vector3Normalize(pProp.GetPosition() - mBaseObj.GetPosition());
					cVector3f vGoalDir = cMath_Vector3Dot(vToDoor, vDoorDir) >= 0.f ? vDoorDir : vDoorDir * -1.f;
				
					float fAngle = cMath_GetAngleFromPoints3D(0.f, vGoalDir).y;
					cVector3f vPos = mvBreakDoor_GoalPos;				
				
					PlayCutsceneAnimation(gsStalkerAnim_HitObstacle_Tackle, false, 0.5f, "", 1.f, 0.f, true, vPos, fAngle, false, false, false);
				}
			}
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Break door!");
		}
		
		//////////////////////
		// Leave state
		if (alId == H64("Exit"))
		{
			//////////////////
			// Investigate sound?
			if (mbBreakDoor_InvestigateSound)
			{
				mpStateMachine.ChangeState(eStalkerState_InvestigateSound);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Heard sound while breaking, investigating!");
				return;
			}
			
			//////////////////
			// Return to previous state!
			mpStateMachine.ChangeState(mlBlocked_PrevState);
			
			if (mBlockedByProp_PrevSpeedState != eStalkerSpeed_Stopped)
			{
				SetSpeedState(mBlockedByProp_PrevSpeedState);
			}
				
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Return to previous state!");
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_ReduceBlockedByDoorCount(uint64 alId)
	{
		--mlBreakDoor_BlockedByLockedDoorCount;
		if (mlBreakDoor_BlockedByLockedDoorCount > 0)
		{
			mBaseObj.Timer_Add("Timer_ReduceBlockedByDoorCount", 10.f, "OnTimer_ReduceBlockedByDoorCount", true, false);
		}
	}

	//------------------------------------------------------------

	//} END BREAK DOOR
	
	//------------------------------------------------------------
	
	//////////////////////////////////
	// STATE: STALK
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlStalk_LocalAreaCheckCount = 0;
	int mlStalk_TotalCheckCount = 0;
	int mlStalk_TotalCheckCountMax = -1;
	int mlStalk_LookCount = 0;
	bool mbStalk_WasInInterestAlert = false;
	bool mbStalk_ResetAfterQuickTurn = false;
	cVector3f mvStalk_BasePos = cVector3f(0.f);
	cVector3f mvStalk_StalkPos = cVector3f(0.f);
	cVector3f mvStalk_PrevStalkPos = cVector3f(0.f);
	
	//------------------------------------------------------------

	void State_Stalk_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Stalk ------");
		
		int lPrevAlertState = mAlertState;
		SetAlertState(eStalkerAlertState_None);
		
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Walk);
		
		if (mlStalk_TotalCheckCountMax == -1 ||
			lPrevAlertState >= eStalkerAlertState_Investigating ||
			mbStalk_WasInInterestAlert == false && mbInterest_Alert)
		{
			Stalk_Reset();
		}
		
		mbStalk_WasInInterestAlert = false;
		
		mpStateMachine.AddTimer("PlayTalk", cMath_RandRectf(5.f, 12.f));
		
		////////////////////////
		// Move to prev interest pos if we didn't reach it last time
		if (mvStalk_PrevStalkPos.SqrLength() > 0.f &&
			mpPathfinder.BuildPathNodeArrayToPos(mvStalk_PrevStalkPos, 1))
		{
			mpPathfinder.MoveTo(mvStalk_PrevStalkPos, 1.f, false);
		}
		else
		{
			Stalk_MoveToNode();
		}
	}

	//------------------------------------------------------------

	void State_Stalk_Leave()
	{
		mbStalk_WasInInterestAlert = mbInterest_Alert;
		mbStalk_ResetAfterQuickTurn = false;
		mpMover.SetUseMoveStateAnimations(true);
	}

	//------------------------------------------------------------

	void State_Stalk_Update(float afTimeStep)
	{				
	}
	
	//------------------------------------------------------------

	bool State_Stalk_Message(int alMessageId)
	{		
		////////////////////////
		// Player entered save room
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom)
		{
			mpStateMachine.ChangeState(eStalkerState_Roar);
			return false;
		}
		
		////////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{			
			mvStalk_PrevStalkPos = cVector3f(0.f);
			msAnimState = "LookAroundLong";
			
			tString sAnim = GetRandomLookAroundSideAnim();
			mpMover.PlayAnimation(sAnim, 0.3f, false);
			
			if (cMath_RandRectl(0, 2) == 2 || mBaseObj.CheckIsOnScreen(true))
			{
				if (mBaseObj.Timer_Exists("Timer_PlayedStalkTalk") == false)
				{
					mBaseObj.PlaySound("LookAround", gsStalkerSound_LookAround, true, true);
					mBaseObj.Timer_Add("Timer_PlayedLookAroundSound", 8.f);
				}
			}
			
			return true;
		}
		
		////////////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			bool bWasTransition = mpStateMachine.GetCurrentMessageData().mlX == 1;
			if (bWasTransition) return true;
			
			////////////////////////
			// Looked around at end
			if (msAnimState == "LookAroundLong")
			{								
				////////////////////////
				// Passive?
				if (mMode == eStalkerMode_Passive)
				{
					mpStateMachine.ChangeState(eStalkerState_Idle);
					return true;
				}
				
				////////////////////////
				// Checked enough?
				else if (mlStalk_TotalCheckCount >= mlStalk_TotalCheckCountMax)
				{
					Stalk_Reset();
					
					mReturnToHole_Speed = eStalkerSpeed_Walk;
					mpStateMachine.ChangeState(eStalkerState_ReturnToHole);
					return true;
				}
				
				msAnimState = "";
				mpStateMachine.AddTimer("Move", 0.f);
			}
			
			////////////////////////
			// Looked at a pos, keep moving!
			else if (msAnimState == "LookAtPos")
			{
				msAnimState = "LookAtPosEnd";
				
				tString sAnim = mpStateMachine.GetCurrentMessageData().msX;
				PlayGlimpseEndAnim(sAnim);
			}
			else if (msAnimState == "LookAtPosEnd")
			{				
				msAnimState = "";
				mpStateMachine.AddTimer("Move", 0.f);
			}
			
			return true;
		}		
		
		////////////////////////
		// Enter interest alert
		if (alMessageId == eCustomEntityMessage_EnterInterestAlert)
		{
			if (mbPlayQuickTurnAnim)
			{
				mbStalk_ResetAfterQuickTurn = true;
			}
			else
			{
				Stalk_Reset();
				Stalk_MoveToNode();
			}
		}
		
		////////////////////////
		// Quick turn over
		if (alMessageId == eCustomEntityMessage_QuickTurnOver)
		{
			bool bChangedState = mpStateMachine.GetCurrentMessageData().mlX == 1;
			if (mbStalk_ResetAfterQuickTurn && bChangedState == false)
			{
				Stalk_Reset();
				Stalk_MoveToNode();
			}
			
			mbStalk_ResetAfterQuickTurn = false;
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_Stalk_TimerUp(uint64 alId)
	{
		/////////////////////
		// Move
		if (H64("Move") == alId)
		{
			Stalk_MoveToNode();
		}
		
		/////////////////////
		// Talk
		else if (H64("PlayTalk") == alId)
		{
			if (mBaseObj.Timer_Exists("Timer_PlayedLookAroundSound") == false)
			{
				float fTalkChance;
				switch (Blackboard_GetStalkerEscalation())
				{
					case eStalkerEscalation_None: 	fTalkChance = 0.10f; break;
					case eStalkerEscalation_Stage1: fTalkChance = 0.20f; break;
					case eStalkerEscalation_Stage2: fTalkChance = 0.40f; break;
					case eStalkerEscalation_Stage3:	fTalkChance = 0.70f; break;
				}
			
				if (fTalkChance > cMath_RandRectf(0.f, 1.f))
				{
					mBaseObj.PlaySound("StalkTalk", gsStalkerSound_Talk, true, true, 2.f, 30.f);				
					mBaseObj.Timer_Add("Timer_PlayedStalkTalk", 5.f);
				}
			}
			
			mpStateMachine.AddTimer("PlayTalk", cMath_RandRectf(8.f, 16.f));
		}
	}
	
	//------------------------------------------------------------
	
	void Stalk_MoveToNode()
	{
		////////////////////////
		// Setup vars
		float fMinRadius = 0.f;
		float fMaxRadius = -1.f;
		
		if (mbInterest_Alert)
		{
			fMaxRadius = mfInterest_AreaRadius;
			mvStalk_BasePos = mvInterest_AreaPos;
		}
		
		////////////////////////
		// Chance of moving to a point near last
		if (mvStalk_StalkPos.SqrLength() > 0.f && 
			mlStalk_LocalAreaCheckCount < 2 && 
			cMath_RandRectl(0, 2) != 2)
		{
			++mlStalk_LocalAreaCheckCount;
			
			mvStalk_BasePos = mvStalk_StalkPos;
			fMinRadius = 1.f;
			fMaxRadius = 7.f;
		}
		else if (mlStalk_LocalAreaCheckCount >= 2)
		{
			mlStalk_LocalAreaCheckCount = 0;
		}
		
		////////////////////////
		// Find node by stalk pos
		int lCount = 0;
		bool bFoundPos = false;
		float fExcludedAngle = 0.f;
		cVector3f vExcludedDir(0.f);
		cAINode@ pNode = null;
		tID idBlockingBody = tID_Invalid;		
		
		while (pNode is null || pNode.GetName() == "" || lCount < 5)
		{
			++lCount;
			
			if (fMaxRadius > 0.f)
			{
				@pNode = mpPathfinder.GetNodeInCircularSectorAroundPos(mvStalk_BasePos, fMinRadius, fMaxRadius, vExcludedDir, fExcludedAngle, false, false, false, null);
			}
			else
			{
				int lId = cMath_RandRectl(0, mpPathfinder.GetNodeContainer().GetNodeNum() - 1);
				@pNode = mpPathfinder.GetNodeContainer().GetNode(lId);
			}
			
			////////////////////////
			// Increase radius until we find a node
			if (pNode is null) 
			{
				fMaxRadius += 2.f;
				continue;
			}
			
			////////////////////////
			// Don't move to point inside blocker
			else if (EvaluateObstacle_GetPointIsInsidePathBlocker(pNode.GetPosition(), idBlockingBody))
			{
				continue;
			}
			
			////////////////////////
			// Can't go there?
			else if (mpPathfinder.BuildPathNodeArrayToPos(pNode.GetPosition(), 1) == false)
			{
				vExcludedDir = (pNode.GetPosition() - mBaseObj.GetPosition());
				fExcludedAngle = cMath_PiDiv4;
				continue;
			}
			
			////////////////////////
			// Got a potential node!
			else if (fMaxRadius > 0.f)
			{
				////////////////////////
				// Not too far from base pos!			
				float fDist = GetPathDistanceToPos(mBaseObj.GetCharBody().GetFeetPosition(), pNode.GetPosition(), false);
				if (fDist < 0.f)
				{
					cAINode@ pBasePosNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition(), 0.f, 2.f, true, false, false, null);
					if (pBasePosNode !is null)
						fDist = GetPathDistanceToPos(pBasePosNode.GetPosition(), pNode.GetPosition(), false);
				}
				
				if (fDist > fMaxRadius * 2.5f)
					continue;
			}
			
			////////////////////////
			// We found our pos!
			bFoundPos = true;
			mvStalk_StalkPos = pNode.GetPosition();
			break;
		}
		
		////////////////////////
		// No pos?
		if (bFoundPos == false)
		{
			mpStateMachine.ChangeState(eStalkerState_ReturnToHole);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No stalk pos found! Retreat");
		}
		
		////////////////////////
		// Look at pos if visible and close enough
		bool bLookAtPos = mlStalk_LookCount < 1 &&
						  mBaseObj.GetPointIsInLineOfSight(mvStalk_StalkPos) && 
						  mBaseObj.GetDistanceToPos2D(mvStalk_StalkPos) < 9.f;
		
		if (bLookAtPos)
		{			
			tString sAnim = GetLookAnimation(mvStalk_StalkPos, false);
			if (sAnim != "")
			{
				++mlStalk_LookCount;
				
				msAnimState = "LookAtPos";
				mpMover.PlayAnimation(sAnim, 0.3f, false, true);
			}
			else
			{
				bLookAtPos = false;
			}
		}
		
		////////////////////////
		// Move
		if (bLookAtPos == false)
		{
			mlStalk_LookCount = 0;
			mpPathfinder.MoveTo(mvStalk_StalkPos, 1.f, false);
		}
		
		mvStalk_PrevStalkPos = mvStalk_StalkPos;
		
		////////////////////////
		// Increase check count
		++mlStalk_TotalCheckCount;
	}
	
	//------------------------------------------------------------
	
	void Stalk_Reset()
	{
		mlStalk_TotalCheckCount = 0;
		mlStalk_TotalCheckCountMax = cMath_Max(int(cMath_RandRectl(4, 10) * GetTenacityClampedAtMid()), 1);
		mvStalk_PrevStalkPos = cVector3f(0.f);
		mvStalk_StalkPos = cVector3f(0.f);
	}
	
	//------------------------------------------------------------
	
	float Stalk_GetTenacityMul()
	{
		return 1.f + (1.f - GetTenacityClampedAtMid()) * 0.5f;
	}

	//------------------------------------------------------------

	//} END STALK
	
	//////////////////////////////////
	// STATE: WAIT IN HOLE
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfWaitInHole_Count = 0.f;
	float mfWaitInHole_SkipEmergeCount = 0.f;
	float mfWaitInHole_PlayerAtHoleCount = 0.f;
	float mfWaitInHole_PlayTalkSoundCount = 0.f;
	bool mbWaitInHole_ImmediateEmerge = false;
	bool mbWaitInHole_HoleEffectsActive = false;
	bool mbWaitInHole_PlayerSeenHole = false;
	bool mbWaitInHole_PlayingReachOutAnim = false;
	tID m_idWaitInHole_Hole = tID_Invalid;
	tID m_idWaitInHole_ParticlesId = tID_Invalid;
	
	//------------------------------------------------------------

	void State_WaitInHole_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: WaitInHole ------");
		
		SetAlertState(eStalkerAlertState_None);
		
		SetHidden(true);
						
		PositionAtGhoulHole(m_idWaitInHole_Hole);		
		Blackboard_SetGhoulHoleUsed(m_idWaitInHole_Hole, mBaseObj.GetID());
		
		mpPathfinder.Stop();
		Terror_RemoveEnemy(mBaseObj.GetID());
		
		////////////////
		// Setup vars
		mbRetreat_Active = false;
		mbWaitInHole_HoleEffectsActive = false;
		mbWaitInHole_PlayerSeenHole = false;
		mbWaitInHole_PlayingReachOutAnim = false;
		mfWaitInHole_Count = 0.f;
		mfWaitInHole_SkipEmergeCount = 0.f;
		mfWaitInHole_PlayerAtHoleCount = 0.f;
		mfWaitInHole_PlayTalkSoundCount = cMath_RandRectf(5.f, 15.f);
		
		if (mbHurt_RecentlyHurt)
		{
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
			mbRetreat_TakingShortcut = false;
			
			m_idMoveBetweenHoles_EmergeHole = tID_Invalid;
		}
		
		if (mbRetreat_TakingShortcut == false &&
			mbRetreat_GoToLastKnownPlayerPosThroughHoles == false)
		{
			mlInvestigateSound_EnterFromHighPrioPlayerSoundCount = 0;
		}
		
		////////////////
		// How long do we stick around in hole?
		float fWaitTime = 0.1f;	
		float fTenacityMul = 1.f + (1.f - GetTenacityClampedAtMid()) * 0.5f;
		bool bJustEntered = mpStateMachine.GetPrevState() != eStalkerState_MoveBetweenHoles;
		{						
			////////////////
			// Sit and wait?
			if (bJustEntered == false && 
				SitAndWait_Setup(m_idWaitInHole_Hole))
			{
				mbEmerge_SitAndWait = true;
				WaitInHole_Emerge(false, false);
				return;
			}
			
			////////////////
			// Just entered, move away
			if (bJustEntered)
			{
				fWaitTime = 0.5f;
			}
			
			////////////////
			// Hang around for longer if passive
			else if (mMode == eStalkerMode_Passive)
			{
				fWaitTime = cMath_RandRectf(120.f, 180.f) * fTenacityMul;
			}
			
			////////////////////////
			// Shorter if active
			else if (mMode == eStalkerMode_Active)
			{
				fWaitTime = cMath_RandRectf(20.f, 30.f) * fTenacityMul;
				
				if (mbInterest_Alert)
					WaitInHole_SetHoleEffectsActive(true);
			}
		}
				
		mpStateMachine.AddTimer("MoveToHole", fWaitTime);
	}

	//------------------------------------------------------------

	void State_WaitInHole_Leave()
	{		
		msAnimState = "";
		
		WaitInHole_SetHoleEffectsActive(false);
		
		InHole_LeaveState();
		Blackboard_RemoveGhoulHoleUsed(m_idWaitInHole_Hole);
		
		//////////////
		// Make sure mesh is not visible - might've exited state while the hand anim was playing
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		if (pMeshEnt !is null)
		{
			pMeshEnt.SetActive(false);
			pMeshEnt.SetVisible(false);
		}		
	}

	//------------------------------------------------------------
	
	void State_WaitInHole_Update(float afTimeStep)
	{
		////////////////////
		// Count
		mfWaitInHole_Count += afTimeStep;
		mfWaitInHole_SkipEmergeCount = cMath_IncreaseTo(mfWaitInHole_SkipEmergeCount, afTimeStep, 0.f);
		
		////////////////////
		// Play talk sound?
		if (mbWaitInHole_HoleEffectsActive)
		{			
			mfWaitInHole_PlayTalkSoundCount -= afTimeStep;
			if (mfWaitInHole_PlayTalkSoundCount <= 0.f)
			{
				float fTalkChance;
				switch (Blackboard_GetStalkerEscalation())
				{
					case eStalkerEscalation_None: 	fTalkChance = 0.05f; break;
					case eStalkerEscalation_Stage1: fTalkChance = 0.20f; break;
					case eStalkerEscalation_Stage2: fTalkChance = 0.60f; break;
					case eStalkerEscalation_Stage3:	fTalkChance = 0.85f; break;
				}
			
				if (fTalkChance > cMath_RandRectf(0.f, 1.f))
				{
					Sound_Fade("Sound_BreatheInHole", 0.f, 0.3f);	
				
					mpStateMachine.AddTimer("PlayTalk", 0.3f);
					mpStateMachine.AddTimer("ResumeBreathing", 2.3f);
				}
				
				mfWaitInHole_PlayTalkSoundCount = cMath_RandRectf(10.f, 25.f);
			}
		}
		
		////////////////////
		// Has seen hole?
		bool bHoleVisible = false;
		if (mbWaitInHole_HoleEffectsActive)
		{
			iLuxEntity@ pHole = cLux_ID_Entity(m_idWaitInHole_Hole);
			bHoleVisible = pHole !is null && pHole.CheckIsOnScreen(true);
		}
		
		if (bHoleVisible)
			mbWaitInHole_PlayerSeenHole = true;
		
		////////////////////
		// Player at hole?
		bool bPlayerAtHole = mBaseObj.GetDistanceToPlayer() < gfStalker_MaxAttackPlayerDistHole && 
							 cMath_Abs(mBaseObj.GetPlayerPos().y - mBaseObj.GetPosition().y) < 1.5f &&
							 mfWaitInHole_Count > 1.f;
		if (bPlayerAtHole) 	mfWaitInHole_PlayerAtHoleCount = cMath_IncreaseTo(mfWaitInHole_PlayerAtHoleCount, afTimeStep, 6.f);
		else 				mfWaitInHole_PlayerAtHoleCount = cMath_IncreaseTo(mfWaitInHole_PlayerAtHoleCount, afTimeStep * 0.5f, 0.f);
				
		////////////////////
		// Emerge?		
		if (mbInterest_Alert && 
			bPlayerAtHole &&
			mfWaitInHole_SkipEmergeCount <= 0.f &&
			mpStateMachine.TimerExists("Emerge") == false &&
			Game_GetDifficultyMode() != eGameMode_Easy)
		{						
			////////////////////
			// Hasn't been attacked through a hole yet? If not, do so!
			bool bFirstTime = cScript_GetGlobalVarBool(gsStalker_PlayerHasBeenAttackedOnEmergeVar) == false;
			if (bFirstTime)
			{
				if (WaitInHole_DelayKillPlayerOnEmerge())
					return;
					
				////////////////////
				// Reaching out of hole? Stop!
				if (mbWaitInHole_PlayingReachOutAnim)
				{
					WaitInHole_StopReachOutHoleAnim();
					mfWaitInHole_SkipEmergeCount = 1.f;
					return;
				}
				
				WaitInHole_Emerge(true, true);
				return;
			}
			
			////////////////////
			// Chance of not emerging
			bool bEmerge = cMath_RandRectl(0, 3) > 0 || mfWaitInHole_PlayerAtHoleCount > 4.f;
			if (bEmerge == false)
			{
				mfWaitInHole_SkipEmergeCount = 3.f;
				return;
			}
				
			if (WaitInHole_DelayKillPlayerOnEmerge())
				return;
				
			////////////////////
			// Reaching out of hole? Stop!
			if (mbWaitInHole_PlayingReachOutAnim)
			{
				WaitInHole_StopReachOutHoleAnim();
				mfWaitInHole_SkipEmergeCount = 1.f;
				return;
			}
			
			////////////////////
			// Emerge?
			WaitInHole_Emerge(true, true);
		}
		
		////////////////////
		// Play reach out anim?
		if (bHoleVisible &&
			mbWaitInHole_PlayingReachOutAnim == false &&
			mpStateMachine.TimerExists("Emerge") == false && 
			Blackboard_GetStalkerReachOutHoleCooldown() <= 0.f)
		{
			mbWaitInHole_PlayingReachOutAnim = true;
			
			float fCooldown = cMath_RandRectf(gfStalker_ReachOutHoleCooldownMin, gfStalker_ReachOutHoleCooldownMax);
			Blackboard_SetStalkerReachOutHoleCooldown(fCooldown);
			
			cVector3f vPos = GetHoleGroundPos(m_idWaitInHole_Hole);
			cVector3f vFwd = GetHoleFwd(m_idWaitInHole_Hole);
			vPos += vFwd * 1.536f;
			vPos += cVector3f_Up * 0.005f;
			mBaseObj.GetCharBody().SetFeetPosition(vPos, false);
			
			cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
			if (pMeshEnt !is null)
			{
				pMeshEnt.SetActive(true);
				pMeshEnt.SetVisible(false);
			}			
			
			msAnimState = "HoleReachOut";			
			tString sAnim = gsStalkerAnim_HoleReachOut[cMath_RandRectl(0, gsStalkerAnim_HoleReachOut.length() - 2)];
			mpMover.PlayAnimation(sAnim, 0.f, false);
		}
	}
	
	//------------------------------------------------------------

	bool State_WaitInHole_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		if (alMessageId == eLuxEntityMessage_SoundNotHeard) return false;
		
		////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "HoleReachOut")
			{
				mbWaitInHole_PlayingReachOutAnim = false;
				
				cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
				if (pMeshEnt !is null)
				{
					pMeshEnt.SetActive(false);
					pMeshEnt.SetVisible(false);
				}
			}
			
			msAnimState = "";
		}
		
		////////////////////
		// Heard sound?
		if (alMessageId == eCustomEntityMessage_PlayerShotGun ||
			alMessageId == eLuxEntityMessage_SoundHeard)
		{
			////////////////////
			// Filter
			bool bGunShot = alMessageId == eCustomEntityMessage_PlayerShotGun;
			int lPrio = bGunShot ? 6 : mpStateMachine.GetCurrentMessageData().mlX;
			
			ResetRecentlyHurtIfSoundInterestingEnough(lPrio);
			
			if (GetShouldIgnoreSound()) return true;		
			if (bGunShot == false && mbRetreat_GoToLastKnownPlayerPosThroughHoles) return true;
			
			////////////////////
			// Can't emerge? Still update interest!
			if (mbEmergeAllowed == false)
			{
				IncreaseInterest(mpStateMachine.GetCurrentMessageData());
				return true;
			}
			
			////////////////////
			// Setup vars
			cVector3f vPos = bGunShot ? mBaseObj.GetPlayerPos() : mpStateMachine.GetCurrentMessageData().mvX;
			tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
			tID idSourceBody = mpStateMachine.GetCurrentMessageData().mID;
			bool bCurrentlyEmerging = mpStateMachine.TimerExists("Emerge");
			bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player" || bGunShot;
			
			////////////////////
			// Investigate sound?
			if (InHole_ShouldInvestigateSound(bGunShot, lPrio, m_idWaitInHole_Hole, vPos) &&
				InHole_GetAllowEmergeFromSound(lPrio))
			{				
				////////////////////
				// Get hole by pos
				tID idHole = InHole_GetBestEmergeHoleFromPos(vPos);
								
				////////////////////
				// If currently emerging, only switch to new hole if it's a lot closer to the sound than the current one
				if (bCurrentlyEmerging && m_idEmerge_Hole != idHole)
				{
					if (InHole_GetShouldEmergeFromNewHole(m_idEmerge_Hole, idHole, vPos) == false)
						return true;
				}
				
				m_idEmerge_Hole = idHole;
				
				////////////////////
				// Emerge from the hole we're currently in?
				if (m_idEmerge_Hole == m_idWaitInHole_Hole && bCurrentlyEmerging == false)
				{
					WaitInHole_Emerge(false, false);
				}
				
				////////////////////
				// Move to emerge hole!
				else if (m_idEmerge_Hole != m_idWaitInHole_Hole)
				{
					mpStateMachine.StopTimer("Emerge");
					mpStateMachine.StopTimer("DoPreEmergeParticles");
					mpStateMachine.StopTimer("PlayEmergeAlert");
				
					m_idMoveBetweenHoles_EmergeHole = m_idEmerge_Hole;
					mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
				}
				
				////////////////////
				// Setup sound investigation		
				if (InvestigateSound_RegisterSound(lPrio, vPos, sSoundName, idSourceBody, false, false, bCausedByPlayer))
					mbEmerge_InvestigateSound = true;	
				
				////////////////////
				// Enter active mode
				ChangeMode(eStalkerMode_Active, false);
			}
			
			////////////////////
			// Update interest!
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), mbEmerge_InvestigateSound);
		}
		
		////////////////////
		// Enter interest alert
		if (alMessageId == eCustomEntityMessage_EnterInterestAlert)
		{
			InHole_PlayWarningSound(0.3f, true);
			WaitInHole_SetHoleEffectsActive(true);
		}
		
		////////////////////
		// Leave interest alert
		if (alMessageId == eCustomEntityMessage_LeaveInterestAlert)
		{
			WaitInHole_SetHoleEffectsActive(false);
		}
		
		return true;
	}
		
	//------------------------------------------------------------

	void State_WaitInHole_TimerUp(uint64 alId)
	{
		/////////////////
		// Move to hole
		if (H64("MoveToHole") == alId)
		{			
			///////////////////
			// Go to hole near last player pos!
			if (mbRetreat_GoToLastKnownPlayerPosThroughHoles)
			{
				m_idMoveBetweenHoles_EmergeHole = GetHoleWithShortestPathToPos(mBaseObj.GetLastKnownPlayerPos(), -1.f, -1.f, true);
				if (m_idMoveBetweenHoles_EmergeHole != tID_Invalid)
				{
					mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
					return;
				}
				else
				{
					mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
				}
			}
			
			///////////////////
			// Go to shortcut hole
			if (mbRetreat_TakingShortcut)
			{
				if (m_idMoveBetweenHoles_EmergeHole != tID_Invalid)
				{
					mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
					return;
				}
				else
				{
					mbRetreat_TakingShortcut = false;
				}
			}
			
			///////////////////
			// Get goal hole
			m_idMoveBetweenHoles_GoalHole = InHole_GetGoalHole(m_idWaitInHole_Hole);
						
			///////////////////
			// No hole found, enter passive!
			if (m_idMoveBetweenHoles_GoalHole == tID_Invalid)
			{
				ChangeMode(eStalkerMode_Passive, true);						
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No suitable hole found, entering passive");
			}
			
			///////////////////
			// Emerge at goal hole if we came here from emerge (means emerge failed since hole was blocked!)													
			if (mpStateMachine.GetPrevState() == eStalkerState_Emerge)
			{
				m_idMoveBetweenHoles_EmergeHole = m_idMoveBetweenHoles_GoalHole;
			}
			
			///////////////////
			// Move!
			mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
		}
		
		/////////////////
		// Emerge
		else if (H64("Emerge") == alId)
		{
			mpStateMachine.ChangeState(eStalkerState_Emerge);
		}
		
		/////////////////
		// Play emerge alert
		else if (H64("PlayEmergeAlert") == alId)
		{
			float fMaxDist = mbEmerge_SitAndWait ? 20.f : -1.f;
			mBaseObj.PlaySound("AlertEmerge", gsStalkerSound_EmergeAlert, true, true, -1.f, fMaxDist);
			
			mfWaitInHole_PlayTalkSoundCount = 30.f;
		}
		
		/////////////////
		// Do pre emerge particles
		else if (H64("DoPreEmergeParticles") == alId)
		{
			Emerge_DoPreEmergeParticles(m_idWaitInHole_Hole);
		}
		
		/////////////////
		// Play talk
		else if (H64("PlayTalk") == alId)
		{
			if (mbWaitInHole_HoleEffectsActive == false) return;
			if (mpStateMachine.TimerExists("Emerge")) return;
			
			cSoundEntity@ pTalkSound = mBaseObj.PlaySound("Talk", gsStalkerSound_Talk, true, true, 2.f, 20.f);
			if (pTalkSound !is null)
				SoundOcclusion_AddForceOccludedSound(pTalkSound.GetID());
		}
		
		/////////////////
		// Resume breathing
		else if (H64("ResumeBreathing") == alId)
		{
			if (mbWaitInHole_HoleEffectsActive == false) return;
			if (mpStateMachine.TimerExists("Emerge")) return;
			if (Sound_Exists("Sound_BreatheInHole") == false) return;
			
			Sound_Fade("Sound_BreatheInHole", 1.f, 0.6f);
		}
	}
	
	//------------------------------------------------------------
	
	tID InHole_GetGoalHole(tID a_idPrevHole)
	{
		///////////////////
		// Setup vars		
		iCharacterBody@ pPlayerCharBody = cLux_GetPlayer().GetCharacterBody();
		if (pPlayerCharBody is null) return a_idPrevHole;
		
		cVector3f vPlayerDir = GetAveragePlayerVelocity();
		if (vPlayerDir.SqrLength() <= 0.f)
			vPlayerDir = pPlayerCharBody.GetForward();
		
		bool bGeneratorOn = Generator_GetState() == eGeneratorState_On;;
		
		tID idHole = tID_Invalid;
		array<tID> vHoleIds;	
		
		///////////////////
		// Active?
		// Go to hole within interest area
		if (mMode == eStalkerMode_Active) 
		{			
			if (mbInterest_Alert)
			{			
				///////////////////
				// Just got to the hole? Stay there a bit more (if generator on)
				if (bGeneratorOn &&
					mpStateMachine.GetCurrentState() == eStalkerState_WaitInHole &&
					mpStateMachine.GetPrevState() == eStalkerState_MoveBetweenHoles &&
					mfWaitInHole_Count < 5.f)
				{
					return a_idPrevHole;
				}
	
				///////////////////
				// Get new hole
				float fDistToHole;
				idHole = GetHoleWithShortestPathToPos(mvInterest_AreaPos, -1.f, -1.f, bGeneratorOn == false, fDistToHole);
					
				if (idHole == tID_Invalid)
				{
					idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mvInterest_AreaPos, -1.f, -1.f, bGeneratorOn == false);
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No hole with path to interest pos found, getting closest one!");
				}
				else
				{
					///////////////////
					// Get best hole 
					vHoleIds.push_back(idHole);

					float fDistToOtherHole;
					tID idOther = GetHoleWithShortestPathToPos(mvInterest_AreaPos, 5.f, -1.f, bGeneratorOn == false, fDistToOtherHole, vHoleIds);
					
					if (idOther != tID_Invalid && fDistToOtherHole - fDistToHole < 5.f)
					{
						vHoleIds.push_back(idOther);
					
						float fTopScore = -1.f;
											
						for (int i = 0; i < vHoleIds.size(); ++i)
						{
							tID id = vHoleIds[i];
							iLuxEntity@ pHole = cLux_ID_Entity(id);
							if (pHole is null) continue;
	
							cVector3f vToHole = pHole.GetPosition() - pPlayerCharBody.GetPosition();
							vToHole.y = 0.f;
							
							float fScore = cMath_Vector3Dot(vPlayerDir, vToHole);
							if (fScore > fTopScore)
							{
								idHole = id;
								fTopScore = fScore;
							}
						}
					}
				}
				
				///////////////////
				// Worth going to the new hole?
				iLuxEntity@ pNewHole = cLux_ID_Entity(idHole);
				iLuxEntity@ pOldHole = cLux_ID_Entity(a_idPrevHole);
								
				if (pNewHole !is null && pOldHole !is null)
				{
					float fDistSqr = (pOldHole.GetPosition() - pNewHole.GetPosition()).SqrLength();
					if (fDistSqr < 7.f * 7.f)
					{
						idHole = a_idPrevHole;
					}
				}
			}
			else
			{
				idHole = Blackboard_GetRandomGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), -1.f, -1.f, true);
			}
		}
			
		///////////////////
		// Passive?
		// Go to hole far away!
		else if (mMode == eStalkerMode_Passive) 
		{
			idHole = Blackboard_GetFarthestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), 20.f, -1.f, true);
			
			if (idHole == tID_Invalid)
				idHole = Blackboard_GetFarthestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), -1.f, -1.f, true);
		}
				
		return idHole == tID_Invalid ? a_idPrevHole : idHole;
	}
	
	//------------------------------------------------------------
	
	void InHole_LeaveState()
	{
		int lNextState = mpStateMachine.GetNextState();
		if (lNextState != eStalkerState_MoveBetweenHoles)
		{	
			m_idWaitInHole_Hole = tID_Invalid;
		}
	}
	
	//------------------------------------------------------------
	
	void InHole_PlayWarningSound(float afDelay, bool abForce)
	{
		tString sTimer = "Timer_WarningSoundCD";
		if (mBaseObj.Timer_Exists(sTimer) && abForce == false)
			return;
		
		mBaseObj.Timer_Add("Timer_PlayWarningSound", afDelay, "OnTimer_InHole_PlayWarningSound", false);
		mBaseObj.Timer_Add(sTimer, cMath_RandRectf(10.f, 12.f));
		
		mfWaitInHole_PlayTalkSoundCount += cMath_RandRectf(5.f, 10.f);
	}
	
	//------------------------------------------------------------
	
	bool WaitInHole_DelayKillPlayerOnEmerge()
	{
		if (Emerge_GetShouldKillPlayer() &&
			mfWaitInHole_PlayerAtHoleCount < 3.f)
		{
			mfWaitInHole_SkipEmergeCount = mbEmergeAllowed == false ? 5.f : 2.f;
			mfWaitInHole_PlayTalkSoundCount = 30.f;
			mBaseObj.PlaySound("WarningEmerge", gsStalkerSound_EmergeWarning, true, true, 1.f, 50.f);
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void OnTimer_InHole_PlayWarningSound(uint64 alId)
	{
		mBaseObj.PlaySound("WarningEmerge", gsStalkerSound_EmergeWarning, true, true, 1.f, 50.f);
	}
	
	//------------------------------------------------------------
	
	void WaitInHole_Emerge(bool abInstant, bool abEmergeAttack)
	{
		m_idEmerge_Hole = m_idWaitInHole_Hole;
		mbEmerge_EmergeAttack = abEmergeAttack;
		
		mpStateMachine.StopTimer("Emerge");
		mpStateMachine.StopTimer("DoPreEmergeParticles");
		mpStateMachine.StopTimer("PlayEmergeAlert");
		
		///////////////////
		// Setup emerge!
		if (abInstant)
		{
			mpStateMachine.AddTimer("PlayEmergeAlert", 0.f);
			mpStateMachine.AddTimer("DoPreEmergeParticles", 0.f);
			mpStateMachine.AddTimer("Emerge", 0.025f);	
		}
		else
		{
			mpStateMachine.AddTimer("PlayEmergeAlert", cMath_RandRectf(0.15f, 0.4f));
					
			float fEmergeTime = cMath_RandRectf(3.f, 4.f);
			mpStateMachine.AddTimer("Emerge", fEmergeTime);
			mpStateMachine.AddTimer("DoPreEmergeParticles", fEmergeTime - 3.f);
		}
		
		///////////////////
		// Play end reach out anim?
		if (mbWaitInHole_PlayingReachOutAnim && 
			abInstant == false)
		{
			WaitInHole_StopReachOutHoleAnim();
		}
	}
	
	//------------------------------------------------------------
	
	void WaitInHole_SetHoleEffectsActive(bool abX)
	{
		if (mbWaitInHole_HoleEffectsActive == abX) 
			return;
		
		mbWaitInHole_HoleEffectsActive = abX;
		
		////////////////
		// Start effects
		if (abX)
		{
			cLuxArea@ pHole = cLux_ID_Area(m_idWaitInHole_Hole);
			if (pHole is null) return;
		
			cParticleSystem@ pPS = pHole.CreateParticleSystem("PS_HoleParticles", "ghoul_hole_dust_trap.ps", true, false);
			if (pPS !is null)
			{
				pPS.SetWorldMatrix(Emerge_GetEmergeParticleMatrix(pHole));
				m_idWaitInHole_ParticlesId = pPS.GetID();
			}
			
			if (Sound_Exists("Sound_BreatheInHole") == false)
				Sound_CreateAtEntity("Sound_BreatheInHole", gsStalkerSound_HoleBreatheLoop, mBaseObj.GetName());
		}
		
		//////////////////
		// Stop effects
		else
		{
			cParticleSystem@ pPS = cLux_ID_ParticleSystem(m_idWaitInHole_ParticlesId);
			if (pPS !is null) 
				pPS.Kill();
				
			m_idWaitInHole_ParticlesId = tID_Invalid;
			
			Sound_Stop("Sound_BreatheInHole", 0.3f);
		}		
	}
	
	//------------------------------------------------------------
	
	void WaitInHole_StopReachOutHoleAnim()
	{					
		mbWaitInHole_PlayingReachOutAnim = false;
		
		tString sEndAnim = "";
		float fTimePos = 0.f;
		cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();
			
		if (pAnim !is null && pAnim.GetRelativeTimePosition() < 0.8f)
		{
			if (pAnim.GetName() == gsStalkerAnim_HoleReachOut[2])
			{
				sEndAnim = gsStalkerAnim_HoleReachOutEndL;
				fTimePos = 3.f;
			}
			else
			{
				sEndAnim = gsStalkerAnim_HoleReachOutEndR;
				fTimePos = 4.f;
			}
		}
			
		if (sEndAnim != "")
		{
			mpMover.PlayAnimation(sEndAnim, 0.3f, false, false);
				
			cAnimationState@ pEndAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(sEndAnim);
			if (pEndAnim !is null)
				pEndAnim.SetTimePosition(fTimePos);
		}
	}
	
	//------------------------------------------------------------
	
	bool InHole_GetAllowEmergeFromSound(int alPrio)
	{
		if (Generator_GetState() == eGeneratorState_On)
		{
			if (alPrio < glStalker_GeneratorOnMinEmergeSoundPrio)
				return false;
		}
		
		return true;
	}
	
	//------------------------------------------------------------
	
	tID InHole_GetBestEmergeHoleFromPos(const cVector3f &in avPos)
	{
		tID idHole = tID_Invalid;
		cLuxArea@ pHole = cLux_ID_Area(m_idWaitInHole_Hole);
		
		if (pHole is null)
		{
			idHole = GetHoleWithShortestPathToPos(avPos);
			if (idHole == tID_Invalid)
				idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, avPos);
			
			return idHole;
		}	
		
		cVector3f vLosStart = pHole.GetPosition() + pHole.GetMatrix().GetTranspose().GetForward();
		cVector3f vLosEnd = avPos;
		
		bool bPlayerNearby = cLux_CheckLineOfSight(vLosStart, vLosEnd, false, false) &&
							 mBaseObj.GetDistanceToPlayer2D() < 15.f;
		if (bPlayerNearby)
		{
			idHole = m_idWaitInHole_Hole;
		}
		else
		{
			idHole = GetHoleWithShortestPathToPos(avPos);
			if (idHole == tID_Invalid)
				idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, avPos);
		}
			
		return idHole;
	}
	
	//------------------------------------------------------------
	
	bool InHole_GetShouldEmergeFromNewHole(tID a_idOldHole, tID a_idNewHole, const cVector3f &in avInterestPos)
	{
		iLuxEntity@ pOld = cLux_ID_Entity(a_idOldHole);
		iLuxEntity@ pNew = cLux_ID_Entity(a_idNewHole);
					
		if (pOld !is null && pNew !is null)
		{
			float fDistOld = GetPathDistanceToPos(pOld.GetPosition(), avInterestPos, true);
			float fDistNew = GetPathDistanceToPos(pNew.GetPosition(), avInterestPos, true);
						
			if (fDistNew < fDistOld - 10.f)
				return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	//} END WAIT IN HOLE
	
	//////////////////////////////////
	// STATE: MOVE BETWEEN HOLES
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfMoveBetweenHoles_Speed = 4.f;
	bool mbMoveBetweenHoles_KilledParticles = false;
	int mlMoveBetweenHoles_MoveCount = 0;
	int mlMoveBetweenHoles_MoveCountMax = cMath_RandRectl(1, 2);
	int mlMoveBetweenHoles_PointIndex = 0;
	tID m_idMoveBetweenHoles_GoalHole = tID_Invalid;
	tID m_idMoveBetweenHoles_EmergeHole = tID_Invalid;
	tID m_idMoveBetweenHoles_Particles = tID_Invalid;
	array<cVector3f> mvMoveBetweenHoles_Points;
	
	//------------------------------------------------------------

	void State_MoveBetweenHoles_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: MoveBetweenHoles ------");
		
		SetHidden(true);
		
		mbMoveBetweenHoles_KilledParticles = false;
		mbRetreat_Active = false;
		
		if (mbInterest_Alert ||
			mbRetreat_GoToLastKnownPlayerPosThroughHoles)
		{
			mfMoveBetweenHoles_Speed = 7.f;
		}
		else
		{
			mfMoveBetweenHoles_Speed = 4.f;
		}
		
		MoveBetweenHoles_StartMove();
		
		////////////////////
		// Play sound
		float fMaxSoundDist = mMode == eStalkerMode_Active ? -1.f : 20.f;
		Sound_Stop("Sound_WallMoveLoop", 0.f);		
		Sound_CreateAtEntity("Sound_WallMoveLoop", gsStalkerSound_WallMoveLoop, mBaseObj.GetName(), 0.f, false, 1.f, -1.f, fMaxSoundDist);
	}

	//------------------------------------------------------------

	void State_MoveBetweenHoles_Leave()
	{		
		m_idWaitInHole_Hole = m_idMoveBetweenHoles_GoalHole;
		m_idMoveBetweenHoles_GoalHole = tID_Invalid;
		m_idMoveBetweenHoles_EmergeHole = tID_Invalid;
		
		Sound_Stop("Sound_WallMoveLoop", 1.f);
	}

	//------------------------------------------------------------

	void State_MoveBetweenHoles_Update(float afTimeStep)
	{		
		/////////////////
		// Somehow lost goal?
		if (mvMoveBetweenHoles_Points.size() == 0 ||
			m_idMoveBetweenHoles_GoalHole == tID_Invalid)
		{
			mpStateMachine.ChangeState(eStalkerState_WaitInHole);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Somehow lost goal hole! Entering WaitInHole...", false, true);
			return;
		}
		
		/////////////////
		// Move
		bool bAtGoal = false;
		float fDistToNextHole = 0.f;
		cVector3f vPos = mBaseObj.GetPosition();
		
		if (mvMoveBetweenHoles_Points.size() > 0)
		{
			cVector3f vDir = (mvMoveBetweenHoles_Points[mlMoveBetweenHoles_PointIndex] - vPos);		
			fDistToNextHole = vDir.Length();
			vDir.Normalize();
			
			float fFrameMove = cMath_Clamp(mfMoveBetweenHoles_Speed * afTimeStep, 0.f, fDistToNextHole);
			vPos += vDir * fFrameMove;
			
			mBaseObj.SetPosition(vPos);
			
			/////////////////
			// At goal?
			if (fFrameMove <= 0.001f)
			{
				if (mlMoveBetweenHoles_PointIndex < int(mvMoveBetweenHoles_Points.size()) - 1)
				{
					++mlMoveBetweenHoles_PointIndex;
				}
				else
				{
					bAtGoal = true;
				}
			}
		}
		
		/////////////////
		// Decide behaviour at goal!
		if (bAtGoal && mpStateMachine.TimerExists("Emerge") == false)
		{
			/////////////////
			// Move around between a few more holes, or emerge?
			if (mMode == eStalkerMode_Active && 
				Generator_GetState() == eGeneratorState_Off &&
				mbPlayerIsInSaveRoom == false)
			{			
				++mlMoveBetweenHoles_MoveCount;
				if (mlMoveBetweenHoles_MoveCount >= mlMoveBetweenHoles_MoveCountMax)
				{
					mlMoveBetweenHoles_MoveCount = 0;
					mlMoveBetweenHoles_MoveCountMax = cMath_RandRectl(1, 2);
					m_idMoveBetweenHoles_EmergeHole = m_idMoveBetweenHoles_GoalHole;
				}				
			}
			
			/////////////////
			// Emerge?
			if (mbEmergeAllowed && m_idMoveBetweenHoles_EmergeHole != tID_Invalid)
			{
				mpStateMachine.AddTimer("PlayEmergeAlert", cMath_RandRectf(0.15f, 0.4f));
				
				float fEmergeTime = cMath_RandRectf(3.f, 4.f);
				mpStateMachine.AddTimer("Emerge", fEmergeTime);
				mpStateMachine.AddTimer("DoPreEmergeParticles", fEmergeTime - 3.f);
			}
			else
			{
				mpStateMachine.ChangeState(eStalkerState_WaitInHole);
			}
			
			/////////////////
			// Kill ceiling particles!
			cParticleSystem@ pPS = cLux_ID_ParticleSystem(m_idMoveBetweenHoles_Particles);
			if (pPS !is null)
				pPS.Kill();
			
			m_idMoveBetweenHoles_Particles = tID_Invalid;
			mbMoveBetweenHoles_KilledParticles = true;
		}
		
		/////////////////
		// Particles
		cVector3f vParticlePos = vPos;
		
		if (mbMoveBetweenHoles_KilledParticles == false)
		{
			float fRayDist;
			cVector3f vRayNrm;
			
			iPhysicsBody@ pHitBody = cLux_GetClosestBody(vPos, cVector3f_Up, 10.f, fRayDist, vRayNrm);
			if (pHitBody !is null)
			{
				cParticleSystem@ pPS = cLux_ID_ParticleSystem(m_idMoveBetweenHoles_Particles);
				if (pPS is null)
				{
					@pPS = mBaseObj.GetMap().GetWorld().CreateParticleSystem("PS_StalkerCeilingDust", "ghoul_ceiling_dust.ps", 1.f, true, false);
					m_idMoveBetweenHoles_Particles = pPS.GetID();
				}
				
				if (pPS !is null)
				{
					vParticlePos = vPos + cVector3f_Up * fRayDist;
					pPS.SetWorldPosition(vParticlePos);
				}
			}
		}
		
		/////////////////
		// Sound				
		cSoundEntity@ pSound = mBaseObj.GetMap().GetWorld().GetSoundEntity("Sound_WallMoveLoop");
		if (pSound !is null)
			pSound.SetWorldPosition(vParticlePos);
	}
	
	//------------------------------------------------------------
	
	bool State_MoveBetweenHoles_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;		
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		if (alMessageId == eLuxEntityMessage_SoundNotHeard) return false;
		
		////////////////////
		// Player entered save room?
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom)
		{
			if (mpStateMachine.TimerExists("Emerge") == false)
				m_idMoveBetweenHoles_EmergeHole = tID_Invalid;
			
			return false;
		}
		
		////////////////////
		// Heard sound?
		if (alMessageId == eCustomEntityMessage_PlayerShotGun ||
			alMessageId == eLuxEntityMessage_SoundHeard)
		{
			////////////////////
			// Filter
			bool bGunShot = alMessageId == eCustomEntityMessage_PlayerShotGun;
			int lPrio = bGunShot ? 6 : mpStateMachine.GetCurrentMessageData().mlX;		
			
			ResetRecentlyHurtIfSoundInterestingEnough(lPrio);
			
			if (GetShouldIgnoreSound()) return true;
			if (bGunShot == false && mbRetreat_GoToLastKnownPlayerPosThroughHoles) return true;
			
			////////////////////
			// Can't emerge? Still update interest!
			if (mbEmergeAllowed == false)
			{
				IncreaseInterest(mpStateMachine.GetCurrentMessageData());
				return true;
			}
			
			////////////////////
			// Setup vars
			cVector3f vPos = bGunShot ? mBaseObj.GetPlayerPos() : mpStateMachine.GetCurrentMessageData().mvX;
			tString sSoundName = mpStateMachine.GetCurrentMessageData().msX;
			tID idSourceBody = mpStateMachine.GetCurrentMessageData().mID;
			bool bCurrentlyEmerging = mpStateMachine.TimerExists("Emerge");
			bool bCausedByPlayer = mpStateMachine.GetCurrentMessageData().msY == "Player" || bGunShot;
			
			////////////////////
			// Investigate sound?
			if (InHole_ShouldInvestigateSound(bGunShot, lPrio, tID_Invalid, vPos) &&
				InHole_GetAllowEmergeFromSound(lPrio))
			{										
				////////////////////
				// Get hole by pos
				tID idHole = GetHoleWithShortestPathToPos(vPos);
				if (idHole == tID_Invalid)
					idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, vPos);
								
				////////////////////
				// Should we just keep moving toward the current emerge hole?
				if (m_idMoveBetweenHoles_EmergeHole != idHole && mbEmerge_InvestigateSound)
				{					
					if (InHole_GetShouldEmergeFromNewHole(m_idMoveBetweenHoles_EmergeHole, idHole, vPos) == false)
						return true;
				}				
				
				////////////////////
				// Move to emerge hole (if not doing that already!)
				if (m_idMoveBetweenHoles_EmergeHole != idHole)
				{
					m_idMoveBetweenHoles_EmergeHole = idHole;
					m_idEmerge_Hole = idHole;
					
					////////////////////
					// Stop current emerge!
					mpStateMachine.StopTimer("Emerge");
					mpStateMachine.StopTimer("DoPreEmergeParticles");
					mpStateMachine.StopTimer("PlayEmergeAlert");
					
					///////////////////////
					// Move to hole
					MoveBetweenHoles_StartMove();
				}
				
				if (lPrio >= 5)
					mfMoveBetweenHoles_Speed = 7.f;
								
				////////////////////
				// Setup sound investigation	
				if (InvestigateSound_RegisterSound(lPrio, vPos, sSoundName, idSourceBody, false, false, bCausedByPlayer))
					mbEmerge_InvestigateSound = true;
				
				////////////////////
				// Enter active mode
				ChangeMode(eStalkerMode_Active, false);
			}
			
			////////////////////
			// Increase interest
			IncreaseInterest(mpStateMachine.GetCurrentMessageData(), mbEmerge_InvestigateSound);
		}
		
		////////////////////
		// Enter interest alert
		if (alMessageId == eCustomEntityMessage_EnterInterestAlert)
		{
			InHole_PlayWarningSound(0.3f, true);
		}
		
		////////////////////
		// Leave interest alert
		if (alMessageId == eCustomEntityMessage_LeaveInterestAlert)
		{
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_MoveBetweenHoles_TimerUp(uint64 alId)
	{
		////////////////
		// Emerge
		if (H64("Emerge") == alId)
		{
			m_idEmerge_Hole = m_idMoveBetweenHoles_EmergeHole;
			mpStateMachine.ChangeState(eStalkerState_Emerge);
		}
		
		////////////////
		// Emerge alert
		else if (H64("PlayEmergeAlert") == alId)
		{
			float fMaxDist = mbEmerge_SitAndWait ? 20.f : -1.f;
			mBaseObj.PlaySound("AlertEmerge", gsStalkerSound_EmergeAlert, true, true, -1.f, fMaxDist);
		}
		
		////////////////
		// Emerge particles
		else if (H64("DoPreEmergeParticles") == alId)
		{
			Emerge_DoPreEmergeParticles(m_idMoveBetweenHoles_EmergeHole);
		}
	}
	
	//------------------------------------------------------------
	
	void MoveBetweenHoles_StartMove()
	{
		////////////////
		// Go to emerge hole if specifed
		if (m_idMoveBetweenHoles_EmergeHole != tID_Invalid)
			m_idMoveBetweenHoles_GoalHole = m_idMoveBetweenHoles_EmergeHole;
		
		iLuxEntity@ pHole = cLux_ID_Entity(m_idMoveBetweenHoles_GoalHole);
		if (pHole is null)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No hole to move to, return to WaitInHole", false, true);
			mpStateMachine.ChangeState(eStalkerState_WaitInHole);
			return;
		}
		
		////////////////
		// Can we find a path through nodes?
		bool bUseNodePath = mbRetreat_GoToLastKnownPlayerPosThroughHoles == false &&
							mbRetreat_TakingShortcut == false &&
							mpPathfinder.BuildPathNodeArrayToPos(pHole.GetPosition(), 1) && 
							mpPathfinder.GetPathNodeArraySize() > 10;
		
		if (bUseNodePath)
		{
			mvMoveBetweenHoles_Points.resize(0);
			
			for (int i = 0; i < mpPathfinder.GetPathNodeArraySize(); i += 4)
			{
				cAINode@ pNode = mpPathfinder.GetPathNodeArrayNode(i);
				if (pNode is null) continue;
				
				cVector3f vPos = pNode.GetPosition();			
				
				if (i == 0)	vPos.y = mBaseObj.GetPosition().y;
				else		vPos.y = pNode.GetPosition().y + 1.f;
				
				mvMoveBetweenHoles_Points.push_back(vPos);
			}
			
			mvMoveBetweenHoles_Points[mvMoveBetweenHoles_Points.size() - 1] = pHole.GetPosition();
		}
		
		////////////////
		// If not, go there in a zig-zag pattern
		else
		{
			cVector3f vHoleFwd = pHole.GetMatrix().GetTranspose().GetForward();
			cVector3f vInFrontOfHoleHole = pHole.GetPosition() + vHoleFwd * 2.f;
			cVector3f vToHole = (vInFrontOfHoleHole - mBaseObj.GetPosition());	
			
			mvMoveBetweenHoles_Points.resize(4);
			mvMoveBetweenHoles_Points[0] = mBaseObj.GetPosition();
			mvMoveBetweenHoles_Points[1] = mvMoveBetweenHoles_Points[0] + cMath_Vector3Project(vToHole, vHoleFwd);
			mvMoveBetweenHoles_Points[2] = mvMoveBetweenHoles_Points[1] + (vInFrontOfHoleHole - mvMoveBetweenHoles_Points[1]);
			mvMoveBetweenHoles_Points[3] = pHole.GetPosition();
		}
		
		mlMoveBetweenHoles_PointIndex = 0;
	}
	
	//------------------------------------------------------------

	//} END MOVE BETWEEN HOLES
	
	///////////////////////////////////
	// STATE: HURT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbHurt_RecentlyHurt = false;
	bool mbHurt_HurtByPlayer = false;
	bool mbHurt_ShouldRetreat = false;
	bool mbHurt_PlayedSound = false;
	bool mbHurt_ShotRun = false;
	bool mbHurt_ShotRecentlyAnimPlaying = false;
	bool mbHurt_ShotDuringQuickTurn = false;
	bool mbHurt_ShotByShotgun = false;
	int mlHurt_RecentlyShotCount = 0;
	float mfHurt_ShotRunCount = 0.f;
	cVector3f mvHurt_StartPos = cVector3f(0.f);
	eDamageType mHurt_DamageType = eDamageType_Gun;
	tString msHurt_HurtAnim = "";
	
	//------------------------------------------------------------

	void State_Hurt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Hurt ------", false, true);
			
		SetAlertState(eStalkerAlertState_None);
			
		Terror_RemoveEnemy(mBaseObj.GetID());
		Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			
		////////////////////
		// Should retreat?
		mbHurt_ShouldRetreat = Hurt_GetShouldRetreat();
		
		////////////////////
		// Setup vars
		mvHurt_StartPos = mBaseObj.GetCharBody().GetFeetPosition();
		mfHurt_ShotRunCount = 0.f;
		mbHurt_ShotRun = false;
		mbHurt_RecentlyHurt = mbHurt_ShouldRetreat;
		mbHurt_ShotRecentlyAnimPlaying = false;
		msHurt_HurtAnim = "";

		if (mbHurt_RecentlyHurt)
			mbWasInActiveModeWhenPlayerEnteredSaveRoom = false;
		
		mbProximityDetectionActive = false;		
		
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Stopped);
		
		////////////////////
		// Special behaviour if in boss fight
		if (mbBossFight_Active)
		{
			mbHurt_ShouldRetreat = false;
			mBaseObj.Timer_Add("Timer_ResetRecentlyHurt", 3.f, "OnTimer_ResetRecentlyHurt", false, false);
		}
		
		////////////////////
		// Only change to passive if should retreat
		if (mbHurt_ShouldRetreat)
		{
			ChangeMode(eStalkerMode_Passive, true);
		}
		
		////////////////////
		// Setup reaction	
		mpStateMachine.AddTimer("PlayHurtAnim", 0.f);		
		mpStateMachine.AddTimer("PlayHurtSound", 0.15f);
	}

	//------------------------------------------------------------

	void State_Hurt_Leave()
	{
		mbProximityDetectionActive = true;
		mbHurt_PlayedSound = false;
		mbHurt_ShotDuringQuickTurn = false;
		mbHurt_ShotByShotgun = false;
		
		mpMover.SetUseMoveStateAnimations(true);
	}

	//------------------------------------------------------------

	void State_Hurt_Update(float afTimeStep)
	{
		//////////////////
		// Move forward a bit if shot while running!
		if (mbHurt_ShotRun)
		{
			iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
			cBoneState@ pHeadBone = mBaseObj.GetMeshEntity().GetBoneStateFromName("j_Head");
			cVector3f vHeadPos = pHeadBone !is null ? pHeadBone.GetWorldPosition() : mBaseObj.GetPosition();
			
			bool bMoved = false;			
			
			float fTime = 0.5f;
			mfHurt_ShotRunCount = cMath_IncreaseTo(mfHurt_ShotRunCount, afTimeStep, fTime);
			float fT = mfHurt_ShotRunCount / fTime;				
			
			float fDistMul = msHurt_HurtAnim == gsStalkerAnim_ShotRecentlyRun ? 0.5f : 1.f;
			float fMoveDist = 3.f * fDistMul; 
			
			cVector3f vPush;
			cVector3f vGoal = mvHurt_StartPos + pCharBody.GetForward() * fMoveDist;
			cVector3f vPos = mvHurt_StartPos * (1.f - fT) + vGoal * fT;
			cVector3f vCheckOffset = cVector3f(0.f, 0.01f, 0.f);
			
			if (pCharBody.CheckCharacterFits(vPos + vCheckOffset, true, 0, vPush) &&
				CheckHeadCollision(vHeadPos, true) == false)
			{
				bMoved = true;
				pCharBody.SetFeetPosition(vPos, true);
			}
						
			if (fT >= 1.f || bMoved == false)
			{
				mbHurt_ShotRun = false;
			}
		}
		
		//////////////////
		// Reveal player pos if in LoS
		// (so head tracker is enabled)
		if (msAnimState == "ShotEnd")
		{
			if (mbHurt_ShouldRetreat &&
				GetPlayerIsInLoS(true, false))
			{
				SetAlertState(eStalkerAlertState_Detected);
				mBaseObj.RevealPlayerPos();
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_Hurt_Message(int alMessageId)
	{		
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		/////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			tString sAnim = mpStateMachine.GetCurrentMessageData().msX;
			
			//////////////////////
			// Hurt
			if (msAnimState == "Hurt")
			{
				//////////////////////
				// Retreat?
				if (mbHurt_ShouldRetreat)
				{
					if (mHurt_DamageType == eDamageType_Gun && mbHurt_ShotRecentlyAnimPlaying == false)
					{
						msAnimState = "ShotEnd";
						mpMover.PlayAnimation(gsStalkerAnim_ShotRetreat, 0.f, false, false);
					}
					else
					{
						mpStateMachine.ChangeState(eStalkerState_Retreat);
					}
				}
				
				//////////////////////
				// Or get mad?
				else
				{
					if (mHurt_DamageType == eDamageType_Gun && mbHurt_ShotRecentlyAnimPlaying == false)
					{
						msAnimState = "ShotEnd";
						tString sAnim = gsStalkerAnim_ShotAttack;
						
						if (mbBossFight_Active && 
							BulletHandler_GetLastDamageBulletType() == eBulletType_Shotgun)
						{
							sAnim = gsStalkerAnim_ShotRetreat;
						}
						
						mpMover.PlayAnimation(sAnim, 0.f, false, false);
					}
					else
					{
						int lNewState = mbBossFight_Active ? BossFight_GetCurrentState() : eStalkerState_PreHunt;
						mpStateMachine.ChangeState(lNewState);
					}
				}
			}
			
			//////////////////////
			// Shot end
			else if (msAnimState == "ShotEnd")
			{
				msAnimState = "";
				
				int lNextState = eStalkerState_PreHunt;
				
				if (mbHurt_ShouldRetreat) 	lNextState = eStalkerState_Retreat;
				if (mbBossFight_Active) 	lNextState = BossFight_GetCurrentState();
				
				mpStateMachine.ChangeState(lNextState);
			}
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Hurt_TimerUp(uint64 alId)
	{
		//////////////////////
		// Anim
		if (H64("PlayHurtAnim") == alId)
		{						
			bool bPlayAnim = true;			
			tString sAnimState = "Hurt";
			tString sRecentlyShotTimer = "Timer_RecentlyShot";
			bool bRecentlyShot = mBaseObj.Timer_Exists(sRecentlyShotTimer);
			
			if (bRecentlyShot)	++mlHurt_RecentlyShotCount;
			else				mlHurt_RecentlyShotCount = 0;
			
			if (Hurt_GetWasShotDuringAnim())
				bRecentlyShot = true;
						
			cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();
			
			//////////////////////
			// Gun damage
			if (mHurt_DamageType == eDamageType_Gun)
			{				
				mBaseObj.Timer_Remove(sRecentlyShotTimer);
				mBaseObj.Timer_Add(sRecentlyShotTimer, 20.f, "", true, false);
								
				////////////////
				// In boss fight and on bridge?
				if (mbBossFight_Active && 
					BossFight_GetIsOnBridge(mBaseObj.GetCharBody().GetFeetPosition(), true))
				{
					sAnimState = "ShotEnd";
					msHurt_HurtAnim = gsStalkerAnim_Hurt;
				}
				
				////////////////
				// Running?
				else if (GetIsRunningQuickly())
				{
					mbHurt_ShotRun = true;
					msHurt_HurtAnim = bRecentlyShot ? gsStalkerAnim_ShotRecentlyRun : gsStalkerAnim_ShotRun;
				}
					
				////////////////
				// Alert anim playing?
				else if (cString_GetFirstStringPos(pAnim.GetName(), "alert") != -1)
				{
					msHurt_HurtAnim = bRecentlyShot ? gsStalkerAnim_ShotRecentlyAlert : gsStalkerAnim_ShotAlert;
				}
					
				////////////////
				// Default
				else
				{
					msHurt_HurtAnim = bRecentlyShot ? gsStalkerAnim_ShotRecently : gsStalkerAnim_Shot;
				}
				
				////////////////
				// Play anim?
				if (pAnim !is null)
				{
					bPlayAnim = cString_GetFirstStringPos(pAnim.GetName(), "shot") == -1;
					
					if (bRecentlyShot && bPlayAnim == false)
					{
						bPlayAnim = pAnim.GetName() == gsStalkerAnim_ShotAttack;
					}
				}
			}
			
			//////////////////////
			// Other damage
			else
			{
				msHurt_HurtAnim = gsStalkerAnim_Hurt;
				
				if (pAnim !is null && pAnim.GetName() == msHurt_HurtAnim)
				{
					bPlayAnim = false;
				}
			}
			
			//////////////////////
			// Play anim?
			if (bPlayAnim)
			{
				mbHurt_ShotRecentlyAnimPlaying = bRecentlyShot;
				
				StopCutsceneAnimation(false);
				
				msAnimState = sAnimState;
				mpMover.PlayAnimation(msHurt_HurtAnim, 0.3f, false);
			}
		}
		
		//////////////////////
		// Sound
		else if (H64("PlayHurtSound") == alId)
		{
			if (Hurt_GetWasShotDuringAnim())
				mBaseObj.PlaySound("Sound_Whine", gsStalkerSound_Whine, true, true);
			else
				Hurt_PlaySound();
		}
	}
	
	//------------------------------------------------------------
	
	void Hurt_SetupRetreat(bool abHurtByPlayer)
	{
		mbHurt_ShouldRetreat = true;
		mbHurt_RecentlyHurt = true;
		mbHurt_PlayedSound = false;
		mbHurt_HurtByPlayer = abHurtByPlayer;
		
		mbWasInActiveModeWhenPlayerEnteredSaveRoom = false;
		
		ChangeMode(eStalkerMode_Passive, true);
		
		mpStateMachine.StopTimer("PlayHurtAnim");		
		mpStateMachine.StopTimer("PlayHurtSound");
		mpStateMachine.AddTimer("PlayHurtAnim", 0.15f);		
		mpStateMachine.AddTimer("PlayHurtSound", 0.15f);
	}
	
	//------------------------------------------------------------
	
	bool Hurt_GetShouldRetreat()
	{
		if (mbHurt_RecentlyHurt) return true;
		
		bool bRet = true;
		
		if (mHurt_DamageType == eDamageType_Gun)
		{
			int lId = cMath_Min(Blackboard_GetStalkerRetreatByShotCount(), glStalker_ShotCountToRetreat.length() - 1);
			int lShotCountToRetreat = glStalker_ShotCountToRetreat[lId];
			
			switch(Game_GetDifficultyMode())
			{
				case eGameMode_Hard: lShotCountToRetreat += 1; break;
			}
			
			if (Blackboard_GetStalkerShotCount() < lShotCountToRetreat &&
				mbHurt_ShotByShotgun == false)
			{
				bRet = false;
				mbHurt_HurtByPlayer = false;
			}
			else
			{
				Blackboard_IncStalkerRetreatByShotCount();
			}
		}
		
		return bRet;
	}
	
	//------------------------------------------------------------
	
	void Hurt_PlaySound(bool abForce = false)
	{		
		if (mbHurt_PlayedSound && abForce == false) 
			return;
			
		mbHurt_PlayedSound = true;
		
		tString sSound = "";
		if (mHurt_DamageType == eDamageType_Gas) sSound = gsStalkerSound_GasChoke;
		else 									 sSound = gsStalkerSound_ShotByGun;
		
		cSoundEntity@ pSound = mBaseObj.PlaySound("Hurt", sSound, true, false);
		cNode3D@ pSocket = mBaseObj.GetMeshEntity().GetSocket("Socket_Head");
		
		if (pSound !is null && pSocket !is null)
		{
			pSound.SetWorldPosition(cVector3f(0.f));
			pSocket.AddEntity(pSound);
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_ResetRecentlyHurt(uint64 alId)
	{
		mbHurt_RecentlyHurt = false;
		mbHurt_HurtByPlayer = false;
	}
	
	//------------------------------------------------------------
	
	bool Hurt_GetWasShotDuringAnim()
	{
		int lPrevState = mpStateMachine.GetPrevState();
		return mbHurt_ShotDuringQuickTurn || 
			   lPrevState == eStalkerState_Emerge || 
			   lPrevState == eStalkerState_CrawlThroughVent ||
			   lPrevState == eStalkerState_BossFight_Jump;
	}
	
	//------------------------------------------------------------

	//} END HURT
	
	///////////////////////////////////
	// STATE: RETREAT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbRetreat_Active = false;
	bool mbRetreat_GoToLastKnownPlayerPosThroughHoles = false;
	bool mbRetreat_TakingShortcut = false;
	int mlRetreat_ShortcutState = eStalkerState_Idle;
	cVector3f mvRetreat_GoalPos = cVector3f(0.f);	
	cVector3f mvRetreat_ShortcutTarget = cVector3f(0.f);
	tID m_idRetreat_GoalHoleId = tID_Invalid;
	
	//------------------------------------------------------------

	void State_Retreat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Retreat ------", false, true);
		
		SetAlertState(eStalkerAlertState_None);
		
		////////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		
		mbRetreat_Active = true;
		mbProximityDetectionActive = false;		
		
		Terror_RemoveEnemy(mBaseObj.GetID());
		Terror_RemoveHuntingEnemy(mBaseObj.GetID());
		Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		
		/////////////////////////
		// Get retreat pos
		// (Go to last if not reset and reachable!)
		if (mvRetreat_GoalPos.SqrLength() == 0.f || 
			mpPathfinder.BuildPathNodeArrayToPos(mvRetreat_GoalPos, 1) == false)
		{
			mvRetreat_GoalPos = Retreat_GetPos();
		}
		
		if (mvRetreat_GoalPos.SqrLength() <= 0.f)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No retreat pos found, this shouldn't happen!", false, true);
			mpStateMachine.ChangeState(eStalkerState_Idle);
			return;
		}
		
		/////////////////////////
		// Move
		SetSpeedState(eStalkerSpeed_Run);
		mpPathfinder.MoveTo(mvRetreat_GoalPos, 1.f, false);
	}

	//------------------------------------------------------------

	void State_Retreat_Leave()
	{	
		Blackboard_SetPlayerBlocksPath(mBaseObj, false);		
		mpMover.SetUseMoveStateAnimations(true);		
		
		mbProximityDetectionActive = true;
		m_idRetreat_GoalHoleId = tID_Invalid;
		
		/////////////////////////
		// Reset goal pos?
		int lNextState = mpStateMachine.GetNextState();
		if (lNextState != eStalkerState_ThrowPlayer &&
			lNextState != eStalkerState_BlockedByProp &&
			lNextState != eStalkerState_Blocked)
		{
			mvRetreat_GoalPos = cVector3f(0.f);
		}
	}

	//------------------------------------------------------------

	void State_Retreat_Update(float afTimeStep)
	{		
		////////////////////
		// Throw player?
		if (mpStateMachine.GetPrevState() == eStalkerState_ThrowPlayer)
			return;
		
		if (mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos()) == false)
			return;
		
		if (mBaseObj.GetCharBody().GetMoveSpeed(eCharDir_Forward) < 3.f)
			return;
			
		if (cLux_GetPlayer().GetCurrentStateId() == ePlayerState_Ladder)
			return;
		
		if (mbPlayerIsHiding)
		{
			if (mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Touching) == false)
				return;
		}
		else
		{
			if (mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Close) == false &&
				mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Touching) == false)
			{
				return;
			}
		}
		
		if (cLux_CheckLineOfSight(mBaseObj.GetPosition(), mBaseObj.GetPlayerHeadPos(), false, false, null) == false)
			return;
		
		mpStateMachine.ChangeState(eStalkerState_ThrowPlayer);
	}
	
	//------------------------------------------------------------

	bool State_Retreat_Message(int alMessageId)
	{	
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		
		//////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			//////////////////
			// Far away still?
			if (mBaseObj.GetDistanceToPos(mvRetreat_GoalPos) > 3.f)
			{
				mpPathfinder.MoveTo(mvRetreat_GoalPos, 1.f, false);
				return true;
			}
			
			//////////////////
			// Return to hole!
			mvRetreat_GoalPos = cVector3f(0.f);
			
			m_idReturnToHole_Hole = tID_Invalid;
			mReturnToHole_Speed = eStalkerSpeed_Run;
			mpStateMachine.ChangeState(eStalkerState_ReturnToHole);
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Retreat_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------
	
	cVector3f Retreat_GetPos()
	{
		////////////////
		// Go to specific hole?
		if (m_idRetreat_GoalHoleId != tID_Invalid)
		{
			cLuxArea@ pArea = cLux_ID_Area(m_idRetreat_GoalHoleId);
			if (pArea !is null)
				return pArea.GetPosition();
		}
		
		////////////////
		// Get holes in 4 directions
		array<tID> vHoles;
		array<tID> vHolesInPlayerDir;
		
		cVector3f vToPlayer = mBaseObj.GetPlayerDir();
		cVector3f[] vHoleCheckDirs = { cVector3f_Forward, cVector3f_Forward * -1.f, cVector3f_Right, cVector3f_Right * -1.f };
		
		for (uint i = 0; i < vHoleCheckDirs.length(); ++i)
		{			
			tID idHole = Blackboard_GetGhoulHoleInPosDir(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), vHoleCheckDirs[i], -1.f, -1.f, false, false, false, vHoles);
			
			////////////////
			// Prioritize holes not in player dir
			if (cMath_Vector3Dot(vToPlayer, vHoleCheckDirs[i]) > 0.25f)
			{
				vHolesInPlayerDir.push_back(idHole);
				continue;
			}
			
			if (idHole != tID_Invalid)
			{
				vHoles.push_back(idHole);
			}
		}
		
		for (uint i = 0; i < vHolesInPlayerDir.size(); ++i)
		{
			vHoles.push_back(vHolesInPlayerDir[i]);
		}
		
		////////////////
		// Find retreat path where we don't have to run past the player
		cAINode@ pRetreatNode = null;
		cVector3f vHolePos = cVector3f(0.f);
		
		Blackboard_SetPlayerBlocksPath(mBaseObj, true);
		
		for (uint i = 0; i < vHoles.size(); ++i)
		{
			iLuxEntity@ pEnt = cLux_ID_Entity(vHoles[i]);
			if (pEnt is null) continue;
			
			////////////////
			// Build path to hole
			vHolePos = pEnt.GetPosition() + GetHoleFwd(pEnt.GetID());			
			
			if (mpPathfinder.BuildPathNodeArrayToPos(vHolePos, 1))
			{
				@pRetreatNode = mpPathfinder.GetNodeAtPos(vHolePos, 0.f, 10.f, true, false, false, null);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found retreat hole not leading through player!",false,true);
				break;
			}
		}
		
		////////////////
		// Fail safe
		if (pRetreatNode is null)
		{
			Blackboard_SetPlayerBlocksPath(mBaseObj, false);
			
			tID idHole = GetHoleWithShortestPathToPos(mBaseObj.GetPosition(), -1.f, -1.f, false);
			if (idHole == tID_Invalid)
			{
				idHole = Blackboard_GetFarthestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), -1.f, -1.f, false, false);
			}
			
			iLuxEntity@ pEnt = cLux_ID_Entity(idHole);
			if (pEnt !is null)
			{
				vHolePos = pEnt.GetPosition() + GetHoleFwd(pEnt.GetID());
				@pRetreatNode = mpPathfinder.GetNodeAtPos(vHolePos, 0.f, 10.f, true, false, false, null);
			}
		}
		
		////////////////
		// Get retreat pos
		cVector3f vRetreatPos = pRetreatNode !is null ? pRetreatNode.GetPosition() : 0.f;
		
		if (vRetreatPos.SqrLength() == 0.f)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Could not find any holes to retreat to!",false,true);
		}
			
		return vRetreatPos;
	}
	
	//------------------------------------------------------------

	//} END RETREAT
	
	///////////////////////////////////
	// STATE: RAGE
	//{////////////////////////////////		
	
	//------------------------------------------------------------
	
	tID m_idRage_PropToBreak = tID_Invalid;
	
	//------------------------------------------------------------
	
	bool Rage_Setup()
	{
		///////////////
		// Random chance
		if (cMath_RandRectl(0, 2) > 0)
			return false;
		
		///////////////
		// Get near props
		cVector3f vBoxCenter = mBaseObj.GetPosition();
		cVector3f vBoxSize = cVector3f(10.f, 2.f, 10.f);
		cVector3f vBoxMin = vBoxCenter - vBoxSize / 2.f;
		cVector3f vBoxMax = vBoxCenter + vBoxSize / 2.f;
		
		array<iPhysicsBody@> vBodies;
		array<cLuxProp@> vBreakableProps;
		cLux_GetCurrentMap().GetPhysicsWorld().GetBodiesInAABB(vBoxMin, vBoxMax, false, false, vBodies);
		
		for (uint i = 0; i < vBodies.size(); ++i)
		{
			iPhysicsBody@ pBody = vBodies[i];
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			
			///////////////
			// Can it be broken?
			if (pBody is null) continue;
			if (pProp is null) continue;
			if (pProp.IsActive() == false) continue;
			if (pBody.IsCharacter()) continue;
			if (pProp.GetIsDoor()) continue;
			if (pProp.GetHealth() <= 0.f) continue;	
			if (GetIsPropBreakable(pProp) == false) continue;
			
			///////////////
			// Big enough?
			cVector3f vPropSize = pBody.GetBoundingVolume().GetSize();
			float fPropSize = cMath_Max(vPropSize.x, cMath_Max(vPropSize.y, vPropSize.z));
			if (fPropSize < 1.f)
				continue;
			
			///////////////
			// In prop in LoS?
			cVector3f vStart = mBaseObj.GetEyePostion();
			cVector3f vEnd = pBody.GetWorldPosition();
			vEnd.y = pBody.GetBoundingVolume().GetMax().y + 0.05f;
			
			if (cLux_CheckLineOfSight(vStart, vEnd, false, false) == false)
				continue;
				
			///////////////
			// Save it!
			vBreakableProps.push_back(pProp);
		}
		
		///////////////
		// Find the closest prop
		cLuxProp@ pClosest = null;
		float fMinDistSqr = 1000.f * 1000.f;
		
		for (uint i = 0; i < vBreakableProps.size(); ++i)
		{
			cLuxProp@ pProp = vBreakableProps[i];
			if (pProp is null) continue;
			
			float fDistSqr = (mBaseObj.GetPosition() - pProp.GetPosition()).SqrLength();
			if (fDistSqr < fMinDistSqr)
			{
				fMinDistSqr = fDistSqr;
				@pClosest = pProp;
			}
		}
		
		///////////////
		// We've found a good prop to break!
		if (pClosest !is null)
		{
			m_idRage_PropToBreak = pClosest.GetID();
			return true;
		}
		
		///////////////
		// No good prop to break, don't enter state!
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_Rage_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Rage ------", false, true);
		
		SetSpeedState(eStalkerSpeed_Walk);
		
		cLuxProp@ pProp = cLux_ID_Prop(m_idRage_PropToBreak);
		if (pProp is null)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No prop to break found, return to idle", false, true);
			mpStateMachine.ChangeState(eStalkerState_Idle);
			return;
		}
		
		mpPathfinder.Stop();
		mpPathfinder.MoveTo(pProp.GetPosition(), 1.f, false);
		
		mpStateMachine.AddTimer("Move", 1.f);
	}

	//------------------------------------------------------------

	void State_Rage_Leave()
	{
		m_idRage_PropToBreak = tID_Invalid;
	}

	//------------------------------------------------------------

	void State_Rage_Update(float afTimeStep)
	{
		////////////////
		// Setup vars
		iLuxEntity@ pEnt = cLux_ID_Entity(m_idRage_PropToBreak);
		if (pEnt is null) return;
		
		////////////////
		// Hit the prop if close enough
		cBoundingVolume@ pBodyBounds = pEnt.GetMainBody().GetBoundingVolume();
		float fRadius = mBaseObj.GetCharBody().GetSize().x * 1.25f;
			
		if (cMath_CheckAABBSphereCollision(pBodyBounds.GetMin(), pBodyBounds.GetMax(), mBaseObj.GetPosition(), fRadius))
		{
			m_idAttackClose_PropToAttack = m_idRage_PropToBreak;
			mpStateMachine.ChangeState(eStalkerState_AttackClose);
		}
	}
	
	//------------------------------------------------------------

	bool State_Rage_Message(int alMessageId)
	{
		///////////////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_Rage_TimerUp(uint64 alId)
	{
		if (H64("Move") == alId)
		{
			cLuxProp@ pProp = cLux_ID_Prop(m_idRage_PropToBreak);
			if (pProp is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No prop to break found, return to idle", false, true);
				mpStateMachine.ChangeState(eStalkerState_Idle);
				return;
			}
			
			mpPathfinder.MoveTo(pProp.GetPosition(), 1.f, false);
			mpStateMachine.AddTimer("Move", 1.f);	
		}
	}
	
	//------------------------------------------------------------

	//} END RAGE
	
	///////////////////////////////////
	// STATE: KILL PLAYER
	//{////////////////////////////////		
	
	//------------------------------------------------------------
	
	bool mbKillPlayer_PlayHoleAnimation = false;
	bool mbKillPlayer_PlayUnderAnimation = false;
	float mfKillPlayer_CameraNearClipPlane = 0.f;
	tID m_idKillPlayer_HoleId = tID_Invalid;
	
	//------------------------------------------------------------
	
	void State_KillPlayer_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: KillPlayer ------", false, true);
		
		SetAlertState(eStalkerAlertState_Detected);
		
		if (mbKillPlayer_PlayHoleAnimation)
		{
			PositionAtGhoulHole(m_idKillPlayer_HoleId);
		}
		
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Stopped);
		mpMover.StopTurning();
		mBaseObj.GetCharBody().StopMovement();
		
		SetHidden(false);
		
		//////////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		iCharacterBody@ pPlayerCharBody = cLux_GetPlayer().GetCharacterBody();
		cLuxPlayer@ pPlayer = cLux_GetPlayer();
		cCamera@ pCam = pPlayer.GetCamera();
		iLuxEntity@ pHole = cLux_ID_Entity(m_idKillPlayer_HoleId);
		
		//////////////////////
		// Setup player
		Player_FadeLookSpeedMulTo(0.f, 0.5f);
		
		mfKillPlayer_CameraNearClipPlane = pCam.GetNearClipPlane();
		pCam.SetNearClipPlane(0.01f);
		
		//////////////////////
		// Get anim
		tString sAnim = gsStalkerAnim_KillPlayerBack;
		tString sPlayerAnim = gsStalkerAnim_KillPlayerBackPlayerAnim;
		bool bPlayerOnLadder = cLux_GetPlayer().GetCurrentStateId() == ePlayerState_Ladder;
		bool bInFrontOfPlayer = false;
		tString sHoleDeathAnimDir = "";
		
		if (bPlayerOnLadder)
		{
			sAnim = gsStalkerAnim_KillPlayerLadder;
			sPlayerAnim = gsStalkerAnim_KillPlayerLadderPlayerAnim;
		}
		else if (mbKillPlayer_PlayHoleAnimation)
		{			
			if (pHole !is null)
			{
				cMatrixf mtxHole = pHole.GetMatrix().GetTranspose();				
				cVector3f vHoleFwd = mtxHole.GetForward();
				cVector3f vHoleRight = mtxHole.GetRight();
				cVector3f vPlayerFwd = pPlayerCharBody.GetForward();
				
				float fFwdDot = cMath_Vector3Dot(vPlayerFwd, vHoleFwd);
				float fRightDot = cMath_Vector3Dot(vPlayerFwd, vHoleRight) * -1.f;
								
				if (cMath_Abs(fFwdDot) > cMath_Abs(fRightDot))
				{
					sHoleDeathAnimDir = fFwdDot > 0.f ? "Back" : "Front";
				}
				else
				{
					sHoleDeathAnimDir = fRightDot > 0.f ? "Right" : "Left";
				}
			}
			
			if (sHoleDeathAnimDir != "")
			{
				if (sHoleDeathAnimDir == "Front")
				{
					sAnim = gsStalkerAnim_KillPlayerHoleFront;
					sPlayerAnim = gsStalkerAnim_KillPlayerHolePlayerAnimFront;
				}
				else if (sHoleDeathAnimDir == "Back")
				{
					sAnim = gsStalkerAnim_KillPlayerHoleBack;
					sPlayerAnim = gsStalkerAnim_KillPlayerHolePlayerAnimBack;
				}
				else if (sHoleDeathAnimDir == "Left")
				{
					sAnim = gsStalkerAnim_KillPlayerHoleLeft;
					sPlayerAnim = gsStalkerAnim_KillPlayerHolePlayerAnimLeft;
				}
				else if (sHoleDeathAnimDir == "Right")
				{
					sAnim = gsStalkerAnim_KillPlayerHoleRight;
					sPlayerAnim = gsStalkerAnim_KillPlayerHolePlayerAnimRight;
				}
			}
		}
		else if (mbKillPlayer_PlayUnderAnimation)
		{
			sAnim = gsStalkerAnim_KillPlayerUnder;
			sPlayerAnim = gsStalkerAnim_KillPlayerUnderPlayerAnim;
		}
		else
		{
			cVector3f vPlayerFwd = cLux_GetPlayer().GetCharacterBody().GetForward();
			cVector3f vToGhoul = cMath_Vector3Normalize(mBaseObj.GetCharBody().GetPosition() - mBaseObj.GetPlayerPos());
			bInFrontOfPlayer = cMath_Vector3Dot(vPlayerFwd, vToGhoul) > 0.f;
			
			if (bInFrontOfPlayer)
			{
				sAnim = gsStalkerAnim_KillPlayerFront;
				sPlayerAnim = gsStalkerAnim_KillPlayerFrontPlayerAnim;
			}
		}
		
		//////////////////////
		// Get anim pos and rot		
		cVector3f vPlayerPos = pPlayerCharBody.GetFeetPosition();		
		if (pPlayerCharBody.IsOnGround() == false)
		{
			float fDist;
			cVector3f vNrm;
			cLux_GetClosestBody(vPlayerPos, cVector3f_Down, 5.f, fDist, vNrm);
			
			if (fDist < 5.f)
				vPlayerPos.y -= fDist;
		}
		
		cVector3f vPos = pCharBody.GetFeetPosition();
		cVector3f vToStalker = vPos - vPlayerPos; 
		vToStalker.y = 0.f; 
		vToStalker.Normalize();
		
		float fAngleToStalker = cMath_GetAngleFromPoints3D(0, vToStalker).y;
		float fAngle = pCharBody.GetYaw();
		float fPlayerAngle = pPlayerCharBody.GetYaw();		
		float fFadeTime = 0.3f;	
		
		if (bPlayerOnLadder)
		{
			cScript_RunGlobalFunc("State_Ladder", "", "_Global_GetLadderAreaPos");
			cVector3f vLadderPos =  cScript_GetGlobalReturnVector3f();
			
			cScript_RunGlobalFunc("State_Ladder", "", "_Global_GetYaw");
			fPlayerAngle = cScript_GetGlobalReturnFloat();
			fAngle = cScript_GetGlobalReturnFloat();
			
			cVector3f vLadderDir = cMath_MatrixMul(cMath_MatrixRotateY(fPlayerAngle), cVector3f_Forward);
			cVector3f vAnimPos = vLadderPos + vLadderDir * 0.555f;
			vAnimPos.y = vPlayerPos.y;
			
			vPlayerPos = vAnimPos;
			vPos = vAnimPos;
		}
		else if (mbKillPlayer_PlayHoleAnimation)
		{				
			if (pHole !is null)
			{
				cMatrixf mtxHole = pHole.GetMatrix().GetTranspose();
				cVector3f vHoleFwd = mtxHole.GetForward();
				cVector3f vHoleRight = mtxHole.GetRight();
				
				cVector3f vOffset(0.f);				
				if (sHoleDeathAnimDir == "Right")
					vOffset = vHoleRight * 0.15f;
				else if (sHoleDeathAnimDir == "Left")
					vOffset = vHoleRight * -0.15f;
				else if (sHoleDeathAnimDir == "Front")
					vOffset = vHoleRight * 0.05f + vHoleFwd * 0.15f;
				else if (sHoleDeathAnimDir == "Back")
					vOffset = vHoleRight * -0.05f + vHoleFwd * 0.15f;
				
				vPlayerPos = GetHoleGroundPos(m_idKillPlayer_HoleId) + vHoleFwd * 0.439f + vOffset;
				fPlayerAngle = cMath_GetAngleFromPoints3D(0, vHoleFwd).y;		
				vPos = vPlayerPos + vHoleFwd * -2.382f;
				
				if (sHoleDeathAnimDir == "Front")
				{
					fPlayerAngle += cMath_Pi;
					pCharBody.SetPosition(vPos, false);
				}
				else
				{
					fFadeTime = 0.f;
				}	
			}
		}
		else if (mbKillPlayer_PlayUnderAnimation)
		{
			tID idArea = Player_GetCurrentHideArea();					
			GetPlayerHideAreaKillAnimData(idArea, vPos, vPlayerPos, fAngle, fPlayerAngle);	
		}
		else
		{
			cVector3f vPosOffset = cVector3f(0.f);
			
			if (bInFrontOfPlayer)
			{
				fAngle = fAngleToStalker + cMath_Pi;
				fPlayerAngle = fAngleToStalker;
				vPosOffset = vToStalker * 2.425f;
			}
			else
			{
				fAngle = fPlayerAngle;
				vPosOffset = pPlayerCharBody.GetForward() * -1.4f;
			}
			
			vPos = vPlayerPos + vPosOffset;
		}		
		
		//////////////////////
		// Play anims
		PlayCutsceneAnimation(sAnim, false, fFadeTime, "", 1.f, 0.f, true, vPos, fAngle, false, false, false);
		PlayerBody_PlayCutsceneAnimation(sPlayerAnim, false, 0.3f, "", 1.f, 0.f, true, vPlayerPos, fPlayerAngle);	
		
		//////////////////////
		// Setup end
		float fEndTime = 1.f;
		
		cAnimationState@ pState = PlayerBody_GetAnimationState(sPlayerAnim);
		if (pState !is null)
			fEndTime = pState.GetLength() - 0.1f;
		mpStateMachine.AddTimer("End", fEndTime);
		
		////////////////////
		// rumble effect
		Effect_Rumble_Start(1.f, cMath_Max(fEndTime-1.5f, 0.f), 0.f, 1.f);
		
		//////////////////////
		// Register Death Stats
		GameStats_IncreaseEntryAmount(eHeroStats_NumberOfDeaths);
		GameStats_Save();
	}

	//------------------------------------------------------------

	void State_KillPlayer_Leave()
	{
		mbKillPlayer_PlayHoleAnimation = false;
		mbKillPlayer_PlayUnderAnimation = false;
		m_idKillPlayer_HoleId = tID_Invalid;
	}

	//------------------------------------------------------------

	void State_KillPlayer_Update(float afTimeStep)
	{
		mpMover.StopTurning();
	}
	
	//------------------------------------------------------------

	bool State_KillPlayer_Message(int alMessageId)
	{		
		return true;
	}
	
	//------------------------------------------------------------

	void State_KillPlayer_TimerUp(uint64 alId)
	{
		////////////////////
		// End
		if (H64("End") == alId)
		{
			Effect_Fade_Out(0.1f);
			mpStateMachine.AddTimer("GameOver", 0.1f);
		}
		
		////////////////////
		// Game over
		if (H64("GameOver") == alId)
		{
			//////////////////
			// Reset clip plane
			cLux_GetPlayer().GetCamera().SetNearClipPlane(mfKillPlayer_CameraNearClipPlane);
			
			//////////////////
			// Start game over
			mBaseObj.SetActive(false);
			GameOver_Start("Monster");
		}
	}
	
	//------------------------------------------------------------

	//} END KILL PLAYER

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: THROW PLAYER
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbThrowPlayer_PlayAnim = true;
	tString msThrowPlayer_ThrowAnim = "";
	eStalkerThrowPlayerType mThrowPlayer_ThrowType = eStalkerThrowPlayerType_Forward;
	
	//------------------------------------------------------------
		
	void State_ThrowPlayer_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ThrowPlayer ------", false, true);
		
		/////////////////
		// Setup state
		SetAlertState(eStalkerAlertState_Detected);
		
		mbProximityDetectionActive = false;
		
		mbThrowPlayer_PlayAnim = mpStateMachine.GetPrevState() != eStalkerState_Retreat;		
		if (mbThrowPlayer_PlayAnim)
		{
			mpPathfinder.Stop();
		}
			
		mThrowPlayer_ThrowType = Throw_GetThrowType();
		msThrowPlayer_ThrowAnim = Throw_GetThrowAnim(mThrowPlayer_ThrowType);
		
		if (msThrowPlayer_ThrowAnim == "")
		{
			mpStateMachine.AddTimer("Exit", 0.f);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No valid throw anim, exiting!", false, true);
			return;
		}
		
		/////////////////
		// Throw player
		mpStateMachine.AddTimer("Throw", 0.f);
	}

	//------------------------------------------------------------

	void State_ThrowPlayer_Leave()
	{						
		mbProximityDetectionActive = true;
		mpMover.SetUseMoveStateAnimations(true);
		
		mBaseObj.Timer_Add("Timer_DontKillPlayer", 3.f);
	}

	//------------------------------------------------------------
	
	void State_ThrowPlayer_Update(float afTimeStep) 
	{
	}
	
	//------------------------------------------------------------

	bool State_ThrowPlayer_Message(int alMessageId)
	{		
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "ThrowPlayer")
			{
				mpStateMachine.AddTimer("Exit", 0.f);
			}
		}
		
		////////////////////
		// Animation message
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			int lMessageId = mpStateMachine.GetCurrentMessageData().mlX;			
			if (lMessageId == 1)
			{
				mBaseObj.Timer_Add("Timer_GiveThrowDamage", 0.f, "OnTimer_GiveThrowDamage", false, false);
			}
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_ThrowPlayer_TimerUp(uint64 alId) 
	{
		/////////////////
		// Throw
		if (H64("Throw") == alId)
		{
			ThrowPlayer_DoThrow();
		}
		
		/////////////////
		// Exit
		if (H64("Exit") == alId)
		{
			int lNewState = mpStateMachine.GetPrevState() == eStalkerState_Retreat ? eStalkerState_Retreat : eStalkerState_Alert;
			mpStateMachine.ChangeState(lNewState);
		}
	}
	
	//------------------------------------------------------------
	
	eStalkerThrowPlayerType Throw_GetThrowType()
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pCharBody is null) return eStalkerThrowPlayerType_Forward;
		
		cVector3f vFwd = pCharBody.GetForward();
		cVector3f vRight = pCharBody.GetRight();
		cVector3f vToPlayer = mBaseObj.GetPlayerDir();
		
		float fAngle = cMath_Vector3Angle(vFwd, vToPlayer);
		fAngle *= cMath_Sign(cMath_Vector3Dot(vRight, vToPlayer));
		fAngle = cMath_ToDeg(fAngle);
		
		float fAbsAngle = cMath_Abs(fAngle);				
		if (fAbsAngle <= gfStalker_ThrowForwardAngle) 	
		{
			return mBaseObj.CheckIsOnScreen(true) ? eStalkerThrowPlayerType_Forward : eStalkerThrowPlayerType_BehindPlayer;
		}
		else if (fAbsAngle >= gfStalker_ThrowBackwardAngle) 	
		{
			return eStalkerThrowPlayerType_Backward;
		}
		else
		{
			bool bRight = cMath_Sign(fAngle) > 0.f;
			return bRight ? eStalkerThrowPlayerType_Right : eStalkerThrowPlayerType_Left;
		}
	}
	
	//------------------------------------------------------------
	
	tString Throw_GetThrowAnim(eStalkerThrowPlayerType aDir)
	{
		bool bCrouch = Player_GetCrouching();
		
		switch (aDir)
		{
			case eStalkerThrowPlayerType_Forward:		return bCrouch ? gsStalkerAnim_ThrowPlayer_Forward_Crouch : gsStalkerAnim_ThrowPlayer_Forward;			
			case eStalkerThrowPlayerType_Backward:		return bCrouch ? gsStalkerAnim_ThrowPlayer_Back_Crouch : gsStalkerAnim_ThrowPlayer_Back;
			case eStalkerThrowPlayerType_Left:			return bCrouch ? gsStalkerAnim_ThrowPlayer_Left_Crouch : gsStalkerAnim_ThrowPlayer_Left;
			case eStalkerThrowPlayerType_Right:			return bCrouch ? gsStalkerAnim_ThrowPlayer_Right_Crouch : gsStalkerAnim_ThrowPlayer_Right;
			case eStalkerThrowPlayerType_BehindPlayer: 	return bCrouch ? gsStalkerAnim_ThrowPlayer_BehindPlayer_Crouch : gsStalkerAnim_ThrowPlayer_BehindPlayer;
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	void ThrowPlayer_DoThrow()
	{
		/////////////////
		// Positioning		
		cVector3f vFeetPos = mBaseObj.GetCharBody().GetFeetPosition();
		cVector3f vToPlayer = cMath_Vector3Normalize(mBaseObj.GetPlayerFeetPos() - vFeetPos);
		cVector3f vPlayerPos = vFeetPos + vToPlayer * 2.5f;
		vPlayerPos.y = mBaseObj.GetPlayerFeetPos().y;
			
		float fAngle = 0.f;
		float fAngleToPlayer = cMath_GetAngleFromPoints3D(0.f, vToPlayer).y;
		float fPlayerAngle = fAngleToPlayer + cMath_Pi;
			
		if (mThrowPlayer_ThrowType == eStalkerThrowPlayerType_Forward)
		{
			fAngle = fAngleToPlayer;
		}
		else if (mThrowPlayer_ThrowType == eStalkerThrowPlayerType_Backward)
		{
			fAngle = fAngleToPlayer + cMath_Pi;
		}
		else if (mThrowPlayer_ThrowType == eStalkerThrowPlayerType_Left)
		{
			fAngle = fAngleToPlayer - cMath_PiDiv2;
		}
		else if (mThrowPlayer_ThrowType == eStalkerThrowPlayerType_Right)
		{
			fAngle = fAngleToPlayer + cMath_PiDiv2;
		}
		else if (mThrowPlayer_ThrowType == eStalkerThrowPlayerType_BehindPlayer)
		{
			fAngle = fAngleToPlayer;
			fPlayerAngle = fAngleToPlayer;
		}
			
		/////////////////
		// Play anims			
		if (mbThrowPlayer_PlayAnim)
		{
			msAnimState = "ThrowPlayer";
			PlayCutsceneAnimation(msThrowPlayer_ThrowAnim, false, 0.2f, "", 1.f, 0.f, true, vFeetPos, fAngle, false, true, false);
			
			mBaseObj.PlaySound("AttackSound", gsStalkerSound_Attack, true, true);
		}
		else
		{
			if (mpStateMachine.GetCurrentState() == eStalkerState_ThrowPlayer)
			{
				mpStateMachine.AddTimer("Exit", 0.2f);
			}
			
			mBaseObj.Timer_Add("Timer_GiveThrowDamage", 0.1f, "OnTimer_GiveThrowDamage", false, false);
		}
			
		cScript_SetGlobalArgInt(0, mThrowPlayer_ThrowType);
		cScript_SetGlobalArgVector3f(1, vPlayerPos);
		cScript_SetGlobalArgFloat(2, fPlayerAngle);
		cScript_SetGlobalArgVector3f(3, vFeetPos);
		cScript_SetGlobalArgBool(4, mbThrowPlayer_PlayAnim);
		cScript_SetGlobalArgFloat(5, 0.3f);
		cScript_RunGlobalFunc("State_Thrown", "", "_Global_Setup");
	}
	
	//------------------------------------------------------------
	
	void ThrowPlayer_ThrowPlayerWhileInCutscene(eStalkerThrowPlayerType aType, const cVector3f &in avPlayerPos, 
												float afPlayerAngle, float afFadeTime)
	{
		cScript_SetGlobalArgInt(0, aType);
		cScript_SetGlobalArgVector3f(1, avPlayerPos);
		cScript_SetGlobalArgFloat(2, afPlayerAngle);
		cScript_SetGlobalArgVector3f(3, cVector3f(0.f));
		cScript_SetGlobalArgBool(4, false);
		cScript_SetGlobalArgFloat(5, afFadeTime);
		cScript_RunGlobalFunc("State_Thrown", "", "_Global_Setup");
		
		mBaseObj.Timer_Add("Timer_DontKillPlayer", 4.f);
		mBaseObj.Timer_Add("Timer_GiveThrowDamage", 0.1f, "OnTimer_GiveThrowDamage", false, false);
	}
	
	//------------------------------------------------------------
	
	void ThrowPlayer_ThrowPlayerWhileInCutscene(const cVector3f &in avPlayerPos)
	{		
		cVector3f vPos = GetRootPosition();
		cVector3f vToPlayer = avPlayerPos - vPos;
		cVector3f vPlayerFwd = cLux_GetPlayer().GetCamera().GetForward();
		
		vPlayerFwd.y = 0.f;
		vToPlayer.y = 0.f;
		vToPlayer.Normalize();
		vPlayerFwd.Normalize();
		
		eStalkerThrowPlayerType type;
		float fPlayerAngle;
		
		float fDot = cMath_Vector3Dot(vPlayerFwd, vToPlayer * -1.f);
		if (fDot > 0.f)
		{
			type = eStalkerThrowPlayerType_Forward;
			fPlayerAngle = cMath_GetAngleFromPoints3D(0.f, vToPlayer).y + cMath_Pi;
		}
		else
		{
			type = eStalkerThrowPlayerType_BehindPlayer;
			fPlayerAngle = cMath_GetAngleFromPoints3D(0.f, vToPlayer).y;
		}
		
		ThrowPlayer_ThrowPlayerWhileInCutscene(type, avPlayerPos, fPlayerAngle, 0.3f);
	}
	
	//------------------------------------------------------------
	
	void OnTimer_GiveThrowDamage(uint64 alId)
	{
		Player_GiveDamage(gfStalker_ThrowDamage, 0.1f, eDamageType_Default, mBaseObj.GetName());
	}

	//------------------------------------------------------------

	//} END THROW PLAYER
	
	///////////////////////////////////
	// STATE: CRAWL THROUGH VENT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlCrawlThroughVent_NextState = eStalkerState_Idle;
	bool mbCrawlThroughVent_Hurt = false;
	tID m_idCrawlThroughVent_GratingWallId = tID_Invalid;
	array<tID> mvCrawlThroughVent_GratingWallIds;
	
	//------------------------------------------------------------
		
	void State_CrawlThroughVent_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CrawlThroughVent ------", false, true);
		
		/////////////////
		// Setup state
		mbProximityDetectionActive = false;
		SetAlertState(eStalkerAlertState_None);
		
		/////////////////
		// Get grating wall
		cLuxProp@ pProp = cLux_ID_Prop(m_idCrawlThroughVent_GratingWallId);
		if (pProp is null)
		{
			mpStateMachine.ChangeState(mlCrawlThroughVent_NextState);
			return;
		}
		
		/////////////////
		// Play anim
		msAnimState = "CrawlThroughVent";
		
		cVector3f vPropPos = pProp.GetOnLoadTransform().GetTranslation();
		cVector3f vPropFwd = pProp.GetMatrix().GetTranspose().GetForward();
		cVector3f vToStalker = cMath_Vector3Normalize(mBaseObj.GetPosition() - vPropPos);
		bool bInFrontOfGrating = cMath_Vector3Dot(vToStalker, vPropFwd) > 0.f;				
					
		cVector3f vAnimDir = bInFrontOfGrating ? vPropFwd * -1.f: vPropFwd;
		cVector3f vAnimPos = vPropPos + vAnimDir * -1.75f;
		float fAnimAngle = cMath_GetAngleFromPoints3D(0.f, vAnimDir).y;
				
		PlayCutsceneAnimation(gsStalkerAnim_GoThroughVent, false, 0.3f, "", 1.f, 0.f, true, vAnimPos, fAnimAngle, false, true, false);
	}

	//------------------------------------------------------------

	void State_CrawlThroughVent_Leave()
	{						
		mbProximityDetectionActive = true;
		
		mbCrawlThroughVent_Hurt = false;
		m_idCrawlThroughVent_GratingWallId = tID_Invalid;
		
		mpMover.SetUseMoveStateAnimations(true);
	}

	//------------------------------------------------------------
	
	void State_CrawlThroughVent_Update(float afTimeStep) 
	{
	}
	
	//------------------------------------------------------------

	bool State_CrawlThroughVent_Message(int alMessageId)
	{				
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "CrawlThroughVent")
			{
				mpMover.StopTurning();
				mpPathfinder.Stop();
				
				mpStateMachine.AddTimer("Exit", 0.f);
			}
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_CrawlThroughVent_TimerUp(uint64 alId) 
	{
		////////////////////
		// Exit
		if (H64("Exit") == alId)
		{
			int lNextState = mbCrawlThroughVent_Hurt ? eStalkerState_Hurt : eStalkerState(mlCrawlThroughVent_NextState);
			mpStateMachine.ChangeState(lNextState);
		}
	}
	
	//------------------------------------------------------------
	
	bool CrawlThroughVent_Setup(cLuxProp@ apProp)
	{
		if (apProp is null) return false;
		
		////////////////
		// Within dist?
		bool bWithinDist = (apProp.GetPosition() - mBaseObj.GetPosition()).SqrLength() < 1.75f * 1.75f;
		if (bWithinDist == false) 
			return false;
		
		////////////////
		// In front?
		bool bGratingInFront = mBaseObj.GetPointIsInFront(apProp.GetOnLoadTransform().GetTranslation());
		if (bGratingInFront == false) 
			return false;
		
		////////////////
		// Path goes through?
		cBoundingVolume@ pBounds = apProp.GetMainBody().GetBoundingVolume();
		
		float fIntersectT;
		cVector3f vIntersection;
		bool bPathGoesThroughGrating = cMath_CheckAABBLineIntersection(pBounds.GetMin(), pBounds.GetMax(),
																	   mBaseObj.GetPosition(), mpPathfinder.GetNextGoalPos(),
																	   vIntersection, fIntersectT);
		if (bPathGoesThroughGrating == false)
			return false;
		
		////////////////
		// Return
		return true;
	}

	//------------------------------------------------------------

	//} END CRAWL THROUGH VENT
	
	///////////////////////////////////
	// STATE: SIT AND WAIT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvSitAndWait_Pos(0.f);
	cVector3f mvSitAndWait_Dir(0.f);
	bool mbSitAndWait_Turning = false;
	bool mbSitAndWait_Sitting = false;
	bool mbSitAndWait_SeenByPlayer = false;
	
	//------------------------------------------------------------
		
	void State_SitAndWait_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: SitAndWait ------", false, true);
		
		mbPresencePaused = true;
		
		mbSitAndWait_Turning = false;
		mbSitAndWait_Sitting = false;
		mbSitAndWait_SeenByPlayer = false;
		
		SetAlertState(eStalkerAlertState_None);
		
		mpPathfinder.MoveTo(mvSitAndWait_Pos, 1.f, false);
	}

	//------------------------------------------------------------

	void State_SitAndWait_Leave()
	{				
		mbPresencePaused = false;
		
		mvSitAndWait_Pos = cVector3f(0.f);
		mvSitAndWait_Dir = cVector3f(0.f);
		
		float fCooldown = mbSitAndWait_SeenByPlayer ? gfStalker_SitAndWaitCooldownMax : gfStalker_SitAndWaitCooldownMin;
		Blackboard_SetStalkerSitAndWaitCooldown(fCooldown);
		
		if (mbSitAndWait_Sitting)
			mpMover.PlayAnimation(gsStalkerAnim_SitEnd, 0.3f, false, true);
	}

	//------------------------------------------------------------
	
	void State_SitAndWait_Update(float afTimeStep) 
	{
		////////////////////
		// Seen by player?
		if (mbIsOnScreen && mbSitAndWait_SeenByPlayer == false)
		{
			mbSitAndWait_SeenByPlayer = true;
			mbPresencePaused = false;
		}
	}
	
	//------------------------------------------------------------

	bool State_SitAndWait_Message(int alMessageId)
	{				
		////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			////////////////////
			// Turn toward dir?			
			float fAngle = cMath_GetAngleFromPoints3D(0, mvSitAndWait_Dir).y;
			float fAngleDiff = cMath_GetAngleDistanceRad(mBaseObj.GetCharBody().GetYaw(), fAngle);
			float fAbsAngleDiff = cMath_Abs(fAngleDiff);
			
			if (fAbsAngleDiff >= cMath_ToRad(25.f))
			{
				mbSitAndWait_Turning = true;
				mfQuickTurnGoalYaw = fAngle;
					
				if (fAbsAngleDiff >= gfStalker_PlayTurnAroundAnimMinAngle)
					mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
				else
					mQuickTurnAnimType = fAngleDiff > 0.f ? eStalkerQuickTurnType_Left : eStalkerQuickTurnType_Right;
					
				PlayQuickTurnAnim();
			}
			
			////////////////////
			// Otherwise, sit!
			else
			{
				SitAndWait_Sit();
			}
		}
		
		////////////////////
		// Quick turn over
		if (alMessageId == eCustomEntityMessage_QuickTurnOver && 
			mbSitAndWait_Turning)
		{
			SitAndWait_Sit();
		}
		
		////////////////////
		// Animation message
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent &&
			mbSitAndWait_Sitting)
		{
			int lMessage = mpStateMachine.GetCurrentMessageData().mlX;
			if (lMessage == 4)
			{
				mBaseObj.PlaySound("Breathe", "creatures/stalker/breathe_idle", true, true, 2.f, 10.f);
			}			
			else if (lMessage == 5)
			{
				mBaseObj.PlaySound("HandL", "creatures/stalker/hand_walk", true, false, 2.f, 10.f);
			}
			else if (lMessage == 6)
			{
				mBaseObj.PlaySound("HandR", "creatures/stalker/hand_walk", true, false, 2.f, 10.f);
			}
			
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_SitAndWait_TimerUp(uint64 alId) 
	{		
		////////////////////
		// Exit
		if (H64("Exit") == alId)
		{
			int lNewState = Generator_GetState() == eGeneratorState_On ? eStalkerState_ReturnToHole : eStalkerState_Idle;
			mpStateMachine.ChangeState(lNewState);
		}
	}
	
	//------------------------------------------------------------
	
	void SitAndWait_Sit()
	{
		mbSitAndWait_Sitting = true;
		
		mpMover.SetSpeedState(eStalkerSpeed_Stopped);
		mpMover.PlayAnimation(gsStalkerAnim_SitLoop, 0.3f, true, true);
			
		float fTime = cMath_RandRectf(gfStalker_SitAndWaitMinTime, gfStalker_SitAndWaitMaxTime);
		mpStateMachine.AddTimer("Exit", fTime);
	}
	
	//------------------------------------------------------------
	
	bool SitAndWait_Setup(tID a_idCurrentHole)
	{
		///////////////////
		// Setup vars
		cLuxArea@ pArea = cLux_ID_Area(a_idCurrentHole);
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		if (pArea is null) return false;
		if (pCharBody is null) return false;
		
		cMatrixf mtxAreaTranspose = pArea.GetMatrix().GetTranspose();
		cVector3f vAreaFwd = mtxAreaTranspose.GetForward();
		cVector3f vAreaRight = mtxAreaTranspose.GetRight();
		
		///////////////////
		// Emerge allowed?
		if (mbEmergeAllowed == false)
			return false;
		
		///////////////////
		// Random chance
		float fChance;
		switch (Blackboard_GetStalkerEscalation())
		{
			case eStalkerEscalation_None: 	fChance = 0.05f; break;
			case eStalkerEscalation_Stage1: fChance = 0.15f; break;
			case eStalkerEscalation_Stage2: fChance = 0.60f; break;
			case eStalkerEscalation_Stage3:	fChance = 0.80f; break;
		}
		
		if (fChance < cMath_RandRectf(0.f, 1.f))
			return false;			
		
		///////////////////
		// In active mode?
		if (mMode == eStalkerMode_Passive)
			return false;
		
		////////////////////
		// Enough time since last?
		if (Blackboard_GetStalkerSitAndWaitCooldown() > 0.f)
			return false;
		
		///////////////////
		// Generator on?
		if (Generator_GetState() == eGeneratorState_Off)
			return false;
		
		///////////////////
		// Player not near?
		float fDistToPlayerSqr = (mBaseObj.GetPlayerPos() - pArea.GetPosition()).SqrLength();
		if (fDistToPlayerSqr < 15.f * 15.f)
			return false;
		
		///////////////////
		// Fits at pos?
		cVector3f vPos = pArea.GetPosition() + vAreaFwd * 1.f;
		vPos.y = pArea.GetAreaBody().GetBoundingVolume().GetMin().y;
				
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(vPos, 0.f, 2.f, true, false, false, null);
		if (pNode is null)
			return false;
		
		mvSitAndWait_Pos = pNode.GetPosition();
		
		cVector3f vPush;
		if (pCharBody.CheckCharacterFits(mvSitAndWait_Pos, true, 0, vPush) == false)
			return false;
		
		///////////////////
		// No LoS?
		cVector3f vLookPosStart = mvSitAndWait_Pos + cVector3f(0.f, 1.2f, 0.f);
		if (cLux_CheckLineOfSight(mBaseObj.GetPlayerHeadPos(), vLookPosStart, false, false, null))
			return false;
		
		///////////////////
		// Free space to look toward?
		float fLookDist = 4.f;
		cVector3f[] vDirs = { vAreaFwd, vAreaRight, vAreaRight * -1.f };
		
		for (int i = 0; i < vDirs.length(); ++i)
		{
			cVector3f vDir = vDirs[i];
			if (cLux_CheckLineOfSight(vLookPosStart, vLookPosStart + vDir * fLookDist, false, false))
			{
				mvSitAndWait_Dir = vDir;
				return true;
			}
		}
		
		return false;
	}

	//------------------------------------------------------------

	//} END SIT AND WAIT
	
	///////////////////////////////////
	// STATE: EXAMINE RABBIT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbExamineRabbit_Turning = false;
	bool mbExamineRabbit_Examining = false;
	bool mbExamineRabbit_FadePropPos = false;
	float mfExamineRabbit_FadePropCount = 0.f;
	tID m_idExamineRabbit_RabbitId = tID_Invalid;
	tID m_idExamineRabbit_CutsceneRabbitId = tID_Invalid;
	
	//------------------------------------------------------------
		
	void State_ExamineRabbit_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ExamineRabbit ------", false, true);
				
		mbExamineRabbit_Turning = false;		
		mbExamineRabbit_Examining = false;		
		mbExamineRabbit_FadePropPos = false;
		
		SetAlertState(eStalkerAlertState_None);
		SetSpeedState(eStalkerSpeed_Walk);
		
		Terror_RemoveEnemy(mBaseObj.GetID());
		Terror_RemoveHuntingEnemy(mBaseObj.GetID());
		
		cLuxProp@ pProp = cLux_ID_Prop(m_idExamineRabbit_RabbitId);
		if (pProp is null)
		{
			int lNewState = mbBossFight_Active ? BossFight_GetCurrentState() : eStalkerState_Idle;
			mpStateMachine.ChangeState(lNewState);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No rabbit prop found!", false, true);
			return;
		}
		
		pProp.SetStaticPhysics(true);
		pProp.SetInteractionDisabled(true);
		
		mpPathfinder.MoveTo(pProp.GetPosition(), 1.f, false);
	}

	//------------------------------------------------------------

	void State_ExamineRabbit_Leave()
	{						
		//////////////////
		// Make sure rabbit props behave
		cLuxMap@ pMap = mBaseObj.GetMap();
		cLuxProp@ pProp = cLux_ID_Prop(m_idExamineRabbit_RabbitId);
		cLuxProp@ pCutsceneProp = cLux_ID_Prop(m_idExamineRabbit_CutsceneRabbitId);
		
		if (pMap !is null)
		{
			if (pCutsceneProp !is null)
				pMap.DestroyEntity(pCutsceneProp);
			
			if (pProp !is null)	
			{
				if (mbExamineRabbit_Examining)
				{
					pMap.DestroyEntity(pProp);
				}
				else
				{
					pProp.SetStaticPhysics(false);
					pProp.SetInteractionDisabled(false);
				}
			}
		}
		
		//////////////////
		// Reset vars
		m_idExamineRabbit_RabbitId = tID_Invalid;
		m_idExamineRabbit_CutsceneRabbitId = tID_Invalid;
	}

	//------------------------------------------------------------
	
	void State_ExamineRabbit_Update(float afTimeStep) 
	{
		/////////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cLuxProp@ pProp = cLux_ID_Prop(m_idExamineRabbit_RabbitId);
		cLuxProp@ pCutsceneProp = cLux_ID_Prop(m_idExamineRabbit_CutsceneRabbitId);
		cMeshEntity@ pCutscenePropMeshEnt = pCutsceneProp !is null ? pCutsceneProp.GetMeshEntity() : null;
		
		if (pCharBody is null) return;
		if (pProp is null) return;
		
		/////////////////////
		// Turn toward rabbit when close enough
		if (mbExamineRabbit_Turning == false &&
			mbExamineRabbit_Examining == false)
		{		
			cVector3f vRabbitPos = pProp.GetPosition();
			float fDistSqr = (vRabbitPos - pCharBody.GetFeetPosition()).SqrLength();
			
			if (fDistSqr < 1.3f * 1.3f)
			{
				ExamineRabbit_Turn(vRabbitPos);
			}
		}
			
		/////////////////////
		// Position cutscene prop
		if (mbExamineRabbit_FadePropPos && 
			pCutsceneProp !is null &&
			pCutscenePropMeshEnt !is null)
		{
			mfExamineRabbit_FadePropCount += afTimeStep;
			float fT = cMath_Clamp(mfExamineRabbit_FadePropCount / 0.3f, 0.f, 1.f);
			
			cVector3f vGoalPos = pCharBody.GetFeetPosition() + pCharBody.GetForward() * 1.f + cVector3f(0.f, 0.137f, 0.f);
			cMatrixf mtxGoal = cMath_MatrixRotateY(pCharBody.GetYaw());
			mtxGoal.SetTranslation(vGoalPos);
			
			cMatrixf mtxNew = cMath_MatrixSlerp(fT, pProp.GetMatrix(), mtxGoal, true);
			pProp.SetMatrix(mtxNew);
			
			if (fT >= 1.f)
			{
				mbExamineRabbit_FadePropPos = false;
				
				pProp.GetMeshEntity().SetVisible(false);
				pCutscenePropMeshEnt.SetVisible(true);
				pCutscenePropMeshEnt.ResetGraphicsUpdated();
				
				mBaseObj.GetMap().DestroyEntity(pProp);
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_ExamineRabbit_Message(int alMessageId)
	{				
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;		
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;		
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;		
		if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;		
		
		////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			cLuxProp@ pProp = cLux_ID_Prop(m_idExamineRabbit_RabbitId);
			if (pProp is null)
			{
				int lNewState = mbBossFight_Active ? BossFight_GetCurrentState() : eStalkerState_Retreat;
				mpStateMachine.ChangeState(lNewState);
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No rabbit prop found, retreating!", false, true);
				return true;
			}
			
			cVector3f vRabbitPos = pProp.GetPosition();
			float fDistSqr = (vRabbitPos - mBaseObj.GetCharBody().GetFeetPosition()).SqrLength();
			
			if (fDistSqr < 1.3f * 1.3f)
			{
				ExamineRabbit_Turn(vRabbitPos);
			}
			else
			{
				int lNewState = mbBossFight_Active ? BossFight_GetCurrentState() : eStalkerState_Retreat;
				mpStateMachine.ChangeState(lNewState);
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Can't get to rabbit, retreating!", false, true);
			}
		}
		
		////////////////////
		// Quick turn over
		if (alMessageId == eCustomEntityMessage_QuickTurnOver &&
			mbExamineRabbit_Turning)
		{			
			ExamineRabbit_PlayAnim();
		}		
		
		////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver && 
			mbExamineRabbit_Examining)
		{
			tString sAnim = mpStateMachine.GetCurrentMessageData().msX;
			
			////////////////////////
			// Examine anim playing?
			if (sAnim == gsStalkerAnim_ExamineRabbit)
			{
				if (mbBossFight_Active == false)
					ChangeMode(eStalkerMode_Passive, true);
				
				int lNewState = mbBossFight_Active ? BossFight_GetCurrentState() : eStalkerState_Retreat;
				mpStateMachine.ChangeState(lNewState);
			}
			
			////////////////////////
			// Interrupt anim playing?
			else if (sAnim == gsStalkerAnim_ExamineRabbitEnd && mbBossFight_Active)
			{
				mpStateMachine.ChangeState(BossFight_GetCurrentState());
				mBaseObj.Timer_Add("Timer_BroadcastGrenadeDetecedMessage", 0.1f, "OnTimer_BroadcastGrenadeDetecedMessage", false, false);
			}
		}
		
		////////////////////
		// Animation message
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent &&
			mbExamineRabbit_Examining)
		{
			////////////////////
			// Destroy rabbit
			int lMessage = mpStateMachine.GetCurrentMessageData().mlX;
			if (lMessage == 1)
			{
				cLuxProp@ pProp = cLux_ID_Prop(m_idExamineRabbit_CutsceneRabbitId);
				if (pProp !is null)
				{
					mBaseObj.GetMap().DestroyEntity(pProp);
				}
			}
		}
		
		////////////////////
		// Grenade detected
		if (alMessageId == eCustomEntityMessage_GrenadeDetected && 
			mbBossFight_Active)
		{
			switch (Game_GetDifficultyMode())
			{
				case eGameMode_Easy: 	return true;
				case eGameMode_Normal: 	return true;
			}
			
			cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(gsStalkerAnim_ExamineRabbit);
			if (pAnim !is null && 
				pAnim.IsActive() && 
				pAnim.GetTimePosition() < 11.f)
			{
				PlayCutsceneAnimation(gsStalkerAnim_ExamineRabbitEnd, false, 0.3f, "", 1.f, 0.f, false, mvCutsceneAnimation_Position, mfCutsceneAnimation_Angle, false, false, false);
			}			
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_ExamineRabbit_TimerUp(uint64 alId) 
	{
		if (H64("FadeCutsceneProp") == alId)
		{
			mbExamineRabbit_FadePropPos = true;			
		}
	}
	
	//------------------------------------------------------------
	
	void ExamineRabbit_Turn(const cVector3f &in avRabbitPos)
	{
		mpMover.StopTurning();
		mpPathfinder.Stop();
		
		////////////////////
		// Turn toward dir?	
		cVector3f vDir = avRabbitPos - mBaseObj.GetPosition();
		vDir.y = 0.f;
		vDir.Normalize();
		
		float fAngle = cMath_GetAngleFromPoints3D(0, vDir).y;
		float fAngleDiff = cMath_GetAngleDistanceRad(mBaseObj.GetCharBody().GetYaw(), fAngle);
		float fAbsAngleDiff = cMath_Abs(fAngleDiff);
			
		if (fAbsAngleDiff >= cMath_ToRad(25.f))
		{
			mbExamineRabbit_Turning = true;
			mfQuickTurnGoalYaw = fAngle;
					
			if (fAbsAngleDiff >= gfStalker_PlayTurnAroundAnimMinAngle)
				mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
			else
				mQuickTurnAnimType = fAngleDiff > 0.f ? eStalkerQuickTurnType_Left : eStalkerQuickTurnType_Right;
					
			PlayQuickTurnAnim();
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Turn to rabbit!", false, true);
		}
			
		////////////////////
		// Otherwise, play anim!
		else
		{
			ExamineRabbit_PlayAnim();
		}
	}
	
	//------------------------------------------------------------
	
	void ExamineRabbit_PlayAnim()
	{
		////////////////
		// Setup
		Achievement_Unlock(eAchievement_Sentimentalist);
		
		mbExamineRabbit_Examining = true;
		cScript_SetGlobalVarBool("StalkerPickedUpRabbit", true);
		
		cLuxMap@ pMap = mBaseObj.GetMap();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cLuxProp@ pProp = cLux_ID_Prop(m_idExamineRabbit_RabbitId);
			
		if (pMap is null) return;
		if (pCharBody is null) return;
		
		pMap.CreateEntity("RabbitCutscene", gsStalker_RabbitCutsceneEnt, cMatrixf_Identity, cVector3f(1.f));
		cLuxProp@ pNewProp = cLux_ToProp(pMap.GetLatestEntity());
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Creating cutscene rabbit prop!", false, true);
		
		if (pNewProp is null) return;
		
		////////////////
		// Play anim			
		if (pProp !is null)
		{ 
			cMatrixf mtxNew = cMath_MatrixMul(pProp.GetBaseMatrix(), cMath_MatrixInverse(pNewProp.GetOnLoadOffsetTransform()));
			pNewProp.SetMatrix(mtxNew);
		}
			
		cVector3f vPos = pCharBody.GetFeetPosition();
		cVector3f vDir = pProp.GetPosition() - mBaseObj.GetPosition();
		vDir.y = 0.f;
		vDir.Normalize();
		
		float fAngle = cMath_GetAngleFromPoints3D(0, vDir).y;		
			
		PlayCutsceneAnimation(gsStalkerAnim_ExamineRabbit, false, 0.3f, "", 1.f, 0.f, true, vPos, fAngle, false, true, false);
			
		Entity_AlignSocketWithParentRotation(mBaseObj.GetName(), "hand_right");
		pNewProp.AttachToSocket(mBaseObj, "hand_right", true, true, false);			
		pNewProp.PlayAnimation("rabbit_doll_stalker", 0.3f, false, false);
		
		////////////////
		// Setup positioning
		mfExamineRabbit_FadePropCount = 0.f;
		m_idExamineRabbit_CutsceneRabbitId = pNewProp.GetID();
		
		pNewProp.GetMeshEntity().SetVisible(false);
		mpStateMachine.AddTimer("FadeCutsceneProp", 2.3f);
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Play rabbit anim!", false, true);
	}
	
	//------------------------------------------------------------
	
	bool ExamineRabbit_GetRabbitInLoS(const cVector3f &in avRabbitPos)
	{
		return mBaseObj.GetPointIsInLineOfSight(avRabbitPos) ||
			   mBaseObj.GetPointIsInLineOfSight(avRabbitPos + cVector3f(0.f, 0.5f, 0.f)) ||
			   mBaseObj.GetPointIsInLineOfSight(avRabbitPos + cVector3f(0.f, 1.f, 0.f));
	}
	
	//------------------------------------------------------------
	
	bool ExamineRabbit_Setup(const cVector3f &in avRabbitPos)
	{
		///////////////////
		// Checks
		if (mbCutsceneAnimation_Active) return false;
		if (mbPlayQuickTurnAnim) return false;
		
		int lCurrentState = mpStateMachine.GetCurrentState();
		if (mpMover.GetCustomAnimActive() && 
			lCurrentState != eStalkerState_SitAndWait &&
			lCurrentState != eStalkerState_BossFight_Pace)
		{
			return false;
		}
		
		///////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cLuxProp@ pRabbit = null;		
		
		array<iLuxEntity@> vEnts;
		mBaseObj.GetMap().GetEntityArray("*", eLuxEntityType_Prop, "cScrPropRabbitDoll", vEnts);
		
		for (int i = 0; i < vEnts.size(); ++i)
		{
			iLuxEntity@ pEnt = vEnts[i];
			if (pEnt is null) continue;
			
			float fDistSqr = (avRabbitPos - pEnt.GetPosition()).SqrLength();
			if (fDistSqr <= 1.f * 1.f)
			{
				@pRabbit = cLux_ToProp(pEnt);
				break;
			}
		}
		
		if (pRabbit is null) return false;
		if (pCharBody is null) return false;
		
		///////////////////
		// Distance check
		float fDistSqr = (avRabbitPos - mBaseObj.GetPosition()).SqrLength();
		if (fDistSqr > 8.f * 8.f) return false;
		
		///////////////////
		// Path check
		if (mpPathfinder.BuildPathNodeArrayToPos(avRabbitPos) == false) 
			return false;
		
		///////////////////
		// LoS check
		if (ExamineRabbit_GetRabbitInLoS(avRabbitPos) == false)
			return false;
		
		///////////////////
		// Can get to it!
		m_idExamineRabbit_RabbitId = pRabbit.GetID();		
		return true;
	}
	
	//------------------------------------------------------------
	
	void OnTimer_BroadcastGrenadeDetecedMessage(uint64 alId)
	{
		mBaseObj.BroadcastMessage(eCustomEntityMessage_GrenadeDetected, null, mBaseObj.GetPosition(), 0);
	}

	//------------------------------------------------------------

	//} END EXAMINE RABBIT
	
	///////////////////////////////////
	// STATE: EVALUATE OBSTACLE
	//{////////////////////////////////		
	
	//------------------------------------------------------------
	
	bool mbEvaluateObstacle_ObstacleIsTrap = false;
	bool mbEvaluateObstacle_AttackObstacle = false;
	float mfEvaulateObstacle_AttackObstacleTimeOutCount = 7.f;
	cVector3f mvEvaulateObstacle_PathGoal;
	tID m_idEvaluateObstacle_BlockerBodyCandidate = tID_Invalid;
	array<tID> mvEvaluateObstacle_IgnoredProps;	
	array<tID> mvEvaluateObstacle_IgnoredBlockers;	
	array<tID> mvEvaluateObstacle_AddedPathBlockerBodyIds;
	array<cStalker_PathBlockerBodyData> mvEvaluateObstacle_BlockerBodyData;
	
	//------------------------------------------------------------
	
	void State_EvaluateObstacle_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: EvaluateObstacle ------", false, true);
		
		///////////////////
		// Setup vars
		iPhysicsBody@ pBody = cLux_ID_Body(m_idEvaluateObstacle_BlockerBodyCandidate);
		cLuxProp@ pProp = pBody !is null ? cLux_ToProp(cLux_GetBodyEntity(pBody)) : null;
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		mvEvaulateObstacle_PathGoal = mpPathfinder.GetGoalPos();
		
		///////////////////
		// Setup vars
		if (pBody is null || pProp is null)
		{
			mpStateMachine.ChangeState(mpStateMachine.GetPrevState());
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Obstacle doesn't exist, returning to prev state!", false, true);
			return;
		}
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Evaluating prop: " + pProp.GetName(), false, true);
		
		///////////////////
		// Setup state
		mpPathfinder.Stop();
		
		mvEvaluateObstacle_AddedPathBlockerBodyIds.resize(0);
		mbEvaluateObstacle_ObstacleIsTrap = false;
		mbEvaluateObstacle_AttackObstacle = false;
		mfEvaulateObstacle_AttackObstacleTimeOutCount = 7.f;
		
		bool bPathFound = false;
		
		///////////////////
		// Get prev state
		int lPrevState = mpStateMachine.GetPrevState();
		if (lPrevState == eStalkerState_BlockedByProp || 
			lPrevState == eStalkerState_Blocked ||
			lPrevState == eStalkerState_BreakDoor)
		{
			lPrevState = mlBlocked_PrevState;
		}

		///////////////////
		// Path around exists?
		if (EvaluateObstacle_GetPathAroundBlockerBody(m_idEvaluateObstacle_BlockerBodyCandidate, mvEvaluateObstacle_AddedPathBlockerBodyIds))
		{
			bPathFound = true;
			
			///////////////////
			// Take path!
			mpPathfinder.MoveTo(mvEvaulateObstacle_PathGoal, 1.f, false);
			mpStateMachine.ChangeState(lPrevState);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Taking path around blockage!", false, true);
		}
		
		///////////////////
		// No path around?
		else
		{
			bPathFound = false;
			
			mbEvaluateObstacle_ObstacleIsTrap = pProp.GetClassName() == "cScrPropTrap";
			bool bIsDamageArea = Blackboard_GetIsBodyDamageArea(pBody) && !mbEvaluateObstacle_ObstacleIsTrap;
			
			///////////////////
			// Is the blocker a trap?
			if (mbEvaluateObstacle_ObstacleIsTrap)
			{
				mbCheckHoleShortcut_ForceCheck = true;
				mvCheckHoleShortcut_ForcedCheckTarget = mvEvaulateObstacle_PathGoal;
			}
			
			///////////////////
			// Is the blocker a damage area?
			else if (bIsDamageArea)
			{
				EvaluateObstacle_HandleDamageArea(pProp.GetID());
			}
				
			///////////////////
			// Is it a physical blocker?
			else
			{						
				mbEvaluateObstacle_AttackObstacle = true;			
				mpPathfinder.MoveTo(pBody.GetWorldPosition(), 1.f, false);
					
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around blockage, try to break it!", false, true);
			}
		}
		
		///////////////////
		// Sound investigation impossible?
		if (bPathFound == false &&
			lPrevState == eStalkerState_InvestigateSound &&
			mpStateMachine.GetNextState() != eStalkerState_InvestigateSound &&
			msInvestigateSound_SoundName != "PrisonerScream") // Hacky fix to prevent him ignoring the prisoner
		{
			InvestigateSound_AddIgnoredSoundSourceBody(m_idInvestigateSound_SoundSourceBodyId);
			InvestigateSound_ResetVars();
		}
	}

	//------------------------------------------------------------

	void State_EvaluateObstacle_Leave()
	{
		m_idEvaluateObstacle_BlockerBodyCandidate = tID_Invalid;
		mvEvaluateObstacle_AddedPathBlockerBodyIds.resize(0);
	}

	//------------------------------------------------------------

	void State_EvaluateObstacle_Update(float afTimeStep)
	{
		///////////////////
		// Re-evaluate trap?
		if (mbEvaluateObstacle_ObstacleIsTrap && !mbCheckHoleShortcut_ForceCheck)
		{
			iPhysicsBody@ pBody = cLux_ID_Body(m_idEvaluateObstacle_BlockerBodyCandidate);
			cLuxProp@ pProp = pBody !is null ? cLux_ToProp(cLux_GetBodyEntity(pBody)) : null;
			if (pBody is null || pProp is null) return;
			
			EvaluateObstacle_HandleDamageArea(pProp.GetID());
		}
		
		///////////////////
		// Attack the obstacle?
		if (mbEvaluateObstacle_AttackObstacle)
		{
			///////////////////
			// If tried long enough, just enter prev state
			mfEvaulateObstacle_AttackObstacleTimeOutCount -= afTimeStep;
			if (mfEvaulateObstacle_AttackObstacleTimeOutCount <= 0.f)
			{
				mpStateMachine.ChangeState(mpStateMachine.GetPrevState());
				return;
			}
			
			///////////////////
			// Setup vars
			iPhysicsBody@ pBody = cLux_ID_Body(m_idEvaluateObstacle_BlockerBodyCandidate);
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(pBody));
			iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
			
			if (pBody is null)
				return;
			
			///////////////////
			// Near obstacle?
			cBoundingVolume@ pBodyBounds = pBody.GetBoundingVolume();
			float fRadius = mBaseObj.GetCharBody().GetSize().x * 1.25f;
			
			if (cMath_CheckAABBSphereCollision(pBodyBounds.GetMin(), pBodyBounds.GetMax(), mBaseObj.GetPosition(), fRadius) == false)
				return;
					
			///////////////////
			// Prop is in front?
			cVector3f vDir = pBody.GetWorldPosition() - pCharBody.GetPosition();		
			cVector3f vFwd = pCharBody.GetForward();
			vFwd.y = vDir.y;
			vFwd.Normalize();
			
			float fDot = cMath_Vector3Dot(vFwd, cMath_Vector3Normalize(vDir));
			if (fDot < 0.9f && vDir.Length() > 1.5f)
			{
				mpPathfinder.Stop();
				mpMover.TurnToPos(pBody.GetWorldPosition());
				return;
			}
			
			///////////////////
			// Attack it!
			if (pProp !is null)
			{
				SetPreBlockedState(mpStateMachine.GetPrevState());
				m_idBlockedByProp_Entity = pProp.GetID();				
				mpStateMachine.ChangeState(eStalkerState_BlockedByProp);
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_EvaluateObstacle_Message(int alMessageId)
	{		
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return true;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return true;
		
		///////////////
		// In boss fight?
		if (mbBossFight_Active)
		{
			if (alMessageId == eLuxEntityMessage_NearDoor) return false;
			if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
			if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
			if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
			return true;
		}
		
		return false;
	}
		
	//------------------------------------------------------------
	
	bool EvaluateObstacle_GetPathAroundBlockerBody(tID a_idBody, array<tID> &out avAddedPathBlockerBodyIds)
	{
		///////////////
		// Setup vars
		iPhysicsBody@ pBody = cLux_ID_Body(a_idBody);
		cLuxProp@ pProp = pBody !is null ? cLux_ToProp(cLux_GetBodyEntity(pBody)) : null;
		
		if (pBody is null) return false;
		if (pProp is null) return false;
		
		bool bTakeAltPath = false;
		bool bIsDamageArea = Blackboard_GetIsBodyDamageArea(pBody);		
		cVector3f vPathGoal = mpPathfinder.GetGoalPos();
		
		///////////////
		// Get original path dist
		float fOriginalPathDist = -1.f;
		if (mpPathfinder.BuildPathNodeArrayToPos(vPathGoal, 1))
		{
			fOriginalPathDist = mpPathfinder.GetPathNodeArrayFullLength();
		}
		
		///////////////
		// Group together blockers close to each other
		avAddedPathBlockerBodyIds = Blackboard_GetPathBlockerBodyCluster(a_idBody);
		if (avAddedPathBlockerBodyIds.find(a_idBody) == -1)
		{
			// Specified ID is not in array? It's most likely a door, add it manually!
			avAddedPathBlockerBodyIds.push_back(a_idBody);
		}
		
		for (uint i = 0; i < avAddedPathBlockerBodyIds.size(); ++i)
			EvaluateObstacle_AddPathBlocker(avAddedPathBlockerBodyIds[i]);
		
		///////////////////
		// Goal inside blocker? Don't look for alt path
		tID idBlockingBody = tID_Invalid;
		if (EvaluateObstacle_GetPointIsInsidePathBlocker(vPathGoal, idBlockingBody))
		{ 
			bTakeAltPath = false;
		}
		
		///////////////////
		// Look for alt path
		else
		{
			///////////////
			// Is there an alt path?
			bTakeAltPath = mpPathfinder.BuildPathNodeArrayToPos(vPathGoal, 1);
			
			///////////////
			// Still blocked by a damage area?
			if (bTakeAltPath == false && bIsDamageArea)
			{
				///////////////
				// Can we find one if we remove physical blockers?
				array<tID> vRemovedBlockers = EvaluateObstacle_RemoveAllPathBlockers(true, false, false);						
				if (mpPathfinder.BuildPathNodeArrayToPos(vPathGoal, 1))
				{
					bTakeAltPath = true;
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found path previously blocked by physical obstacle!", false, true);
				}
				
				///////////////////
				// Nope, restore blockers we removed!
				else
				{
					for (uint i = 0; i < vRemovedBlockers.size(); ++i)
						EvaluateObstacle_AddPathBlocker(vRemovedBlockers[i]);
				}	
			}
			
			////////////////////////////
			// Skip path if much longer than just breaking the obstacle (unless blocker is a door)
			if (bTakeAltPath && bIsDamageArea == false && pProp.GetIsDoor() == false)
			{
				float fAltPathDist = mpPathfinder.GetPathNodeArrayFullLength();				
				if (fAltPathDist > fOriginalPathDist * 1.5f)
				{
					bTakeAltPath = false;
				}
			}
		}
		
		///////////////////
		// No alt path found, blocker is physical and NOT a door -- remove blocker!
		if (bTakeAltPath == false && bIsDamageArea == false && pProp.GetIsDoor() == false)
		{
			for (uint i = 0; i < avAddedPathBlockerBodyIds.size(); ++i)
				EvaluateObstacle_RemovePathBlocker(avAddedPathBlockerBodyIds[i], false);
				
			avAddedPathBlockerBodyIds.resize(0);
		}
		
		return bTakeAltPath;
	}
		
	//------------------------------------------------------------
	
	void EvaluateObstacle_AddPathBlocker(tID a_idBody, bool abIsOpenDoor = false, bool abManualRemovalOnly = false)
	{
		///////////////
		// Exists? Update it!
		cStalker_PathBlockerBodyData@ pData = EvaluateObstacle_GetPathBlocker(a_idBody);
		if (pData !is null)
		{
			pData.mbManualRemovalOnly = abManualRemovalOnly;
			pData.mbIsOpenDoor = abIsOpenDoor;
			return;
		}
		
		///////////////
		// Add!
		cStalker_PathBlockerBodyData data;
		data.m_idBody = a_idBody;
		data.mfTimeUntilRemoval = gfStalker_AutoRemovePathBlockerTime;
		data.mbIsOpenDoor = abIsOpenDoor;
		data.mbManualRemovalOnly = abManualRemovalOnly;
		mvEvaluateObstacle_BlockerBodyData.push_back(data);
		
		mpPathfinder.AddPathBlockerBody(a_idBody);
	}
	
	//------------------------------------------------------------
	
	void EvaluateObstacle_RemovePathBlocker(tID a_idBody, bool abIsManualRemoval)
	{
		for (uint i = 0 ; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];
			
			if (pData.m_idBody != a_idBody) 								continue;
			if (abIsManualRemoval == false && pData.mbManualRemovalOnly) 	continue;
			
			mvEvaluateObstacle_BlockerBodyData.removeAt(i);			
			break;
		}
						
		mpPathfinder.RemovePathBlockerBody(a_idBody);
	}
	
	//------------------------------------------------------------
	
	cStalker_PathBlockerBodyData@ EvaluateObstacle_GetPathBlocker(tID a_idBody)
	{
		for (uint i = 0 ; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];
			if (pData.m_idBody == a_idBody)
				return pData;
		}
		
		return null;
	}
	
	//------------------------------------------------------------
	
	bool EvaluateObstacle_GetPathBlockerExists(tID a_idBody)
	{
		for (uint i = 0 ; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];
			if (pData.m_idBody == a_idBody)
				return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	array<tID>@ EvaluateObstacle_RemoveAllPathBlockers(bool abPhysicalBlockers, bool abDamageAreas, bool abIsManualRemoval)
	{
		array<tID> vOut;
		
		for (uint i = 0; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];
			iPhysicsBody@ pBody = cLux_ID_Body(pData.m_idBody);
			
			if (pBody is null) continue;
			
			bool bIsDamageArea = Blackboard_GetIsBodyDamageArea(pBody);
			if (bIsDamageArea && abDamageAreas == false) 					continue;
			if (bIsDamageArea == false && abPhysicalBlockers == false) 		continue;
			if (abIsManualRemoval == false && pData.mbManualRemovalOnly) 	continue;
			
			mpPathfinder.RemovePathBlockerBody(pData.m_idBody);
			vOut.push_back(pData.m_idBody);
				
			mvEvaluateObstacle_BlockerBodyData.removeAt(i);
			--i;
		}	
		
		return vOut;
	}
	
	//------------------------------------------------------------
	
	bool EvaluateObstacle_GetPointIsInsidePathBlocker(const cVector3f &in avPos, tID &out a_idBlockingBody)
	{
		for (uint i = 0; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];
			iPhysicsBody@ pBody = cLux_ID_Body(pData.m_idBody);
			cBoundingVolume@ pBounds = pBody !is null ? pBody.GetBoundingVolume() : null;
			
			if (pBounds is null) continue;
			
			cVector3f vOffset = cVector3f(0.2f);
			cVector3f vMin = pBounds.GetMin() - vOffset;
			cVector3f vMax = pBounds.GetMax() + vOffset;
			
			if (cMath_CheckPointInAABBIntersection(avPos, vMin, vMax))
			{
				a_idBlockingBody = pData.m_idBody;
				return true;
			}
		}
		
		a_idBlockingBody = tID_Invalid;
		return false;
	}
	
	//------------------------------------------------------------
	
	bool EvaluateObstacle_GetPointIsInsideSpecificPathBlocker(const cVector3f &in avPos, tID a_idBlocker)
	{
		iPhysicsBody@ pBody = cLux_ID_Body(a_idBlocker);
		cBoundingVolume@ pBounds = pBody !is null ? pBody.GetBoundingVolume() : null;
			
		if (pBounds is null) return false;
			
		cVector3f vOffset = cVector3f(0.2f);
		cVector3f vMin = pBounds.GetMin() - vOffset;
		cVector3f vMax = pBounds.GetMax() + vOffset;
			
		return cMath_CheckPointInAABBIntersection(avPos, vMin, vMax);
	}
	
	//------------------------------------------------------------
	
	cVector3f EvaluateObstacle_GetAvailablePosNearPoint(const cVector3f &in avPos, float afMinRadius = 1.f, float afMaxRadius = 5.f)
	{
		////////////////////////
		// Setup vars
		int lCount = 0;
		cAINode@ pNode = null;		
		tID idBlockingBody = tID_Invalid;
		cVector3f vGoalPos = cVector3f(0.f);
		
		while ((pNode is null || pNode.GetName() == "") && lCount < 5)
		{
			++lCount;
			@pNode = mpPathfinder.GetNodeInCircularSectorAroundPos(avPos, afMinRadius, afMaxRadius, 0.f, 0.f, false, false, false, null);
				
			////////////////////////
			// Increase radius until we find a node
			if (pNode is null) 
			{
				afMaxRadius += 1.f;
				continue;
			}
				
			////////////////////////
			// Don't move to point inside blocker
			if (EvaluateObstacle_GetPointIsInsidePathBlocker(pNode.GetPosition(), idBlockingBody))
			{
				continue;
			}
			
			////////////////////////
			// We found our pos!
			vGoalPos = pNode.GetPosition();
			break;
		}
		
		return vGoalPos;
	}
	
	//------------------------------------------------------------
	
	void EvaluateObstacle_HandleDamageArea(tID a_idBlocker)
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		int lPrevState = mpStateMachine.GetPrevState();
		if (lPrevState == eStalkerState_BlockedByProp || 
			lPrevState == eStalkerState_Blocked ||
			lPrevState == eStalkerState_BreakDoor)
		{
			lPrevState = mlBlocked_PrevState;
		}
		
		///////////////////
		// Retreat if hunting!
		if (mAlertState == eStalkerAlertState_Detected)
		{
			mbRoar_PlayerDetectedOnEnter = true;
			mpStateMachine.ChangeState(eStalkerState_Roar);
			
			if (EnvironmentalDamage_GetDamageAreaType(a_idBlocker) == eDamageType_Gas)
			{
				iLuxEntity@ pBlockerEnt = cLux_ID_Entity(a_idBlocker);
				if (pBlockerEnt !is null && pBlockerEnt.GetVarBool("IsTrap") == false || pBlockerEnt.GetVarString("TriggerCause") != mBaseObj.GetName())
					Achievement_Unlock(eAchievement_ChemicalWeaponExpert);
			}
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around damage area and hunting, enter roar!", false, true);
			return;
		}
		
		///////////////////
		// Try to move to a position near the goal
		cVector3f vAvailablePos = EvaluateObstacle_GetAvailablePosNearPoint(mvEvaulateObstacle_PathGoal);
		if (vAvailablePos.SqrLength() > 0.f && mpPathfinder.BuildPathNodeArrayToPos(vAvailablePos, 1))
		{
			mpPathfinder.MoveTo(vAvailablePos, 1.f, false);
			mpStateMachine.ChangeState(lPrevState);
	
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Moving to position near blocked one!", false, true);
			return;
		}
		
		///////////////////
		// Go to an available hole!
		tID idHole = tID_Invalid;				
		cVector3f[] vHoleCheckDirs = { pCharBody.GetForward() * -1.f, pCharBody.GetRight(), pCharBody.GetRight() * -1.f };
			
		for (uint i = 0; i < vHoleCheckDirs.length(); ++i)
		{
			idHole = GetHoleInDir(vHoleCheckDirs[i], true, true); 
			if (idHole != tID_Invalid)
				break;
		}
			
		if (idHole != tID_Invalid)
		{
			Emerge_AddKnownBlockedHole(idHole);
			
			m_idReturnToHole_Hole = idHole;
			mReturnToHole_Speed = eStalkerSpeed(mpMover.GetSpeedState());
			mpStateMachine.ChangeState(eStalkerState_ReturnToHole);
			
			if (EnvironmentalDamage_GetDamageAreaType(a_idBlocker) == eDamageType_Gas)
			{
				iLuxEntity@ pBlockerEnt = cLux_ID_Entity(a_idBlocker);
				if (pBlockerEnt !is null && pBlockerEnt.GetVarBool("IsTrap") == false || pBlockerEnt.GetVarString("TriggerCause") != mBaseObj.GetName())
					Achievement_Unlock(eAchievement_ChemicalWeaponExpert);
			}
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around damage area, retreat to hole network!", false, true);
		}
			
		///////////////////
		// No accessible hole, ignore the blocker and keep going!
		else
		{
			for (uint i = 0; i < mvEvaluateObstacle_AddedPathBlockerBodyIds.size(); ++i)
				EvaluateObstacle_RemovePathBlocker(mvEvaluateObstacle_AddedPathBlockerBodyIds[i], false);
			
			mvEvaluateObstacle_IgnoredProps.push_back(a_idBlocker);
			
			mpPathfinder.MoveTo(mvEvaulateObstacle_PathGoal, 1.f, false);
			mpStateMachine.ChangeState(lPrevState);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path around damage area, ignore it!", false, true);
		}					
	}
	
	//------------------------------------------------------------

	//} END EVALUATE OBSTACLE
	
	///////////////////////////////////
	// STATE: ROAR
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbRoar_PlayerDetectedOnEnter = false;
	
	//------------------------------------------------------------

	void State_Roar_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Roar ------", false, true);
				
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Stopped);
		
		mpStateMachine.AddTimer("PlayRoarAnim", 0.1f);		
		mpStateMachine.AddTimer("PlayRoarSound", 0.1f);		
		mpStateMachine.AddTimer("Retreat", 5.f);
	}

	//------------------------------------------------------------

	void State_Roar_Leave()
	{
		mbRoar_PlayerDetectedOnEnter = false;
	}

	//------------------------------------------------------------

	void State_Roar_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Roar_Message(int alMessageId)
	{		
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOn) return false;
		if (alMessageId == eCustomEntityMessage_GeneratorTurnedOff) return false;
		if (alMessageId == eCustomEntityMessage_PlayerEnterSaveRoom) return false;
		if (alMessageId == eCustomEntityMessage_PlayerLeaveSaveRoom) return false;
		
		////////////////////
		// Animation over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "RoarAnim")
			{
				Roar_LeaveState();
			}
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Roar_TimerUp(uint64 alId)
	{
		////////////////////
		// Play anim
		if (H64("PlayRoarAnim") == alId)
		{				
			msAnimState = "RoarAnim";
			mpMover.PlayAnimation(Alert_GetAnim(), 0.3f, false);
		}
		
		////////////////////
		// Play sound
		if (H64("PlayRoarSound") == alId)
		{
			mBaseObj.PlaySound("Roar", gsStalkerSound_Frustration, true, true);
		}
		
		////////////////////
		// Retreat
		if (H64("Retreat") == alId)
		{
			Roar_LeaveState();
		}
	}
	
	//------------------------------------------------------------
	
	void Roar_LeaveState()
	{
		//////////////
		// Special case if in boss fight
		if (mbBossFight_Active)
		{
			if (mBossFight_Behaviour == eStalkerBossFightBehaviour_Pace)
			{
				mvBossFightPace_PacePosition = mBaseObj.GetPosition();
			}
			
			mpStateMachine.ChangeState(BossFight_GetCurrentState());
			return;
		}
		
		//////////////
		// Enter retreat
		if (mbRoar_PlayerDetectedOnEnter)
		{
			// TODO: Check if we can get to the player here, in that case, do it!
			mbRetreat_GoToLastKnownPlayerPosThroughHoles = true;	
		}
			
		mpStateMachine.ChangeState(eStalkerState_Retreat);
	}
	
	//------------------------------------------------------------

	//} END ROAR
	
	///////////////////////////////////
	// STATE: BOSS FIGHT DEFAULT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlBossFight_PathFailCount = 0;	
	bool mbBossFight_Active = false;
	bool mbBossFight_Desperate = false;
	bool mbBossFight_UpdateDesperate = false;
	int mlBossFight_EnterCount = 0;
	float mfBossFight_KillDistance = -1.f;
	cVector3f mvBossFight_ClosestJumpPos(0.f);
	tID m_idBossFight_EndArea = tID_Invalid;
	array<tID> mvBossFight_TemporarilyDisabledPathBlockers;
	array<tID> mvBossFight_BridgeEntityIds;
	eStalkerBossFightBehaviour mBossFight_Behaviour = eStalkerBossFightBehaviour_Default;
	
	//------------------------------------------------------------

	void State_BossFightDefault_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BossFightDefault ------");
		
		SetSpeedState(eStalkerSpeed_Walk);
		
		mbBossFight_Active = true;
		mbPresencePaused = true;
		
		++mlBossFight_EnterCount;
		if (mlBossFight_EnterCount == 1)
		{
			SetAlertState(eStalkerAlertState_None);			
			mpStateMachine.AddTimer("Roar", 0.25f);
		}
		else
		{
			SetAlertState(eStalkerAlertState_Detected);
			
			float fTime = mlBossFight_EnterCount > 2 ? 0.f : 6.f;
			mpStateMachine.AddTimer("Move", 0.f);
			mpStateMachine.AddTimer("UpdateMoveSpeed", fTime);			
			mpStateMachine.AddTimer("UpdateDesperate", 0.f);
		}
	}	
	
	//------------------------------------------------------------
	
	void State_BossFightDefault_Leave() 
	{		
		mpMover.SetSpeedMul(1.f);
		mbPresencePaused = false;
	}	
	
	//------------------------------------------------------------
	
	void State_BossFightDefault_Update(float afTimeStep) 
	{				
		///////////////////
		// Always know where player is (if player is in front)
		if (mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos()))
		{
			mBaseObj.RevealPlayerPos();
		}
		
		/////////////////
		// Run if about to do a jump
		if (mvBossFight_ClosestJumpPos.SqrLength() > 0.f)
		{
			float fDistToClosestExtraLongJump = (mvBossFight_ClosestJumpPos - mBaseObj.GetPosition()).SqrLength();
			if (fDistToClosestExtraLongJump < gfStalker_BossFightRunBeforeJumpMinDist * gfStalker_BossFightRunBeforeJumpMinDist && 
				mBaseObj.GetDistanceToPlayer() > gfStalker_BossFightRunBeforeJumpMinDist * 1.25f)
			{
				mpMover.SetSpeedState(eStalkerSpeed_Run);
			}
		}
		
		///////////////////
		// Update speed
		float fSpeedMul = 1.f;		
		if (BossFight_GetAllowSlowdown() &&
			mBaseObj.CheckIsOnScreen(false) == false &&			
			mpStateMachine.TimerExists("ForceRun") == false)
		{
			float fRunMul = 0.5f;
			float fWalkMul = 0.8f;
			
			switch (Game_GetDifficultyMode())
			{
				case eGameMode_Easy:
				{
					if (mbBossFight_Desperate)
					{
						fRunMul = 0.6f;
						fWalkMul = 1.f;
					}
					else
					{
						fRunMul = 0.3f;
						fWalkMul = 0.5f;
					}
					
					break;
				}
				case eGameMode_Hard:
				{
					fRunMul = 0.75f;
					fWalkMul = 0.9f;
					break;
				}
			}
			
			fSpeedMul = mpMover.GetSpeedState() == eStalkerSpeed_Run ? fRunMul : fWalkMul;
			
			
		}
		
		mpMover.SetSpeedMul(fSpeedMul);
		
		///////////////////
		// Update removed blockers
		BossFight_UpdateTemporarilyRemovedBlockers();		
		
		/////////////////////
		// Kill/throw player if they get too close
		if (GetCanKillPlayer(mfBossFight_KillDistance, 2.f))
		{
			int lNewState;
			if (cLux_GetPlayer().GetHealth() <= 0.333f) 	lNewState = eStalkerState_KillPlayer;
			else											lNewState = eStalkerState_ThrowPlayer;
			
			mpStateMachine.ChangeState(lNewState);			
		}
	}
	
	//------------------------------------------------------------
	
	void State_BossFightDefault_TimerUp(uint64 alId)
	{
		/////////////////
		// Roar
		if (H64("Roar") == alId)
		{
			mpStateMachine.ChangeState(eStalkerState_Alert);
		}
		
		/////////////////
		// Move
		else if (H64("Move") == alId)
		{			
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPlayerPos(), 0.f, 5.f, true, false, false, null);
			if (pNode !is null)
			{
				if (BossFight_MoveTo(pNode.GetPosition()) == false)
					return;
			}
			
			mpStateMachine.AddTimer("Move", 0.1f);
			
			if (mpStateMachine.TimerExists("UpdateMoveSpeed") == false)
				mpStateMachine.AddTimer("UpdateMoveSpeed", 1.f);
		}
		
		/////////////////
		// Update move speed
		else if (H64("UpdateMoveSpeed") == alId)
		{
			float fDist = GetPathDistanceToPos(mBaseObj.GetCharBody().GetFeetPosition(), mBaseObj.GetPlayerPos());
			int lSpeedState = eStalkerSpeed_Walk;
			
			bool bPlayerInFront = mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos());
					
			if (fDist >= 40.f) 							lSpeedState = eStalkerSpeed_Run;
			else if (fDist < 15.f && bPlayerInFront) 	lSpeedState = eStalkerSpeed_Run;
			else 										lSpeedState = eStalkerSpeed_Walk;
			
			if (mbBossFight_Desperate || mpStateMachine.TimerExists("ForceRun"))
			{
				lSpeedState = eStalkerSpeed_Run;
			}
			
			int lPrevSpeedState = mpMover.GetSpeedState();
			SetSpeedState(lSpeedState);
			
			if (lSpeedState == eStalkerSpeed_Walk && 
				lPrevSpeedState != lSpeedState)
			{
				mbAllowUprightWalk = cMath_RandRectl(0, 1) == 1;
				if (mbAllowUprightWalk)
					mfAllowUprightWalkCount = cMath_RandRectf(4.f, 10.f);
			}
			
			mpStateMachine.AddTimer("UpdateMoveSpeed", cMath_RandRectf(0.75f, 2.f));
		}
		
		//////////////////
		// Update desperate
		else if (H64("UpdateDesperate") == alId)
		{
			if (mbBossFight_UpdateDesperate)
			{
				cLuxArea@ pEndArea = cLux_ID_Area(m_idBossFight_EndArea);
				iCharacterBody@ pPlayerCharBody = cLux_GetPlayer().GetCharacterBody();
				
				bool bDesperate = pEndArea !is null &&
								  pPlayerCharBody !is null &&
								  pEndArea.CheckCharacterCollision(pPlayerCharBody, mBaseObj.GetMap()) &&
								  pPlayerCharBody.GetPosition().z > mBaseObj.GetPosition().z;
					
				BossFight_SetIsDesperate(bDesperate);
			}
			
			mpStateMachine.AddTimer("UpdateDesperate", cMath_RandRectf(1.f, 2.f));
		}
	}
	
	//------------------------------------------------------------
	
	bool State_BossFightDefault_Message(int alMessageId) 
	{
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
		///////////////
		// Grenade detected
		if (alMessageId == eCustomEntityMessage_GrenadeDetected)
		{
			if (Game_GetDifficultyMode() == eGameMode_Easy) return true;
			
			mpStateMachine.AddTimer("ForceRun", 4.f);
			mpStateMachine.StopTimer("UpdateMoveSpeed");
			mpStateMachine.AddTimer("UpdateMoveSpeed", 0.f);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Detected grenade!", false, true);
		}
		
		///////////////
		// Rabbit doll
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract)
		{
			return mBaseObj.GetDistanceToPlayer() < gfStalker_IgnoreRabbitPlayerDistance;
		}
		
		return true; 
	}
	
	//------------------------------------------------------------
	
	bool BossFight_MoveTo(const cVector3f &in avPos)
	{
		int lBehaviour = mBossFight_Behaviour;
		
		///////////////
		// Update path in map
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap !is null)
		{
			tString sCallback = "void OnStalkerMoveTo(int alBehaviour, const cVector3f &in avGoalPos)";
			if (pMap.ScriptMethodExists(sCallback) && pMap.ScriptPrepare(sCallback))
			{
				pMap.SetArgInt(0, mBossFight_Behaviour);
				pMap.SetArgVector3f(1, avPos);
				pMap.ScriptExecute();
			}
		}
		
		///////////////
		// Behaviour changed?		
		if (mBossFight_Behaviour != lBehaviour) return false;
		
		///////////////
		// Move
		mpPathfinder.MoveTo(avPos, 1.f, false);
		return true;
	}
	
	//------------------------------------------------------------
	
	eStalkerState BossFight_GetCurrentState()
	{
		switch (mBossFight_Behaviour)
		{
			case eStalkerBossFightBehaviour_Default: return eStalkerState_BossFight_Default;
			case eStalkerBossFightBehaviour_Pace: return eStalkerState_BossFight_Pace;
			case eStalkerBossFightBehaviour_Retreat: return eStalkerState_BossFight_Retreat;
		}
		
		return eStalkerState_BossFight_Default;
	}
	
	//------------------------------------------------------------
	
	void BossFight_UpdateBehaviour(eStalkerBossFightBehaviour aBehaviour)
	{
		if (mBossFight_Behaviour == aBehaviour)
			return;
		
		mBossFight_Behaviour = aBehaviour;
		mpStateMachine.ChangeState(BossFight_GetCurrentState());
	}
		
	//------------------------------------------------------------
	
	void BossFight_SetIsDesperate(bool abX)
	{
		if (mBaseObj.IsActive() == false) return;
		if (mbBossFight_Desperate == abX) return;
		
		mbBossFight_Desperate = abX;
		
		if (mbBossFight_Desperate)
			mbBossFight_UpdateDesperate = true;
		
		/////////////////
		// Do roar?
		if (mbBossFight_Desperate && 
			mBaseObj.GetDistanceToPlayer() > 5.f &&
			mBaseObj.Timer_Exists("Timer_DesperateRoarCD") == false)
		{
			int lCurrentState = mpStateMachine.GetCurrentState();			
			if (lCurrentState == eStalkerState_BossFight_Default ||
				lCurrentState == eStalkerState_BossFight_Retreat ||
				lCurrentState == eStalkerState_BossFight_Pace)
			{
				mpMover.PlayAnimation(Alert_GetAnim(), 0.3f, false);
			}
			
			mBaseObj.Timer_Add("Timer_DesperateRoarCD", 10.f);
			
			/////////////////
			// Make sure sound is heard
			cSoundEntity@ pSound = mBaseObj.PlaySound("Sound_Scream", gsStalkerSound_PlayerSpotted, true, true);
			if (pSound !is null)
			{
				pSound.SetUseCustomProperties(true);
				pSound.SetCustomMinDistance(2.f);
				pSound.SetCustomMaxDistance(80.f);
			}			
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_BossFightHandleHurt(uint64 alId)
	{		
		///////////////////////
		// Ignore environmental damage for a while
		if (mHurt_DamageType == eDamageType_Gas ||
			mHurt_DamageType == eDamageType_Fire)
		{
			mBaseObj.Timer_Add(gsStalker_BossFightIgnoreEnvironmentalDamageTimer, 10.f);
		}
		
		///////////////////////
		// Fall?
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pCharBody is null) return;
		
		bool bOnGround = pCharBody.IsOnGround();		
		if (mpStateMachine.GetCurrentState() == eStalkerState_ExamineRabbit)
		{
			float fDist;
			cVector3f vNrm;
			iPhysicsBody@ pBody = cLux_GetClosestBody(pCharBody.GetFeetPosition() + cVector3f(0.f, 0.1f, 0.f), cVector3f_Down, 5.f, fDist, vNrm);
			iLuxEntity@ pEnt = cLux_GetBodyEntity(pBody);
			
			bOnGround = true;
			
			if (pBody is null)
			{
				bOnGround = false;
			}
			else if (pEnt !is null && 
					 cString_GetFirstStringPos(pEnt.GetName(), "broken") != -1 &&
					 cString_GetFirstStringPos(pEnt.GetName(), "bridge") != -1)
			{	
				bOnGround = false;					
			}
		}
		
		if (mHurt_DamageType == eDamageType_Grenade &&
			bOnGround == false &&
			BossFight_GetIsOnBridge(pCharBody.GetFeetPosition(), false) == false)
		{			
			BossFightJump_Fall(false);
			
			msAnimState = "IdleToFall";
			PlayCutsceneAnimation(gsStalkerAnim_IdleToFall, false, 0.3f, "", 0.8f, 0.f, false, cVector3f(0.f), 0.f, false, false, true);
		}
		
		///////////////////////
		// Enter hurt?
		else
		{
			if (mpStateMachine.GetCurrentState() == eStalkerState_BossFight_Jump)
				return;
			
			///////////////////////
			// Retreat?
			bool bShotgunDamage = mHurt_DamageType == eDamageType_Gun && BulletHandler_GetLastDamageBulletType() == eBulletType_Shotgun;
			if ((mHurt_DamageType == eDamageType_Grenade || 
				 mHurt_DamageType == eDamageType_Gas ||
				 mHurt_DamageType == eDamageType_Fire ||
			     bShotgunDamage) &&
				BossFightRetreat_Setup())
			{
				mBossFight_Behaviour = eStalkerBossFightBehaviour_Retreat;
			}
			
			////////////////////
			// Enter hurt
			if (mbPlayQuickTurnAnim)
				mlQuickTurnDoneState = eStalkerState_Hurt;
			else
				mpStateMachine.ChangeState(eStalkerState_Hurt);			
		}
		
		////////////////////
		// Allow slowdown
		float fSlowdownTime = mBossFight_Behaviour == eStalkerBossFightBehaviour_Retreat ? 60.f : 30.f;
		BossFight_SetAllowSlowdownTime(fSlowdownTime);
	}
	
	//------------------------------------------------------------
	
	bool BossFight_GetIsOnBridge(const cVector3f &in avCheckPos, bool abWoodenBridgeOnly)
	{
		cVector3f vMin = avCheckPos - cVector3f(0.5f);
		cVector3f vMax = avCheckPos + cVector3f(0.5f);
		array<iPhysicsBody@> vBodies;
					
		mBaseObj.GetMap().GetPhysicsWorld().GetBodiesInAABB(vMin, vMax, false, false, vBodies);
				
		for (int i = 0; i < vBodies.size(); ++i)
		{
			cLuxProp@ pProp = cLux_ToProp(cLux_GetBodyEntity(vBodies[i]));
					
			if (pProp is null) continue;
			if (pProp.GetClassName() != "cScrPropSwingDoor") continue;
			if (abWoodenBridgeOnly && pProp.GetIsBreakable() == false) continue;
					
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	bool BossFight_GetAllowSlowdown()
	{
		if (mbBossFight_UpdateDesperate == false)
		{
			return true;
		}
		
		bool bAllowSlowdown;
		switch (Game_GetDifficultyMode())
		{
			case eGameMode_Easy: 
			{
				bAllowSlowdown = true;
				break;
			}
			case eGameMode_Hard:
			{
				bAllowSlowdown = mbBossFight_Desperate == false && 
								 mBaseObj.Timer_Exists("Timer_BossFight_AllowSlowdown"); 
				break;
			}
			default:
			{
				bAllowSlowdown = mbBossFight_Desperate == false;
				break;
			}
		}	
		
		return bAllowSlowdown;
	}
	
	//------------------------------------------------------------
	
	void BossFight_SetAllowSlowdownTime(float afTime)
	{
		mBaseObj.Timer_Add("Timer_BossFight_AllowSlowdown", afTime);
	}
	
	//------------------------------------------------------------
	
	void BossFight_UpdateTemporarilyRemovedBlockers()
	{
		/////////////////
		// Any temporarly disabled path blockers to restore?
		cBoundingVolume@ pBV = mBaseObj.GetCharBody().GetCurrentBody().GetBoundingVolume();
		
		for (int i = 0; i < mvBossFight_TemporarilyDisabledPathBlockers.size(); ++i)
		{
			bool bRestore = true;
			
			tID idBlocker = mvBossFight_TemporarilyDisabledPathBlockers[i];
			iPhysicsBody@ pBody = cLux_ID_Body(idBlocker);
			cBoundingVolume@ pBodyBV = pBody !is null ? pBody.GetBoundingVolume() : null;
			
			if (pBody !is null && pBodyBV !is null)
			{
				if (cMath_CheckAABBIntersection(pBV.GetMin(), pBV.GetMax(), pBodyBV.GetMin(), pBodyBV.GetMax()) || 
					EvaluateObstacle_GetPointIsInsideSpecificPathBlocker(mpPathfinder.GetGoalPos(), idBlocker))
				{
					bRestore = false;
				}
			}
			
			if (bRestore)
			{
				if (pBody !is null && 
					pBody.IsActive() && 
					EvaluateObstacle_GetPathBlockerExists(idBlocker))
				{
					mpPathfinder.AddPathBlockerBody(idBlocker);
				}
					
				mvBossFight_TemporarilyDisabledPathBlockers.removeAt(i);
				--i;	
			}
		}
	}
	
	//------------------------------------------------------------
	
	void BossFight_OnPathFindingResult(bool abSuccess)
	{		
		//////////////////////
		// Success?
		if (abSuccess)
		{
			mlBossFight_PathFailCount = 0;
			return;
		}
		else
		{
			++mlBossFight_PathFailCount;
		}
		
		////////////////
		// Setup vars
		cVector3f vGoalPos = mpPathfinder.GetGoalPos();
		cBoundingVolume@ pBV = mBaseObj.GetCharBody().GetCurrentBody().GetBoundingVolume();
		
		//////////////////////
		// Stalker or goal inside blocker that can only be removed manually?
		// (Then remove blocker temporarily)
		for (int i = 0; i < mvEvaluateObstacle_BlockerBodyData.size(); ++i)
		{
			cStalker_PathBlockerBodyData@ pData = mvEvaluateObstacle_BlockerBodyData[i];			
			iPhysicsBody@ pBody = cLux_ID_Body(pData.m_idBody);
			cBoundingVolume@ pBodyBV = pBody !is null ? pBody.GetBoundingVolume() : null;
			
			if (pBody is null) continue;
			if (pBodyBV is null) continue;
			if (pData.mbManualRemovalOnly == false) continue;
			if (mvBossFight_TemporarilyDisabledPathBlockers.find(pData.m_idBody) != -1) 
				continue;
			
			if (cMath_CheckAABBIntersection(pBV.GetMin(), pBV.GetMax(), pBodyBV.GetMin(), pBodyBV.GetMax()) || 
				EvaluateObstacle_GetPointIsInsideSpecificPathBlocker(vGoalPos, pData.m_idBody))
			{
				mvBossFight_TemporarilyDisabledPathBlockers.push_back(pData.m_idBody);
				mpPathfinder.RemovePathBlockerBody(pData.m_idBody);
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Stalker or goal pos inside path blocker, temporarily removing it!", false, true);
			}
		}		
		
		//////////////////////
		// No path!
		if (mlBossFight_PathFailCount >= 3)
		{
			//////////////////////
			// Enter pace and wait as failsafe!
			mvBossFightPace_PacePosition = mBaseObj.GetPosition();
			mBossFight_Behaviour = eStalkerBossFightBehaviour_Pace;
			mpStateMachine.ChangeState(eStalkerState_BossFight_Pace);
					
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path found, entering pace as failsafe!", false, true);				
			return;
		}
			
		//////////////////////
		// Build path with blockers removed
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path found, searching for new...", false, true);
				
			//////////////////////
			// Remove all blockers
			// (Except for manual ones)
			array<tID> vBlockersToRestore;
			array<tID> vRemovedBlockers = EvaluateObstacle_RemoveAllPathBlockers(true, true, false);
				
			//////////////////////
			// Ignore blocker if stalker collides with it
			array<iPhysicsBody@> vRemovedBlockerBodies;				
			for (int i = 0; i < vRemovedBlockers.size(); ++i)
			{
				iPhysicsBody@ pBody = cLux_ID_Body(vRemovedBlockers[i]);
				cBoundingVolume@ pBodyBV = pBody !is null ? pBody.GetBoundingVolume() : null;
					
				if (pBody is null) continue;
				if (pBodyBV is null) continue;
				if (cMath_CheckAABBIntersection(pBV.GetMin(), pBV.GetMax(), pBodyBV.GetMin(), pBodyBV.GetMax()))
					continue;
				
				vRemovedBlockerBodies.push_back(pBody);
			}
			
			//////////////////////
			// Path exists?
			if (mpPathfinder.BuildPathNodeArrayToPos(vGoalPos, 1))
			{				
				//////////////////////
				// Find removed blockers not in way of path
				for (int i = 1; i < mpPathfinder.GetPathNodeArraySize() + 1; ++i)
				{
					cAINode@ pPrevNode = mpPathfinder.GetPathNodeArrayNode(i - 1);
					cAINode@ pNode = null;
					
					if (i == mpPathfinder.GetPathNodeArraySize())
					{
						@pNode = mpPathfinder.GetNodeAtPos(vGoalPos, 0.f, 5.f, true, false, false, null);
					}
					else
					{
						@pNode = mpPathfinder.GetPathNodeArrayNode(i);
					}
						
					if (pNode is null) continue;
					if (pPrevNode is null) continue;
												
					for (int j = 0; j < vRemovedBlockerBodies.size(); ++j)
					{
						iPhysicsBody@ pBody = vRemovedBlockerBodies[j];
						cBoundingVolume@ pBounds = pBody.GetBoundingVolume();
							
						if (pBounds is null) continue;
						
						cVector3f vExtraSize = cVector3f(0.25f);
						cVector3f vMin = pBounds.GetMin() - vExtraSize;
						cVector3f vMax = pBounds.GetMax() + vExtraSize;
						cVector3f vStart = pPrevNode.GetPosition();
						cVector3f vEnd = pNode.GetPosition();
							
						float fT;	
						cVector3f vPos;
													
						if (cMath_CheckAABBLineIntersection(vMin, vMax, vStart, vEnd, vPos, fT) == false)
						{
							if (vBlockersToRestore.find(pBody.GetID()) == -1)
								vBlockersToRestore.push_back(pBody.GetID());
						}
					}
				}
					
				//////////////////////
				// Restore removed blockers not in way of path
				for (int i = 0; i < vBlockersToRestore.size(); ++i)
				{
					tID idBlocker = vBlockersToRestore[i];
					EvaluateObstacle_AddPathBlocker(idBlocker, GetPathBlockerIsOpenDoor(idBlocker), false);				
				}
					
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found new path and restored all eligible path blockers!", false, true);
			}
		}			
	}
	
	//------------------------------------------------------------
	
	void BossFight_OnAttackDamage()
	{
		//////////////////////
		// Ignore bridges
		for (int i = 0; i < mvBossFight_BridgeEntityIds.size(); ++i)
		{
			cLux_ShapeDamage_AddIgnoreEntityId(mvBossFight_BridgeEntityIds[i]);
		}
	}
	
	//------------------------------------------------------------

	//} END BOSS FIGHT DEFAULT
	
	///////////////////////////////////
	// STATE: BOSS FIGHT JUMP
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbBossFightJump_HangOnLedge = false;
	bool mbBossFightJump_ThrewPlayer = false;
	bool mbBossFightJump_HurtMidJump = false;
	bool mbBossFightJump_Fall = false;
	bool mbBossFightJump_JumpingToPlatform = false;
	bool mbBossFightJump_TurnAround = false;
	bool mbBossFightJump_IncreasedHurtCount = false;
	bool mbBossFightJump_PlayerBrokeBridge = false;
	float mfBossFightJump_Angle = 0.f;
	float mfBossFightJump_AnimDistOffset = -1.f;
	int mlBossFightJump_HurtWhileHangingCount = 0;
	int mlBossFightJump_JumpCount = 0;
	cVector3f mvBossFightJump_StartPos(0.f);
	cVector3f mvBossFightJump_GoalPos(0.f);
	cVector3f mvBossFightJump_CutscenePos(0.f);
	cVector3f mvBossFightJump_FallVelocity(0.f);
	tString msBossFightJump_JumpAnim = "";
	tString msBossFightJump_FallStartAnim = "";
	tString msBossFightJump_ClimbUpLedgeAnim = "";
	tString msBossFightJump_ClimbUpLedgeTackleAnim = "";
	
	//------------------------------------------------------------

	void State_BossFightJump_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BossFightJump ------", false, true);
		
		/////////////////////
		// Setup state
		mpPathfinder.Stop();
		SetSpeedState(eStalkerSpeed_Stopped);
		
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		pCharBody.SetTestCollision(false);		
		mpMover.SetUseMoveStateAnimations(false);
		
		mbBossFightJump_ThrewPlayer = false;
		mbBossFightJump_HurtMidJump = false;
		mbBossFightJump_IncreasedHurtCount = false;
		mlBossFightJump_JumpCount = 0;
		msBossFightJump_JumpAnim = "";
		msBossFightJump_FallStartAnim = "";
		msBossFightJump_ClimbUpLedgeAnim = "";
		msBossFightJump_ClimbUpLedgeTackleAnim = "";
		
		mbProximityDetectionActive = false;
		mbPresencePaused = true;
		
		/////////////////////
		// Setup jump
		BossFightJump_Setup(false);
	}

	//------------------------------------------------------------

	void State_BossFightJump_Leave()
	{				
		mbBossFightJump_PlayerBrokeBridge = false;
		mbBossFightJump_HangOnLedge = false;
		mbBossFightJump_JumpingToPlatform = false;
		mbBossFightJump_TurnAround = false;
		
		mBaseObj.GetCharBody().SetTestCollision(true);		
		mpMover.SetUseMoveStateAnimations(true);
		
		mbProximityDetectionActive = true;
		mbPresencePaused = false;
		
		mBaseObj.Timer_Add("Timer_QuickTurnDisallowed", 0.5f);
	}

	//------------------------------------------------------------
	
	void State_BossFightJump_Update(float afTimeStep)
	{
		if (mpStateMachine.TimerExists("Exit")) return;
		
		/////////////////////
		// Setup vars
		cLuxMap@ pMap = mBaseObj.GetMap();
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();
		
		cVector3f vPos = mBaseObj.GetPosition();
		
		if (pMap is null) return;
		if (pMeshEnt is null) return;
		if (pCharBody is null) return;
		if (pAnim is null) return;
		
		/////////////////////
		// Falling?
		if (mbBossFightJump_Fall)
		{
			if (pAnim.GetName() == gsStalkerAnim_Fall)
			{
				float fFriction = 7.f;
				cVector3f vVelXZ(mvBossFightJump_FallVelocity.x, 0.f, mvBossFightJump_FallVelocity.z);
				float fSpeed = cMath_IncreaseTo(vVelXZ.Length(), fFriction * afTimeStep, 0.f);
				vVelXZ.Normalize();
				
				mvBossFightJump_FallVelocity.x = vVelXZ.x * fSpeed;
				mvBossFightJump_FallVelocity.z = vVelXZ.z * fSpeed;
				mvBossFightJump_FallVelocity.y += pMap.GetPhysicsWorld().GetGravity().y * afTimeStep;
				
				cVector3f vPosAdd = mvBossFightJump_FallVelocity * afTimeStep;
				SetCutscenePosition(mvCutsceneAnimation_Position + vPosAdd);
			}
			
			return;
		}	
		
		/////////////////////
		// Jump
		if (msAnimState == "Jump")
		{			
			float fTimePos = pAnim.GetTimePosition();
			float fMinT = 0.360f;
			float fMaxT = 0.707f;
			
			float fT = cMath_Clamp((fTimePos - fMinT) / (fMaxT - fMinT), 0.f, 1.f);
			vPos = mvBossFightJump_StartPos * (1.f - fT) + mvBossFightJump_GoalPos * fT;
			
			cVector3f vOffsetDir = mvBossFightJump_GoalPos - mvBossFightJump_StartPos;
			vOffsetDir.y = 0.f;
			vOffsetDir.Normalize();
			
			cVector3f vOffset = vOffsetDir * cMath_InterpolateLinear(fT, 0.f, mfBossFightJump_AnimDistOffset);
			mvBossFightJump_CutscenePos = vPos + vOffset;
			
			SetCutscenePosition(mvBossFightJump_CutscenePos);
			
			/////////////////////
			// Jumping to a destroyed bridge? Fall!
			bool bCheckForBridge = fT >= 0.4f && 
								   mlBossFightJump_JumpCount == 1 &&
								   mbBossFightJump_JumpingToPlatform == false &&
								   mbBossFightJump_TurnAround == false;
			
			if (bCheckForBridge && 
				BossFight_GetIsOnBridge(mvBossFightJump_GoalPos, false) == false)
			{
				BossFightJump_Fall(false);
				
				if (fTimePos <= fMaxT)
				{
					msAnimState = "JumpFail";
					PlayCutsceneAnimation(gsStalkerAnim_JumpFail, false, 0.3f, "", 0.8f, pAnim.GetRelativeTimePosition(), true, mvBossFightJump_CutscenePos, mfBossFightJump_Angle, false, true, true);
				}
				else
				{
					msAnimState = "IdleToFallJumpLand";
					PlayCutsceneAnimation(gsStalkerAnim_IdleToFallJumpLand, false, 0.3f, "", 1.f, 0.f, true, mvBossFightJump_CutscenePos, mfBossFightJump_Angle, false, false, true);
					
					cAnimationState@ pFallAnim = pMeshEnt.GetAnimationStateFromName(gsStalkerAnim_IdleToFallJumpLand);
					if (pFallAnim !is null)
						pFallAnim.FadeSpeed(0.8f, 0.7f);
				}
			}
			
			////////////////////
			// Throw player?
			cVector3f vPlayerPos = mBaseObj.GetPlayerPos();
			if (cLux_GetPlayer().GetCurrentStateId() == ePlayerState_CutsceneAnimation) return;
			if (mbBossFightJump_ThrewPlayer) return;
			if (mbBossFightJump_HangOnLedge) return;
			if ((vPlayerPos - vPos).SqrLength() > 5.f * 5.f) return;
			if ((vPlayerPos - mvBossFightJump_GoalPos).SqrLength() > 2.5f * 2.5f) return;
			if (mvBossFightJump_GoalPos.SqrLength() <= 0.f) return;
				
			mbBossFightJump_ThrewPlayer = true;
			ThrowPlayer_ThrowPlayerWhileInCutscene(mvBossFightJump_GoalPos);
		}
		
		/////////////////////
		// Climb up
		else if (msAnimState == "ClimbUp")
		{
			SetCutscenePosition(mvBossFightJump_CutscenePos);
		}
	}
	
	//------------------------------------------------------------

	bool State_BossFightJump_Message(int alMessageId)
	{		
		//////////////////
		// Anim over
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{			
			//////////////////
			// Jump
			if (msAnimState == "Jump")
			{
				/////////////////
				// Tackle player if hanging on ledge and close enough!
				if (mbBossFightJump_HangOnLedge)
				{
					msAnimState = "ClimbUp";
					
					float fDist = (mBaseObj.GetPlayerPos() - mvBossFightJump_GoalPos).Length();
					if (fDist < 2.5f)
					{
						mpStateMachine.AddTimer("Tackle", 0.3f);
						PlayCutsceneAnimation(msBossFightJump_ClimbUpLedgeTackleAnim, false, 0.f, "", 1.f, 0.f, true, mvBossFightJump_StartPos, mfBossFightJump_Angle, false, true, false);
					}
					else
					{
						PlayCutsceneAnimation(msBossFightJump_ClimbUpLedgeAnim, false, 0.f, "", 1.f, 0.f, true, mvBossFightJump_StartPos, mfBossFightJump_Angle, false, true, false);
					}	
				}
								
				/////////////////
				// Exit!
				else
				{
					float fTime = mbBossFightJump_ThrewPlayer ? 1.f : 0.f;
					mpStateMachine.AddTimer("Exit", fTime);
				}
			}
			
			//////////////////
			// Climb up
			else if (msAnimState == "ClimbUp")
			{
				msAnimState = "";
				
				float fTime = mbBossFightJump_ThrewPlayer ? 1.f : 0.f;
				mpStateMachine.AddTimer("Exit", fTime);
			}
			
			//////////////////
			// Falling
			else if (msAnimState == "FallStart" ||
					 msAnimState == "IdleToFall" ||
					 msAnimState == "IdleToFallJumpLand" ||
					 msAnimState == "JumpFail")
			{
				msAnimState = "";
				
				float fTimePos;
				float fSpeed;
				tString sAnim = mpStateMachine.GetCurrentMessageData().msX;
				cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(sAnim);
				
				if (pAnim !is null)
				{
					fTimePos = pAnim.GetLength();
					fSpeed = pAnim.GetSpeed();
				}
				
				BossFightJump_PlayFallLoopAnim(sAnim, fTimePos, 0.f, -16.624f, fSpeed);
			}
		}
		
		//////////////////
		// Animation message
		else if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			int lMessageId = mpStateMachine.GetCurrentMessageData().mlX;
			
			//////////////////
			// Speed up anim
			if (lMessageId == 1 && msBossFightJump_JumpAnim == gsStalkerAnim_JumpHangOnLedge)
			{
				cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(msBossFightJump_JumpAnim);
				if (pAnim is null) return true;
				
				pAnim.FadeSpeed(1.2f, 1.f);
			}
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_BossFightJump_TimerUp(uint64 alId)
	{		
		////////////////////
		// Tackle
		if (H64("Tackle") == alId)
		{
			////////////
			// Disable anim hitbox so it doesn't interfere with the throwing
			iLuxEntity@ pHitbox = cLux_ID_Entity(m_idCutsceneAnimation_HitboxEntId);
			if (pHitbox !is null)
			{
				pHitbox.SetActive(false);
				pHitbox.GetMainBody().SetCollide(false);
			}
			
			////////////
			// Throw player
			mbBossFightJump_ThrewPlayer = true;
			ThrowPlayer_ThrowPlayerWhileInCutscene(mvBossFightJump_GoalPos);
		}
		
		////////////////////
		// Fall on land
		else if (H64("FallOnLand") == alId)
		{
			BossFightJump_Fall(true);
		}
		
		////////////////////
		// Deactivate
		else if (H64("Deactivate") == alId)
		{
			mBaseObj.SetActive(false);
		}
		
		////////////////////
		// Exit
		else if (H64("Exit") == alId)
		{
			int lNextState = BossFight_GetCurrentState();		
			
			if (mbBossFightJump_ThrewPlayer) lNextState = eStalkerState_Alert;
			else if (mbBossFightJump_HurtMidJump) lNextState = eStalkerState_Hurt;
			
			mpStateMachine.ChangeState(lNextState);
		}
	}
	
	//------------------------------------------------------------
	
	void BossFightJump_Setup(bool abSecondJump)
	{
		/////////////////////
		// Setup vars
		cAnimationState@ pAnim = mBaseObj.GetCurrentAnimationState();
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		if (pAnim is null) return;
		if (pMeshEnt is null) return;
		if (pCharBody is null) return;
		
		/////////////////////
		// Get jump vars
		if (abSecondJump)
		{		
			/////////////////////
			// Reset timers
			mpStateMachine.StopTimer("Tackle");
			mpStateMachine.StopTimer("Deactivate");
			mpStateMachine.StopTimer("Exit");
			
			/////////////////////
			// Setup transition from prev anim
			tString sRootBone = "j_Root";
			cMatrixf mtxCurrent = pMeshEnt.GetBoneWorldMatrixInAnim(sRootBone, pAnim.GetName(), pAnim.GetTimePosition(), false);
			cMatrixf mtxNext = pMeshEnt.GetBoneWorldMatrixInAnim(sRootBone, gsStalkerAnim_JumpLong, 0.f, false);

			cVector3f vDiff = mtxCurrent.GetTranslation() - mtxNext.GetTranslation();
			vDiff.y = 0.f;
			cVector3f vStartPos = pCharBody.GetFeetPosition() + vDiff;
			
			mvBossFightJump_StartPos = vStartPos;
			pCharBody.SetFeetPosition(vStartPos, false);		
		}
		else
		{
			mvBossFightJump_CutscenePos = cVector3f(0.f);
			mvBossFightJump_StartPos = pCharBody.GetFeetPosition();		
		}
		
		++mlBossFightJump_JumpCount;		
		
		cVector3f vToGoal = mvBossFightJump_GoalPos - mvBossFightJump_StartPos;
		vToGoal.y = 0.f;
		vToGoal.Normalize();
		
		cVector3f vGoalRayStart = mvBossFightJump_GoalPos + vToGoal * 0.55f + cVector3f(0.f, 0.5f, 0.f);
		
		float fDist;
		cVector3f vNrm;
		if (cLux_GetClosestBody(vGoalRayStart, cVector3f_Down, 1.f, fDist, vNrm) !is null)
		{
			mvBossFightJump_GoalPos = vGoalRayStart + cVector3f_Down * fDist;
		}
		
		vToGoal = mvBossFightJump_GoalPos - mvBossFightJump_StartPos;		
		mfBossFightJump_Angle = cMath_GetAngleFromPoints3D(0.f, cMath_Vector3Normalize(vToGoal)).y;
		
		float fJumpDist = vToGoal.Length();
		mbBossFightJump_HangOnLedge = mbBossFightJump_JumpingToPlatform && 
									  mbBossFightJump_TurnAround == false &&
									  ((fJumpDist >= 7.f && mbBossFightJump_PlayerBrokeBridge == false) ||
									   (fJumpDist >= 10.f && mbBossFightJump_PlayerBrokeBridge));
		
		/////////////////////
		// Play anim
		msBossFightJump_FallStartAnim = gsStalkerAnim_FallStart;
		msBossFightJump_ClimbUpLedgeAnim = gsStalkerAnim_ClimbUpLedge;
		msBossFightJump_ClimbUpLedgeTackleAnim = gsStalkerAnim_ClimbUpLedgeTackle;
		
		msAnimState = "Jump";		
		bool bStayInAnim = false;
		
		if (mbBossFightJump_TurnAround)
		{
			mfBossFightJump_Angle += cMath_Pi;
			msBossFightJump_JumpAnim = gsStalkerAnim_JumpShortTurnAround;
			mfBossFightJump_AnimDistOffset = gfStalker_JumpShortAnimDistOffset;
		}
		else if (fJumpDist >= 10.f)
		{
			mbBossFightJump_HangOnLedge = true;			
			bStayInAnim = true;
			msBossFightJump_JumpAnim = gsStalkerAnim_JumpExtraLongHangOnLedge;
			mfBossFightJump_AnimDistOffset = gfStalker_JumpExtraLongHangOnLedgeAnimDistOffset;
			
			msBossFightJump_FallStartAnim = gsStalkerAnim_FallStartExtraLong;
			msBossFightJump_ClimbUpLedgeAnim = gsStalkerAnim_ClimbUpLedgeExtraLong;
			msBossFightJump_ClimbUpLedgeTackleAnim = gsStalkerAnim_ClimbUpLedgeTackleExtraLong;
		}
		else if (fJumpDist >= 5.f)
		{
			if (mbBossFightJump_HangOnLedge)
			{
				bStayInAnim = true;
				msBossFightJump_JumpAnim = gsStalkerAnim_JumpHangOnLedge;
				mfBossFightJump_AnimDistOffset = gfStalker_JumpHangOnLedgeAnimDistOffset;
			}
			else
			{
				msBossFightJump_JumpAnim = gsStalkerAnim_JumpLong;
				mfBossFightJump_AnimDistOffset = gfStalker_JumpLongAnimDistOffset;
			}
		}
		else if (fJumpDist < 5.f)
		{
			msBossFightJump_JumpAnim = gsStalkerAnim_JumpShort;
			mfBossFightJump_AnimDistOffset = gfStalker_JumpShortAnimDistOffset;
		}	
		
		float fFadeTime = abSecondJump ? 0.f : 0.3f;
		PlayCutsceneAnimation(msBossFightJump_JumpAnim, false, fFadeTime, "", 1.f, 0.f, true, mvBossFightJump_StartPos, mfBossFightJump_Angle, false, true, bStayInAnim);
	}
	
	//------------------------------------------------------------
	
	bool BossFightJump_HandleHurt(int alDamageType)
	{		
		////////////////////
		// Setup vars
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		bool bForceSound = false;
		
		bool bClimbedUp;
		bool bHanging = BossFightJump_GetIsHangingOnLedge(bClimbedUp);
		
		////////////////////
		// Took damage while in jump and would hang on ledge = fall when land
		if (bHanging == false && 
			bClimbedUp == false &&
			mpStateMachine.TimerExists("FallOnLand") == false)
		{
			cAnimationState@ pAnimA  = pMeshEnt.GetAnimationStateFromName(gsStalkerAnim_JumpHangOnLedge);
			cAnimationState@ pAnimB  = pMeshEnt.GetAnimationStateFromName(gsStalkerAnim_JumpExtraLongHangOnLedge);
			cAnimationState@ pCurrentAnim = null;
			
			if (pAnimA.IsActive()) 		@pCurrentAnim = pAnimA;
			else if (pAnimB.IsActive()) @pCurrentAnim = pAnimB;
			
			if (pCurrentAnim !is null)
			{
				bForceSound = true;
				
				float fMinFallTime = pCurrentAnim is pAnimA ? gfStalker_HangOnLedgeAnimMinAllowFallRelTimePos :
															  gfStalker_HangOnLedgeLongAnimMinAllowFallRelTimePos;
				float fCurrentTime = pCurrentAnim.GetTimePosition();
				float fGoalTime = fMinFallTime * pCurrentAnim.GetLength();
				float fTime = fGoalTime - fCurrentTime;
				
				mpStateMachine.AddTimer("FallOnLand", fTime);
			}
		}
		
		////////////////////
		// Allow slowdown
		float fSlowdownTime = 60.f;
		if (mHurt_DamageType == eDamageType_Gun && BulletHandler_GetLastDamageBulletType() == eBulletType_Revolver)
			fSlowdownTime = 30.f;
		
		BossFight_SetAllowSlowdownTime(fSlowdownTime);
		
		////////////////////
		// Hurt count
		if (bHanging && 
			mbBossFightJump_IncreasedHurtCount == false)
		{
			++mlBossFightJump_HurtWhileHangingCount;
			mbBossFightJump_IncreasedHurtCount = true;
		}
		
		////////////////////
		// Fall?
		bool bFall = bHanging && mlBossFightJump_HurtWhileHangingCount > 0;		
		if (bFall)
		{
			bForceSound = true;
			BossFightJump_Fall(true);
		}
		else if (bHanging == false)
		{
			mbBossFightJump_HurtMidJump = true;
		}
		
		////////////////////
		// Feedback
		if (mbBossFightJump_HurtMidJump || bClimbedUp == false)
		{
			if (mbBossFightJump_Fall == false)
				Hurt_PlaySound(bForceSound);
		}
		
		return bFall;
	}
	
	//------------------------------------------------------------
	
	void BossFightJump_Fall(bool abPlayStartFallAnim)
	{
		if (mbBossFightJump_Fall) return;
		
		mbBossFightJump_Fall = true;
		
		if (abPlayStartFallAnim)
		{
			msAnimState = "FallStart";
			PlayCutsceneAnimation(msBossFightJump_FallStartAnim, false, 0.3f, "", 0.9f, 0.f, true, mvBossFightJump_CutscenePos, mfBossFightJump_Angle, false, true, true);
			
			cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(msBossFightJump_FallStartAnim);
			if (pAnim !is null)
				pAnim.FadeSpeed(1.f, pAnim.GetLength());
		}
		
		mpStateMachine.AddTimer("Deactivate", 8.f);
		
		cScript_SetGlobalVarBool("Arena_StalkerFellIntoRift", true);
		Achievement_Unlock(eAchievement_BeastMaster);
		
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap !is null)
		{
			tString sCallback = "void OnStalkerFall()";
			if (pMap.ScriptMethodExists(sCallback) && pMap.ScriptPrepare(sCallback))
				pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------
	
	bool BossFightJump_GetIsHangingOnLedge(bool &out abClimbedUp)
	{
		abClimbedUp = false;
		bool bRet = false;
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		
		if (pMeshEnt !is null)
		{
			cAnimationState@ pAnimA = pMeshEnt.GetAnimationStateFromName(gsStalkerAnim_JumpHangOnLedge);
			cAnimationState@ pAnimB = pMeshEnt.GetAnimationStateFromName(msBossFightJump_ClimbUpLedgeAnim);
			cAnimationState@ pAnimC = pMeshEnt.GetAnimationStateFromName(msBossFightJump_ClimbUpLedgeTackleAnim);
			cAnimationState@ pAnimD = pMeshEnt.GetAnimationStateFromName(gsStalkerAnim_JumpExtraLongHangOnLedge);
			
			if (pAnimA !is null && 
				pAnimA.IsActive() &&
				pAnimA.GetRelativeTimePosition() > gfStalker_HangOnLedgeAnimMinAllowFallRelTimePos)
			{
				bRet = true;
			}
			else if (pAnimB !is null && 
					 pAnimB.IsActive())
			{
				if (pAnimB.GetRelativeTimePosition() < 0.55f)
				{
					bRet = true;
				}
				else
				{
					abClimbedUp = true;
				}
			}
			else if (pAnimC !is null &&
					 pAnimC.IsActive())
			{
				if (pAnimC.GetRelativeTimePosition() < 0.3f)
				{
					bRet = true;
				}
				else
				{
					abClimbedUp = true;
				}
			}
			else if (pAnimD !is null &&
					 pAnimD.IsActive() &&
					 pAnimD.GetRelativeTimePosition() > gfStalker_HangOnLedgeLongAnimMinAllowFallRelTimePos)
			{
				bRet = true;
			}
		}
		
		return bRet;
	}
	
	//------------------------------------------------------------
	
	void BossFightJump_PlayFallLoopAnim(const tString &in asPrevAnim, float afTimePos, float afFadeTime, float afVelocityY, float afAnimSpeed)
	{
		//////////////////
		// Setup vars
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		cAnimationState@ pAnim = pMeshEnt.GetAnimationStateFromName(asPrevAnim);
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
					
		if (pMeshEnt is null) return;
		if (pAnim is null) return;
		if (pCharBody is null) return;
		
		//////////////////
		// Calculate offset
		tString sRootBone = "j_Root";
		cMatrixf mtxCurrent = pMeshEnt.GetBoneWorldMatrixInAnim(sRootBone, asPrevAnim, afTimePos, false);
		cMatrixf mtxNext = pMeshEnt.GetBoneWorldMatrixInAnim(sRootBone, gsStalkerAnim_Fall, 0.f, false);

		cVector3f vDiff = mtxCurrent.GetTranslation() - mtxNext.GetTranslation();		
		cVector3f vNewPos = pCharBody.GetFeetPosition() + vDiff;			
		
		if (afFadeTime <= 0.f)
			pCharBody.SetFeetPosition(vNewPos, false);
		
		//////////////////
		// Play anim
		PlayCutsceneAnimation(gsStalkerAnim_Fall, true, afFadeTime, "", afAnimSpeed, 0.f, true, vNewPos, pCharBody.GetYaw(), false, false, true);
		
		//////////////////
		// Set velocity
		if (afVelocityY == 0.f)
		{
			float fPrevTimePos = afTimePos - 0.1f;
			cMatrixf mtxPrev = pMeshEnt.GetBoneWorldMatrixInAnim(sRootBone, asPrevAnim, fPrevTimePos, false); 
			mvBossFightJump_FallVelocity = (mtxCurrent.GetTranslation() - mtxPrev.GetTranslation()) * 10.f;
		}
		else
		{
			mvBossFightJump_FallVelocity = cVector3f(0.f);
			mvBossFightJump_FallVelocity.y = afVelocityY;
		}
	}
	
	//------------------------------------------------------------

	//} END BOSS FIGHT JUMP
	
	///////////////////////////////////
	// STATE: BOSS FIGHT PACE
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbBossFightPace_Sitting = false;
	bool mbBossFightPace_TurnToPlayer = false;
	cVector3f mvBossFightPace_PacePosition(0.f);
	
	//------------------------------------------------------------

	void State_BossFightPace_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BossFightPace ------");
		
		SetAlertState(eStalkerAlertState_Detected);
		SetSpeedState(eStalkerSpeed_Walk);
		
		mbPresencePaused = true;
		mpPathfinder.Stop();
		
		mbBossFightPace_Sitting = false;
		mbBossFightPace_TurnToPlayer = false;
		
		int lPrevState = mpStateMachine.GetPrevState();
		if (lPrevState == eStalkerState_BossFight_Default && 
			lPrevState != eStalkerState_Alert)
		{
			mpStateMachine.AddTimer("Roar", 0.3f);
		}
		else
		{
			mpStateMachine.AddTimer("Move", 0.f);
		}
	}	
	
	//------------------------------------------------------------
	
	void State_BossFightPace_Leave() 
	{
		mbPresencePaused = false;
		
		if (mbBossFightPace_Sitting)
			mpMover.PlayAnimation(gsStalkerAnim_SitEnd, 0.3f, false, true);
	}	
	
	//------------------------------------------------------------
	
	void State_BossFightPace_Update(float afTimeStep) 
	{		
		///////////////////
		// Update removed blockers
		BossFight_UpdateTemporarilyRemovedBlockers();
		
		/////////////////////
		// Turning? Play anim when done!
		if (mbBossFightPace_TurnToPlayer)
		{
			if (mbPlayQuickTurnAnim == false)
			{
				mbBossFightPace_TurnToPlayer = false;
				BossFightPace_PlaySitAnim();
			}		
			return;
		}
	}
	
	//------------------------------------------------------------
	
	void State_BossFightPace_TimerUp(uint64 alId)
	{
		/////////////////
		// Roar
		if (H64("Roar") == alId)
		{			
			if (mlAlert_LastAlertTimeStamp > 0 && 
				mBaseObj.GetMap().GetElapsedTime(mlAlert_LastAlertTimeStamp) < 10.f)
			{
				mpStateMachine.AddTimer("Move", 0.f);	
			}
			else
			{
				mpStateMachine.ChangeState(eStalkerState_Alert);
			}		
		}
		
		/////////////////
		// Move
		else if (H64("Move") == alId)
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvBossFightPace_PacePosition, 0.f, 5.f, true, false, false, null);
			if (pNode !is null)
			{
				if (BossFight_MoveTo(pNode.GetPosition()) == false)
					return;
			}
			
			mpStateMachine.AddTimer("Move", 0.1f);
		}
		
		/////////////////
		// Wait
		else if (H64("Wait") == alId)
		{						
			///////////////////
			// Turn toward player?
			iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
			
			cVector3f vToPlayer = mBaseObj.GetPlayerDir();
			float fAngle = cMath_GetAngleFromPoints3D(0, vToPlayer).y;
			float fAngleDiff = cMath_GetAngleDistanceRad(pCharBody.GetYaw(), fAngle);
			float fAbsAngleDiff = cMath_Abs(fAngleDiff);
			
			if (fAbsAngleDiff > cMath_PiDiv4)
			{
				mbBossFightPace_TurnToPlayer = true;
				
				////////////////////
				// Play turn anim
				mfQuickTurnGoalYaw = fAngle;
				
				if (fAbsAngleDiff >= gfStalker_PlayTurnAroundAnimMinAngle)
					mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
				else
					mQuickTurnAnimType = fAngleDiff > 0.f ? eStalkerQuickTurnType_Left : eStalkerQuickTurnType_Right;
				
				PlayQuickTurnAnim();
			}
			
			///////////////////
			// Play sit anim
			else
			{
				BossFightPace_PlaySitAnim();
			}	
		}
		
		/////////////////
		// Update path to player
		else if (H64("UpdatePathToPlayer") == alId)
		{
			///////////////
			// Update behaviour in map
			cLuxMap@ pMap = mBaseObj.GetMap();
			if (pMap !is null)
			{
				tString sCallback = "void OnStalkerMoveTo(int alBehaviour, const cVector3f &in avGoalPos)";
				if (pMap.ScriptMethodExists(sCallback) && pMap.ScriptPrepare(sCallback))
				{
					pMap.SetArgInt(0, mBossFight_Behaviour);
					pMap.SetArgVector3f(1, mBaseObj.GetPlayerPos());
					pMap.ScriptExecute();
				}
			}
			
			mpStateMachine.AddTimer("UpdatePathToPlayer", 1.f);
		}
	}
	
	//------------------------------------------------------------
	
	bool State_BossFightPace_Message(int alMessageId) 
	{
		if (alMessageId == eCustomEntityMessage_RabbitDollAttract) return false;
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
		/////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if ((mvBossFightPace_PacePosition - mBaseObj.GetPosition()).SqrLength() < 3.f * 3.f)
			{
				mpStateMachine.StopTimer("Move");
				mpStateMachine.AddTimer("Wait", 0.f);
			}			
		}
		
		///////////////
		// Grenade detected
		else if (alMessageId == eCustomEntityMessage_GrenadeDetected)
		{
			if (BossFightRetreat_Setup())
				BossFight_UpdateBehaviour(eStalkerBossFightBehaviour_Retreat);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Detected grenade!", false, true);
		}
		
		////////////////////
		// Animation message
		else if (alMessageId == eLuxEntityMessage_AnimationMessageEvent &&
				 mbBossFightPace_Sitting)
		{
			int lMessage = mpStateMachine.GetCurrentMessageData().mlX;
			if (lMessage == 4)
			{
				mBaseObj.PlaySound("Breathe", "creatures/stalker/breathe_idle", true, true);
			}			
			else if (lMessage == 5)
			{
				mBaseObj.PlaySound("HandL", "creatures/stalker/hand_walk", true, false);
			}
			else if (lMessage == 6)
			{
				mBaseObj.PlaySound("HandR", "creatures/stalker/hand_walk", true, false);
			}
			
			return true;
		}
		
		return true; 
	}
	
	//------------------------------------------------------------
	
	void BossFightPace_PlaySitAnim()
	{
		mbBossFightPace_Sitting = true;
		
		mpMover.SetSpeedState(eStalkerSpeed_Stopped);
		mpMover.PlayAnimation(gsStalkerAnim_SitLoop, 0.3f, true, true);
		
		mpStateMachine.AddTimer("UpdatePathToPlayer", 1.f);
	}
	
	//------------------------------------------------------------

	//} END BOSS FIGHT PACE
	
	///////////////////////////////////
	// STATE: BOSS FIGHT RETREAT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvBossFightRetreat_Pos(0.f);
	array<cVector3f> mvBossFightRetreat_Positions;
	
	//------------------------------------------------------------

	void State_BossFightRetreat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BossFightRetreat ------");
		
		SetAlertState(eStalkerAlertState_Detected);
		SetSpeedState(eStalkerSpeed_Run);
		
		mbPresencePaused = true;
		
		mpStateMachine.AddTimer("Move", 0.f);
	}	
	
	//------------------------------------------------------------
	
	void State_BossFightRetreat_Leave() 
	{
		mbPresencePaused = false;
	}	
	
	//------------------------------------------------------------
	
	void State_BossFightRetreat_Update(float afTimeStep) 
	{
		///////////////////
		// Update removed blockers
		BossFight_UpdateTemporarilyRemovedBlockers();
		
		////////////////////
		// Throw player?
		if (mpStateMachine.GetPrevState() == eStalkerState_ThrowPlayer)
			return;
		
		if (mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos()) == false)
			return;
		
		if (mBaseObj.GetCharBody().GetMoveSpeed(eCharDir_Forward) < 3.f)
			return;
			
		if (cLux_GetPlayer().GetCurrentStateId() == ePlayerState_Ladder)
			return;
		
		if (mbPlayerIsHiding)
		{
			if (mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Touching) == false)
				return;
		}
		else
		{
			if (mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Close) == false &&
				mpProximitySensor.GetPlayerInsideState(eStalkerProximity_Touching) == false)
			{
				return;
			}
		}
		
		if (cLux_CheckLineOfSight(mBaseObj.GetPosition(), mBaseObj.GetPlayerHeadPos(), false, false, null) == false)
			return;
		
		ThrowPlayer_ThrowPlayerWhileInCutscene(mBaseObj.GetPlayerFeetPos());
	}
	
	//------------------------------------------------------------
	
	void State_BossFightRetreat_TimerUp(uint64 alId)
	{
		////////////////////
		// Move
		if (H64("Move") == alId)
		{
			BossFight_MoveTo(mvBossFightRetreat_Pos);
			mpStateMachine.AddTimer("Move", 0.1f);
		}
	}
	
	//------------------------------------------------------------
	
	bool State_BossFightRetreat_Message(int alMessageId) 
	{
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_GrenadeImpact) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
		////////////////////
		// End of path
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.StopTimer("Move");
			
			msAnimState = "Recover";
			mpMover.PlayAnimation(gsStalkerAnim_ShotAttack, 0.3f, false);
		}
		
		////////////////////
		// Animation over
		else if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "Recover")
			{
				mBossFight_Behaviour = eStalkerBossFightBehaviour_Default;
				mpStateMachine.ChangeState(eStalkerState_Alert);
			}
		}
		
		return true; 
	}
	
	//------------------------------------------------------------
	
	bool BossFightRetreat_Setup()
	{	
		/////////////////////
		// Player at end? Don't retreat!
		cLuxArea@ pEndArea = cLux_ID_Area(m_idBossFight_EndArea);
		iCharacterBody@ pPlayerCharBody = cLux_GetPlayer().GetCharacterBody();
				
		bool bPlayerAtEnd = pEndArea !is null &&
							pPlayerCharBody !is null &&
							pEndArea.CheckCharacterCollision(pPlayerCharBody, mBaseObj.GetMap());
		
		if (bPlayerAtEnd)
		{
			mvBossFightRetreat_Pos = cVector3f(0.f);			
			return false;
		}
		
		/////////////////////
		// Get low prio retreat positions
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap is null) return false;
		
		array<cVector3f> vLowPrioRetreatPositions;
		
		tString sCallback = "tString GetLowPrioStalkerRetreatPositions()";
		if (pMap.ScriptMethodExists(sCallback) && pMap.ScriptPrepare(sCallback))
		{
			pMap.ScriptExecute();
			
			array<tString> vPositions;
			cString_GetStringVec(pMap.GetReturnString(), vPositions, ";");
			for (int i = 0; i < vPositions.size(); ++i)
			{
				vLowPrioRetreatPositions.push_back(cString_ToVector3f(vPositions[i], cVector3f(0.f)));
			}
		}		
		
		/////////////////////
		// Get best pos
		Blackboard_SetPlayerBlocksPath(mBaseObj, true);
		
		mvBossFightRetreat_Pos = cVector3f(0.f);
		
		cVector3f vPlayerPos = mBaseObj.GetPlayerFeetPos();
		cVector3f vFeetPos = mBaseObj.GetCharBody().GetFeetPosition();		
		cVector3f vToPlayer = cMath_Vector3Normalize(vPlayerPos - vFeetPos);
		
		array<cVector3f> vPositions;
		array<cVector3f> vBackupPositions;
		
		for (int i = 0; i < mvBossFightRetreat_Positions.size(); ++i)
		{
			cVector3f vPos = mvBossFightRetreat_Positions[i];
			cVector3f vToPos = vPos - vFeetPos;
			
			float fDistSqr = vToPos.SqrLength();
			if (fDistSqr < 15.f * 15.f ||
				fDistSqr > 30.f * 30.f)
			{
				continue;
			}
			
			float fDistToPlayerSqr = (vPos - vPlayerPos).SqrLength();
			if (fDistToPlayerSqr < 10.f * 10.f)
			{
				continue;
			}
			
			bool bIsBackupPos = false;
			for (int j = 0; j < vLowPrioRetreatPositions.size(); ++j)
			{
				if ((vLowPrioRetreatPositions[j] - vPos).SqrLength() <= 1.f)
				{
					bIsBackupPos = true;
					break;
				}
			}
			
			if (bIsBackupPos == false && 
				mpPathfinder.BuildPathNodeArrayToPos(vPos, 1) == false)
			{
				bIsBackupPos = true;
			}
			
			float fDot = cMath_Vector3Dot(vToPlayer, cMath_Vector3Normalize(vToPos));
			if (fDot < 0.3f)
			{
				if (bIsBackupPos) vBackupPositions.push_back(vPos);
				else			  vPositions.push_back(vPos);
			}
			else
			{
				vBackupPositions.push_back(vPos);
			}
		}
		
		Blackboard_SetPlayerBlocksPath(mBaseObj, false);
		
		if (vPositions.size() > 0)
		{
			mvBossFightRetreat_Pos = vPositions[cMath_RandRectl(0, vPositions.size() - 1)];
		}
		else if (vBackupPositions.size() > 0)
		{
			mvBossFightRetreat_Pos = vBackupPositions[cMath_RandRectl(0, vBackupPositions.size() - 1)];
		}
		
		return mvBossFightRetreat_Pos.SqrLength() > 0.f;
	}
	
	//------------------------------------------------------------

	//} END BOSS FIGHT RETREAT
	
	///////////////////////////////////
	// STATE: MAP TRANSFER
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlMapTransfer_NextState = eStalkerState_Idle;
	cVector3f mvMapTransfer_GoalPos(0.f);
	
	//------------------------------------------------------------

	void State_MapTransfer_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: MapTransfer ------");
		
		mbPresencePaused = true;
		
		/////////////////////
		// Get goal node
		cLuxArea@ pArea = null;		
		for (int i = 0; i < mvMapTransferData_TransferAreaIds.size(); ++i)
		{
			@pArea = cLux_ID_Area(mvMapTransferData_TransferAreaIds[i]);
			cBoundingVolume@ pBV = pArea !is null ? pArea.GetAreaBody().GetBoundingVolume() : null;
			
			if (pArea is null) continue;
			if (pBV is null) continue;			
			
			if (cMath_CheckAABBSphereCollision(pBV.GetMin(), pBV.GetMax(), mBaseObj.GetPlayerPos(), 1.f))
				break;
		}
		
		if (pArea is null)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No map transfer area found, this shouldn't happen!");
			return;
		}
		
		tString sNode = MapTransferArea_GetTransferAINode(pArea.GetName());
		cAINode@ pNode = mpPathfinder.GetNodeFromName(sNode);
		
		if (pNode is null)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No transfer node set, this shouldn't happen!");
			return;
		}
		
		mvMapTransfer_GoalPos = pNode.GetPosition();
		
		/////////////////////
		// Set yaw
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		float fYaw = pCharBody.GetYaw();
		
		cAINode@ pNextNode = mpPathfinder.GetNodeAtPos(mvMapTransfer_GoalPos, 0.f, 5.f, true, false, false, pNode);
		if (pNextNode !is null)
		{
			cVector3f vPathDir = pNextNode.GetPosition() - mvMapTransfer_GoalPos;
			fYaw = cMath_GetAngleFromPoints3D(0.f, vPathDir).y;
		}
		
		pCharBody.SetYaw(fYaw);
		
		/////////////////////
		// Turn off collision and play run anim	
		pCharBody.SetTestCollision(false);
		pCharBody.SetGravityActive(false);
		pCharBody.StopMovement();
		
		mpMover.SetSpeedState(eStalkerSpeed_Stopped);
		mpMover.PlayAnimation(gsStalkerAnim_RunMapTransfer, 0.f, true, false);
	}	
	
	//------------------------------------------------------------
	
	void State_MapTransfer_Leave() 
	{
		mbPresencePaused = false;
		mlMapTransfer_NextState = eStalkerState_Idle;
		
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		pCharBody.SetTestCollision(true);
		pCharBody.SetGravityActive(true);
		
		mpMover.SetUseMoveStateAnimations(true);		
		mBaseObj.SetSensesActive(true);
	}	
	
	//------------------------------------------------------------
	
	void State_MapTransfer_Update(float afTimeStep) 
	{
		////////////////////
		// Move to goal!
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pCharBody is null) return;
		
		cVector3f vPos = pCharBody.GetFeetPosition();
		cVector3f vDir = mvMapTransfer_GoalPos - vPos;		
		
		float fDist = vDir.Length();
		vDir.Normalize();
			
		float fFrameMove = cMath_Clamp(4.f * afTimeStep, 0.f, fDist);
		vPos += vDir * fFrameMove;
			
		pCharBody.SetFeetPosition(vPos, false);
			
		/////////////////
		// At goal?
		if (fFrameMove <= 0.001f)
		{			
			pCharBody.SetFeetPosition(mvMapTransfer_GoalPos, false);			
			mpStateMachine.ChangeState(mlMapTransfer_NextState);
		}
	}
	
	//------------------------------------------------------------
	
	bool State_MapTransfer_Message(int alMessageId) 
	{
		return true;
	}
	
	//------------------------------------------------------------

	//} END MAP TRANSFER
	
	///////////////////////////////////
	// STATE: NULL
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_Null_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Null ------");
		
		SetAlertState(eStalkerAlertState_None);
		
		mbPresencePaused = true;
		
		mpPathfinder.Stop();
		mpMover.StopTurning();
		mBaseObj.GetCharBody().StopMovement();
		mBaseObj.StopAllAnimations(0.f);
	}	
	
	//------------------------------------------------------------
	
	void State_Null_Leave() 
	{
		mbPresencePaused = false;
	}	
	
	//------------------------------------------------------------
	
	void State_Null_Update(float afTimeStep) {}
	
	//------------------------------------------------------------
	
	bool State_Null_Message(int alMessageId) 
	{
		///////////////////////
		// Sound heard 
		// (Only care about this if map change transition is active)
		if (alMessageId == eCustomEntityMessage_PlayerShotGun ||
			alMessageId == eLuxEntityMessage_SoundHeard)
		{
			////////////////////
			// Filter
			if (mBaseObj.Timer_Exists("Timer_SetupAfterMapTransfer") == false)
				return true;
			
			bool bGunShot = alMessageId == eCustomEntityMessage_PlayerShotGun;
			int lPrio = bGunShot ? 6 : mpStateMachine.GetCurrentMessageData().mlX;	
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;
			
			if (lPrio < 5) return true;
			
			ResetRecentlyHurtIfSoundInterestingEnough(lPrio);
			
			if (GetShouldIgnoreSound()) return true;
			
			tID idHole = InHole_GetBestEmergeHoleFromPos(vPos);
			if (idHole == tID_Invalid) return true;
			
			ChangeMode(eStalkerMode_Active, true);
			
			m_idMoveBetweenHoles_GoalHole = idHole;
			m_idMoveBetweenHoles_EmergeHole = idHole;
			mpStateMachine.ChangeState(eStalkerState_MoveBetweenHoles);
			
			mBaseObj.Timer_Remove("Timer_SetupAfterMapTransfer");
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	//} END NULL
	
	///////////////////////////////////
	// STATE: DEBUG
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_Debug_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Debug ------");
		
		SetSpeedState(eStalkerSpeed_Walk);
		mBaseObj.SetSensesActive(false);
		
		mbPresencePaused = true;
		
		mpStateMachine.AddTimer("Move", 0.1f);
	}	
	
	//------------------------------------------------------------
	
	void State_Debug_Leave() 
	{		
		mbPresencePaused = false;
	}	
	
	//------------------------------------------------------------
	
	void State_Debug_Update(float afTimeStep) 
	{		
	}
	
	//------------------------------------------------------------
	
	void State_Debug_TimerUp(uint64 alId)
	{
		if (H64("Move") == alId)
		{
			mpPathfinder.MoveTo(mBaseObj.GetPlayerFeetPos(), 1.f, false);
			mpStateMachine.AddTimer("Move", 0.1f);
		}
	}
	
	//------------------------------------------------------------
	
	bool State_Debug_Message(int alMessageId) 
	{
		if (alMessageId == eLuxEntityMessage_NearDoor) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		return true; 
	}

	//------------------------------------------------------------

	//} END DEBUG
	
	//} END STALKER SPECIFIC CODE

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// PROPERTIES
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	////////////////
	// Components
	cLuxStateMachine@ mpStateMachine;
	cLuxSoundListener@ mpSoundListener;
	cLuxHeadTracker@ mpHeadTracker;
	cLuxLightSensor@ mpLightSensor;
	cLuxProximitySensor@ mpProximitySensor;
	cLuxAttackDamage@ mpAttackDamage;
	cLuxFootPlacement@ mpFootPlacement;
	cLuxVerletAnimation@ mpVerletAnimation;
	
	tString msHeadTracker_TargetEntity = "";
	tID m_idHeadTracker_TargetEntity = tID_Invalid;
	
	bool mbVerletEnabled = true;
	[nosave] bool mbVerletModuleInitialized = false;
	
	////////////////
	// Setup
	[nosave] bool mbSetup = false;
	bool mbStarted = false;
		
	////////////////
	// General
	eStalkerAlertState mAlertState = eStalkerAlertState_None;
	tString msAnimState = "";
	bool mbIsInLiquid = false;
	bool mbHidden = false;
	bool mbPlayerIsInSaveRoom = false;
	bool mbWasInActiveModeWhenPlayerEnteredSaveRoom = false;
	bool mbIsOnScreen = false;
	float mfPlayerLeftSaveRoomCount = 0.f;
	float mfFallingFailSafeUpdateCount = 1.f;
	int mlPathfindingFailCount = 0;
	array<tID> mvHideAreaIds;
	array<cStalker_DoorAABB> mvDoorAABBs;
	
	////////////////
	// Map change
	int mlMapTransferData_SetupStage = -1;
	bool mbMapTransferData_InsideTransferArea = false;
	bool mbMapTransferData_RetreatActive = false;
	eStalkerAlertState mMapTransferData_AlertState = eStalkerAlertState_None;
	bool mbMapTransferData_EmergeAllowed = true;
	bool mbMapTransferData_RecentlyHurt = false;
	float mfMapTransferData_Presence = 0.f;
	float mfMapTransferData_Tenacity = 1.f;
	bool mbMapTransferData_InterestAlert = false;
	bool mbMapTransferData_Emerging = false;
	float mfMapTransferData_InterestAreaRadius = -1.f;
	float mfMapTransferData_InterestIncreaseCount = 0.f;
	float mfMapTransferData_InterestPauseEmergeCount = 0.f;
	float mfMapTransferData_InterestEmergeCount = 0.f;
	float mfMapTransferData_InterestEmergeTime = 1.f;
	cVector3f mvMapTransferData_InterestAreaPos = cVector3f(0.f);
	eStalkerState mlMapTransferData_State = eStalkerState_Stalk;
	eStalkerMode mMapTransferData_Mode = eStalkerMode_Active;
	array<tID> mvMapTransferData_TransferAreaIds;
	
	///////////////
	// Mode
	eStalkerMode mMode = eStalkerMode_Active;
	float mfPresence = 0.f;
	float mfPresenceIncreaseMul = 1.f;
	float mfPresenceDecreaseMul = 1.f;
	float mfRandPresenceDecreaseMul = 1.f;
	float mfTenacity = 1.f;
	bool mbPresencePaused = false;
	
	////////////////
	// Move anims
	tString msIdleAnim = gsStalkerAnim_Idle;
	tString msWalkAnim = gsStalkerAnim_Walk;
	tString msWalkCrampedAnim = gsStalkerAnim_WalkCramped;
	tString msRunAnim = gsStalkerAnim_Run;
	bool mbAllowUprightWalk = true;
	bool mbShouldWalkUpright = false;
	float mfAllowUprightWalkCount = 0.f;
	
	/////////////////
	// Head anims
	float mfHeadAnimation_PlayCount = 0.f;
	int mlHeadAnimation_CurrentId = -1;
	eStalkerHeadAnimationType mHeadAnimation_CurrentType = eStalkerHeadAnimationType_Mouth;
	
	array<int> mvHeadAnimation_MouthAnimIndices;
	array<int> mvHeadAnimation_TwistAnimIndices;
	array<int> mvHeadAnimation_TwitchAnimIndices;
	
	/////////////////
	// Head adjustment
	bool mbHeadAdjustment_HeadColliding = false;
	cMatrixf mtxHeadAdjustment_Offset = cMatrixf_Identity;
	[nosave] iCollideShape@ mpHeadAdjustment_Shape = null;
	
	////////////////
	// Senses
	float mfSightMul = 1.0f;
	float mfHearingMul = 1.0f;
	float mfHearRadius = 1.0f;
	float mfIsInPlayerProximityTimer = 0.f;
	bool mbEyePositionAtHeadSocket = false;
	
	////////////////
	// Player los check
	bool mbPlayerIsInLos = false;
	float mfPlayerLosCounter = 0.0f;
	float mfTimeSincePlayerInLoS = 100.0f;
	
	////////////////
	// Proximity detection
	float mfProximityDetectionTimer = 0.0f;
	bool mbProximityDetectionActive = true;
	
	////////////////
	// Flashlight detection
	bool mbDetectFlashlight = true;
	float mfGoboCount = 0.0f;
	float mfHitByFlashlightCount = 0.0f;
	cVector3f mvGoboPos = cVector3f(0.f);
		
	////////////////
	// Pathfinding
	float mfDirectPathMaxDistanceMul = 0.25f;
	bool mbFootstepSoundsActive = true;
	
	////////////////
	// Hole shortcut
	bool mbCheckHoleShortcut_ForceCheck = false;
	float mfCheckHoleShortcut_UpdateCount = 0.f;
	cVector3f mvCheckHoleShortcut_ForcedCheckTarget;
	int mlCheckHoleShortcut_Stage = 0;
	float mfCheckHoleShortcut_PathDistToTarget = -1.f;
	float mfCheckHoleShortcut_PathDistToClosestHole = -1.f;
	float mfCheckHoleShortcut_PathDistToTargetHole = -1.f;
	tID m_idCheckHoleShortcut_ClosestHole = tID_Invalid;
		
	////////////////
	// Spawning system
	tString msHoleNetwork = "";	
	[nosave] int mlGhoulHoleNetworkId = -1;	
	bool mbEmergeAllowed = true;
	
	////////////////
	// Hit by prop
	bool mbLastHitByPropThrownByPlayer = false;
	bool mbLastHitByPropWasMolotov = false;
	tID m_idLastHitByPropThrownByPlayerId = tID_Invalid;
	array<cStalker_CollidePropData> mvCollideProps;
	
	////////////////
	// No collision bodies
	array<tID> mvNoCollBodies;
	array<uint> mvNoCollBodiesCollGroups;
	float mfNoCollisionBodiesUpdateCount = 0.2f;
	
	////////////////
	// Sound counter
	float mfSoundCounter;
	
	/////////////////
	// Cramped anim
	bool mbUseCrampedAnims = false;
	float mfUpdateWalkAnimCount = 0.f;
	[nosave] iCollideShape@ mpCrampedAnimShape = null;
	
	/////////////////
	// Quick turn anim
	bool mbPlayQuickTurnAnim = false;
	float mfQuickTurnStartYaw = 0.f;
	float mfQuickTurnGoalYaw = 0.f;
	float mfQuickTurnCount = 0.f;
	int mlQuickTurnTimeStamp = 0;
	int mlQuickTurnDoneState = -1;
	tString msQuickTurnAnim = "";
	eStalkerQuickTurnType mQuickTurnAnimType = eStalkerQuickTurnType_TurnAround;
		
	////////////////////
	// Flickering lights
	bool mbMakeLampsFlicker = true;
	int mlLampFlickerUpdateFrame = 0;
	array<tString> mvLampsInCurrentLevel;
	
	////////////////
	// Interest
	cVector3f mvInterest_AreaPos(0.f);
	float mfInterest_MapRadius = -1.f;
	float mfInterest_AreaRadius = -1.f;
	bool mbInterest_Alert = false; 
	float mfInterest_IncreaseCount = 0.f;
	float mfInterest_PauseEmergeCount = 0.f;
	float mfInterest_EmergeCount = 0.f;
	float mfInterest_EmergeTime = 1.f;
	
	////////////////
	// Player hiding
	bool mbPlayerIsHiding = false;
	bool mbPlayerHidWhileSpotted = false;
	
	////////////////
	// Player prediction
	float mfPlayerPrediction_UpdateCount = gfStalker_PlayerPredictionIntervalTime;
	array<cVector3f> mvPlayerPrediction_VelocityBuffer;
	
	////////////////////
	// Grenade tracking
	array<tID> mvTrackedGrenades;
	
	////////////////////
	// First encounter achievement tracking
	bool mbFirstEncounterHasStarted = false;
	float mfFirstEncounterUpdateTimer = 0;
	
	//------------------------------------------------------------

	//} END PROPERTIES

	//------------------------------------------------------------

	/////////////////////////////////////////
	// DEBUG
	//{//////////////////////////////////////

	//------------------------------------------------------------

	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afStartY)
	{
		if (Blackboard_GetAgentCount() > 4) return afStartY;
		
		tString sAnimationState = "";
		if (mAlertState == eStalkerAlertState_None) 				sAnimationState = "Patrol";
		else if (mAlertState == eStalkerAlertState_Investigating) 	sAnimationState = "Stalk";
		else if (mAlertState == eStalkerAlertState_Detected) 		sAnimationState = "Rage";
		
		afStartY += 10.0f;
		
		afStartY = cLux_DrawDebugText("Escalation: " + EscalationStageToString(Blackboard_GetStalkerEscalation()), afStartY);
		afStartY = cLux_DrawDebugText("Player distance: " + mBaseObj.GetDistanceToPlayer(), afStartY);
		afStartY = cLux_DrawDebugText("Stuck: " + mpMover.GetStuckCounter(), afStartY);
		afStartY = cLux_DrawDebugText("Sound counter: " + mfSoundCounter, afStartY);
		afStartY = cLux_DrawDebugText("Senses active: " + GetSensesActive(), afStartY);
		afStartY = cLux_DrawDebugText("Speed state: " + SpeedStateToString(mpMover.GetSpeedState()), afStartY);
		afStartY = cLux_DrawDebugText("Speed: " + mBaseObj.GetCharBody().GetMoveSpeed(eCharDir_Forward), afStartY);
		afStartY = cLux_DrawDebugText("Alert state: " + AlertStateToString(mAlertState), afStartY);
		afStartY = cLux_DrawDebugText("Interest alert: " + mbInterest_Alert, afStartY);
		afStartY = cLux_DrawDebugText("Interest emerge: " + (mfInterest_EmergeCount / mfInterest_EmergeTime), afStartY);
		afStartY = cLux_DrawDebugText("Mode: " + ModeToString(mMode), afStartY);
		afStartY = cLux_DrawDebugText("Presence: " + mfPresence, afStartY);
		afStartY = cLux_DrawDebugText("Tenacity: " + mfTenacity, afStartY);
		afStartY = cLux_DrawDebugText("Emerge allowed: " + mbEmergeAllowed, afStartY);
		afStartY = cLux_DrawDebugText("Player sound count: " + mlInvestigateSound_PlayerSoundCount, afStartY);
		afStartY = cLux_DrawDebugText("High prio player sound count: " + mlInvestigateSound_EnterFromHighPrioPlayerSoundCount, afStartY);
		afStartY = cLux_DrawDebugText("Recently hurt: " + mbHurt_RecentlyHurt, afStartY);
		afStartY = cLux_DrawDebugText("Hurt by player: " + mbHurt_HurtByPlayer, afStartY);
		afStartY = cLux_DrawDebugText("Head tracker: " + mpHeadTracker.IsActive(), afStartY);
		afStartY = cLux_DrawDebugText("Animation state: " + sAnimationState, afStartY);
		afStartY = cLux_DrawDebugText("Animations: ", afStartY);
		
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();		
		for (int i = 0; i < pMeshEnt.GetAnimationStateNum(); ++i)
		{
			cAnimationState@ pState = pMeshEnt.GetAnimationState(i);
			if (pState.IsActive())
			{
				afStartY = cLux_DrawDebugText("   " + pState.GetName() + ", time: " + pState.GetRelativeTimePosition() + ", speed: " + pState.GetSpeed() + ", weight: " + pState.GetWeight(), afStartY);
			}
		}

		return afStartY;
	}

	//------------------------------------------------------------	
	
	void OnRenderSolid(cRendererCallbackFunctions@ apFunctions)
	{						
		///////////////////
		// Interest		
		if (mfInterest_AreaRadius < mfInterest_MapRadius)
		{
			StalkerDebug_DrawCircle(apFunctions, mvInterest_AreaPos, gfStalker_AlertInterestAreaRadiusMax, cColor_Green);
			StalkerDebug_DrawCircle(apFunctions, mvInterest_AreaPos, gfStalker_AlertInterestAreaRadiusMin, cColor_Blue);
			
			float fT = mfInterest_EmergeCount / mfInterest_EmergeTime;
			cColor radiusColor = cColor_White * (1.f - fT) + cColor_Red * fT;
			StalkerDebug_DrawCircle(apFunctions, mvInterest_AreaPos, mfInterest_AreaRadius, radiusColor);
		}	
		
		///////////////////
		// Stalk
		if (mpStateMachine.GetCurrentState() == eStalkerState_Stalk)
		{
			if (mbInterest_Alert)
				StalkerDebug_DrawCircle(apFunctions, mvStalk_BasePos, mfInterest_AreaRadius, cColor_Red);
		}
		
		///////////////////
		// Search
		if (mpStateMachine.GetCurrentState() == eStalkerState_SearchArea)
		{
			for (int i = 0; i < mvSearchArea_InterestPositions.size(); ++i)
				apFunctions.GetLowLevelGfx().DrawSphere(mvSearchArea_InterestPositions[i].mvPos, 1.f, cColor(1,1,1,1));
		}
		
		///////////////////
		// Wait in hole
		if (mpStateMachine.GetCurrentState() == eStalkerState_WaitInHole)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 2, cColor(10,0,0,1));
			
			iLuxEntity@ pHole = cLux_ID_Entity(m_idMoveBetweenHoles_GoalHole);
			cVector3f vHolePos = pHole is null ? cVector3f(0.f) : pHole.GetPosition();
		}
		
		///////////////////
		// Move between holes
		if (mpStateMachine.GetCurrentState() == eStalkerState_MoveBetweenHoles)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 2, cColor(10,0,0,1));
			
			iLuxEntity@ pHole = cLux_ID_Entity(m_idMoveBetweenHoles_GoalHole);
			cVector3f vHolePos = pHole is null ? cVector3f(0.f) : pHole.GetPosition();
			apFunctions.GetLowLevelGfx().DrawSphere(vHolePos, 2, cColor(0,10,0,1));
			
			for (uint i = 1; i < mvMoveBetweenHoles_Points.size(); ++i)
				apFunctions.GetLowLevelGfx().DrawLine(mvMoveBetweenHoles_Points[i - 1], mvMoveBetweenHoles_Points[i], cColor(0,10,0,1));
		}
		
		///////////////////
		// Map transfer
		if (mpStateMachine.GetCurrentState() == eStalkerState_MapTransfer)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 2, cColor(10,0,0,1));
			apFunctions.GetLowLevelGfx().DrawSphere(mvMapTransfer_GoalPos, 2, cColor(0,10,0,1));
		}
	}
	
	//------------------------------------------------------------
	
	void StalkerDebug_DrawCircle(cRendererCallbackFunctions@ apFunctions, const cVector3f &in avCenter, 
							     float afRadius, const cColor &in aColor)
	{
		int lSegments = 20;
		float fPrevAngle = 0.f;
		for (int i = 1; i <= lSegments; ++i)
		{
			float fAngle = (cMath_PiMul2 / lSegments) * i;
			
			cVector3f vStart = avCenter + cVector3f(cMath_Cos(fPrevAngle), 0.f, cMath_Sin(fPrevAngle)) * afRadius;
			cVector3f vEnd = avCenter + cVector3f(cMath_Cos(fAngle), 0.f, cMath_Sin(fAngle)) * afRadius;
				
			fPrevAngle = fAngle;
				
			apFunctions.GetLowLevelGfx().DrawLine(vStart, vEnd, aColor);
		}
	}
	
	//------------------------------------------------------------

	//} END DEBUG
}
